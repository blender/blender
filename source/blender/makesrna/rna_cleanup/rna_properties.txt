 NOTE * CLASS.FROM -> TO:   TYPE  "DESCRIPTION"
#+ * ActionGroup.channels -> channels:   collection,  "(read-only)    F-Curves in this group"
#+ * ActionGroup.custom_color -> custom_color:   int  "Index of custom color set"
#+ * ActionGroup.lock -> lock:   boolean  "Action Group is locked"
#+ * ActionGroup.name -> name:   string  "NO DESCRIPTION"
#+ * ActionGroup.select -> select:   boolean  "Action Group is selected"
#ActionGroup.show_expanded -> show_expanded:   boolean  "Action Group is expanded"
#+ * Actuator.name -> name:   string  "NO DESCRIPTION"
#Actuator.pin -> pin:   boolean  "Display when not linked to a visible states controller"
#Actuator.show_expanded -> show_expanded:   boolean  "Set actuator expanded in the user interface"
#+ * Actuator.type -> type:   enum  "NO DESCRIPTION"
#+ * Actuator|ActionActuator.action -> action:   pointer  "NO DESCRIPTION"
#Actuator|ActionActuator.frame_blend_in -> frame_blend_in:   int  "Number of frames of motion blending"
#+ * Actuator|ActionActuator.frame_end -> frame_end:   int  "NO DESCRIPTION"
#+ * Actuator|ActionActuator.frame_property -> frame_property:   string  "Assign the actions current frame number to this property"
#+ * Actuator|ActionActuator.frame_start -> frame_start:   int  "NO DESCRIPTION"
#Actuator|ActionActuator.play_mode -> play_mode:   enum  "Action playback type"
#+ * Actuator|ActionActuator.priority -> priority:   int  "Execution priority - lower numbers will override actions with higher numbers. With 2 or more actions at once, the overriding channels must be lower in the stack"
#+ * Actuator|ActionActuator.property -> property:   string  "Use this property to define the Action position"
#Actuator|ActionActuator.use_continue_last_frame -> use_continue_last_frame:   boolean  "Restore last frame when switching on/off, otherwise play from the start each time"
#+ * Actuator|ArmatureActuator.bone -> bone:   string  "Bone on which the constraint is defined"
#+ * Actuator|ArmatureActuator.constraint -> constraint:   string  "Name of the constraint you want to control"
#+ * Actuator|ArmatureActuator.mode -> mode:   enum  "NO DESCRIPTION"
#+ * Actuator|ArmatureActuator.secondary_target -> secondary_target:   pointer  "Set weight of this constraint"
#+ * Actuator|ArmatureActuator.target -> target:   pointer  "Set this object as the target of the constraint"
#+ * Actuator|ArmatureActuator.weight -> weight:   float  "Set weight of this constraint"
#+ * Actuator|CameraActuator.axis -> axis:   enum  "Specify the axis the Camera will try to get behind"
#+ * Actuator|CameraActuator.height -> height:   float  "NO DESCRIPTION"
#+ * Actuator|CameraActuator.max -> max:   float  "NO DESCRIPTION"
#+ * Actuator|CameraActuator.min -> min:   float  "NO DESCRIPTION"
#+ * Actuator|CameraActuator.object -> object:   pointer  "Look at this Object"
#Actuator|ConstraintActuator.angle_max -> angle_max:   float  "Maximum angle (in degree) allowed with target direction. No correction is done if angle with target direction is between min and max"
#Actuator|ConstraintActuator.angle_min -> angle_min:   float  "Minimum angle (in degree) to maintain with target direction. No correction is done if angle with target direction is between min and max"
#+ * Actuator|ConstraintActuator.damping -> damping:   int  "Damping factor: time constant (in frame) of low pass filter"
#+ * Actuator|ConstraintActuator.damping_rotation -> damping_rotation:   int  "Use a different damping for orientation"
#+ * Actuator|ConstraintActuator.direction -> direction:   enum  "Set the direction of the ray"
#+ * Actuator|ConstraintActuator.direction_axis -> direction_axis:   enum  "Select the axis to be aligned along the reference direction"
#+ * Actuator|ConstraintActuator.distance -> distance:   float  "Set the maximum length of ray"
#+ * Actuator|ConstraintActuator.fh_damping -> fh_damping:   float  "Damping factor of the Fh spring force"
#+ * Actuator|ConstraintActuator.fh_height -> fh_height:   float  "Height of the Fh area"
#+ * Actuator|ConstraintActuator.limit -> limit:   enum  "NO DESCRIPTION"
#+ * Actuator|ConstraintActuator.limit_max -> limit_max:   float  "NO DESCRIPTION"
#+ * Actuator|ConstraintActuator.limit_min -> limit_min:   float  "NO DESCRIPTION"
#+ * Actuator|ConstraintActuator.material -> material:   string  "Ray detects only Objects with this material"
#+ * Actuator|ConstraintActuator.mode -> mode:   enum  "The type of the constraint"
#+ * Actuator|ConstraintActuator.property -> property:   string  "Ray detect only Objects with this property"
#+ * Actuator|ConstraintActuator.range -> range:   float  "Set the maximum length of ray"
#Actuator|ConstraintActuator.rotation_max -> rotation_max:   float[3]  "Reference Direction"
#+ * Actuator|ConstraintActuator.spring -> spring:   float  "Spring force within the Fh area"
#+ * Actuator|ConstraintActuator.time -> time:   int  "Maximum activation time in frame, 0 for unlimited"
#Actuator|ConstraintActuator.use_fh_normal -> use_fh_normal:   boolean  "Add a horizontal spring force on slopes"
#Actuator|ConstraintActuator.use_fh_paralel_axis -> use_fh_paralel_axis:   boolean  "Keep object axis parallel to normal"
#Actuator|ConstraintActuator.use_force_distance -> use_force_distance:   boolean  "Force distance of object to point of impact of ray"
#Actuator|ConstraintActuator.use_local -> use_local:   boolean  "Set ray along objects axis or global axis"
#Actuator|ConstraintActuator.use_material_detect -> use_material_detect:   boolean  "Detect material instead of property"
#Actuator|ConstraintActuator.use_normal -> use_normal:   boolean  "Set object axis along (local axis) or parallel (global axis) to the normal at hit position"
#Actuator|ConstraintActuator.use_persistent -> use_persistent:   boolean  "Persistent actuator: stays active even if ray does not reach target"
#+ * Actuator|EditObjectActuator.angular_velocity -> angular_velocity:   float[3]  "Angular velocity upon creation"
#+ * Actuator|EditObjectActuator.dynamic_operation -> dynamic_operation:   enum  "NO DESCRIPTION"
#+ * Actuator|EditObjectActuator.linear_velocity -> linear_velocity:   float[3]  "Velocity upon creation"
#+ * Actuator|EditObjectActuator.mass -> mass:   float  "The mass of the object"
#+ * Actuator|EditObjectActuator.mesh -> mesh:   pointer  "Replace the existing, when left blank Phys will remake the existing physics mesh"
#+ * Actuator|EditObjectActuator.mode -> mode:   enum  "The mode of the actuator"
#+ * Actuator|EditObjectActuator.object -> object:   pointer  "Add this Object and all its children (cant be on an visible layer)"
#+ * Actuator|EditObjectActuator.time -> time:   int  "Duration the new Object lives or the track takes"
#+ * Actuator|EditObjectActuator.track_object -> track_object:   pointer  "Track to this Object"
#Actuator|EditObjectActuator.use_3d_tracking -> use_3d_tracking:   boolean  "Enable 3D tracking"
#Actuator|EditObjectActuator.use_local_angular_velocity -> use_local_angular_velocity:   boolean  "Apply the rotation locally"
#Actuator|EditObjectActuator.use_local_linear_velocity -> use_local_linear_velocity:   boolean  "Apply the transformation locally"
#Actuator|EditObjectActuator.use_replace_display_mesh -> use_replace_display_mesh:   boolean  "Replace the display mesh"
#Actuator|EditObjectActuator.use_replace_physics_mesh -> use_replace_physics_mesh:   boolean  "Replace the physics mesh (triangle bounds only - compound shapes not supported)"
#Actuator|FCurveActuator.apply_to_children -> apply_to_children:   boolean  "Update F-Curve on all children Objects as well"
#Actuator|FCurveActuator.frame_end -> frame_end:   int  "NO DESCRIPTION"
#Actuator|FCurveActuator.frame_property -> frame_property:   string  "Assign the actions current frame number to this property"
#Actuator|FCurveActuator.frame_start -> frame_start:   int  "NO DESCRIPTION"
#Actuator|FCurveActuator.play_type -> play_type:   enum  "Specify the way you want to play the animation"
#Actuator|FCurveActuator.property -> property:   string  "Use this property to define the F-Curve position"
#Actuator|FCurveActuator.use_additive -> use_additive:   boolean  "F-Curve is added to the current loc/rot/scale in global or local coordinate according to Local flag"
#Actuator|FCurveActuator.use_force -> use_force:   boolean  "Apply F-Curve as a global or local force depending on the local option (dynamic objects only)"
#Actuator|FCurveActuator.use_local -> use_local:   boolean  "Let the F-Curve act in local coordinates, used in Force and Add mode"
#+ * Actuator|Filter2DActuator.filter_pass -> filter_pass:   int  "Set filter order"
#+ * Actuator|Filter2DActuator.glsl_shader -> glsl_shader:   pointer  "NO DESCRIPTION"
#+ * Actuator|Filter2DActuator.mode -> mode:   enum  "NO DESCRIPTION"
#+ * Actuator|Filter2DActuator.motion_blur_factor -> motion_blur_factor:   float  "Set motion blur factor"
#Actuator|Filter2DActuator.use_motion_blur -> use_motion_blur:   boolean  "Enable/Disable Motion Blur"
#+ * Actuator|GameActuator.filename -> filename:   string  "Load this blend file, use the // prefix for a path relative to the current blend file"
#+ * Actuator|GameActuator.mode -> mode:   enum  "NO DESCRIPTION"
#+ * Actuator|MessageActuator.body_message -> body_message:   string  "Optional message body Text"
#+ * Actuator|MessageActuator.body_property -> body_property:   string  "The message body will be set by the Property Value"
#+ * Actuator|MessageActuator.body_type -> body_type:   enum  "Toggle message type: either Text or a PropertyName"
#+ * Actuator|MessageActuator.subject -> subject:   string  "Optional message subject. This is what can be filtered on"
#+ * Actuator|MessageActuator.to_property -> to_property:   string  "Optional send message to objects with this name only, or empty to broadcast"
#+ * Actuator|ObjectActuator.angular_velocity -> angular_velocity:   float[3]  "Sets the angular velocity"
#+ * Actuator|ObjectActuator.damping -> damping:   int  "Number of frames to reach the target velocity"
#+ * Actuator|ObjectActuator.derivate_coefficient -> derivate_coefficient:   float  "Not required, high values can cause instability"
#+ * Actuator|ObjectActuator.force -> force:   float[3]  "Sets the force"
#+ * Actuator|ObjectActuator.force_max_x -> force_max_x:   float  "Set the upper limit for force"
#+ * Actuator|ObjectActuator.force_max_y -> force_max_y:   float  "Set the upper limit for force"
#+ * Actuator|ObjectActuator.force_max_z -> force_max_z:   float  "Set the upper limit for force"
#+ * Actuator|ObjectActuator.force_min_x -> force_min_x:   float  "Set the lower limit for force"
#+ * Actuator|ObjectActuator.force_min_y -> force_min_y:   float  "Set the lower limit for force"
#+ * Actuator|ObjectActuator.force_min_z -> force_min_z:   float  "Set the lower limit for force"
#+ * Actuator|ObjectActuator.integral_coefficient -> integral_coefficient:   float  "Low value (0.01) for slow response, high value (0.5) for fast response"
#+ * Actuator|ObjectActuator.linear_velocity -> linear_velocity:   float[3]  "Sets the linear velocity (in Servo mode it sets the target relative linear velocity, it will be achieved by automatic application of force. Null velocity is a valid target)"
#+ * Actuator|ObjectActuator.mode -> mode:   enum  "Specify the motion system"
#Actuator|ObjectActuator.offset_location -> offset_location:   float[3]  "Sets the location"
#Actuator|ObjectActuator.offset_rotation -> offset_rotation:   float[3]  "Sets the rotation"
#+ * Actuator|ObjectActuator.proportional_coefficient -> proportional_coefficient:   float  "Typical value is 60x integral coefficient"
#+ * Actuator|ObjectActuator.reference_object -> reference_object:   pointer  "Reference object for velocity calculation, leave empty for world reference"
#+ * Actuator|ObjectActuator.torque -> torque:   float[3]  "Sets the torque"
#Actuator|ObjectActuator.use_add_linear_velocity -> use_add_linear_velocity:   boolean  "Toggles between ADD and SET linV"
#Actuator|ObjectActuator.use_local_angular_velocity -> use_local_angular_velocity:   boolean  "Angular velocity is defined in local coordinates"
#Actuator|ObjectActuator.use_local_force -> use_local_force:   boolean  "Force is defined in local coordinates"
#Actuator|ObjectActuator.use_local_linear_velocity -> use_local_linear_velocity:   boolean  "Velocity is defined in local coordinates"
#Actuator|ObjectActuator.use_local_location -> use_local_location:   boolean  "Location is defined in local coordinates"
#Actuator|ObjectActuator.use_local_rotation -> use_local_rotation:   boolean  "Rotation is defined in local coordinates"
#Actuator|ObjectActuator.use_local_torque -> use_local_torque:   boolean  "Torque is defined in local coordinates"
#Actuator|ObjectActuator.use_servo_limit_x -> use_servo_limit_x:   boolean  "Set limit to force along the X axis"
#Actuator|ObjectActuator.use_servo_limit_y -> use_servo_limit_y:   boolean  "Set limit to force along the Y axis"
#Actuator|ObjectActuator.use_servo_limit_z -> use_servo_limit_z:   boolean  "Set limit to force along the Z axis"
#+ * Actuator|ParentActuator.mode -> mode:   enum  "NO DESCRIPTION"
#+ * Actuator|ParentActuator.object -> object:   pointer  "Set this object as parent"
#Actuator|ParentActuator.use_compound -> use_compound:   boolean  "Add this object shape to the parent shape (only if the parent shape is already compound)"
#Actuator|ParentActuator.use_ghost -> use_ghost:   boolean  "Make this object ghost while parented (only if not compound)"
#+ * Actuator|PropertyActuator.mode -> mode:   enum  "NO DESCRIPTION"
#+ * Actuator|PropertyActuator.object -> object:   pointer  "Copy from this Object"
#+ * Actuator|PropertyActuator.object_property -> object_property:   string  "Copy this property"
#+ * Actuator|PropertyActuator.property -> property:   string  "The name of the property"
#+ * Actuator|PropertyActuator.value -> value:   string  "The value to use, use  around strings"
#+ * Actuator|RandomActuator.chance -> chance:   float  "Pick a number between 0 and 1. Success if you stay below this value"
#+ * Actuator|RandomActuator.distribution -> distribution:   enum  "Choose the type of distribution"
#+ * Actuator|RandomActuator.float_max -> float_max:   float  "Choose a number from a range. Upper boundary of the range"
#+ * Actuator|RandomActuator.float_mean -> float_mean:   float  "A normal distribution. Mean of the distribution"
#+ * Actuator|RandomActuator.float_min -> float_min:   float  "Choose a number from a range. Lower boundary of the range"
#+ * Actuator|RandomActuator.float_value -> float_value:   float  "Always return this number"
#+ * Actuator|RandomActuator.half_life_time -> half_life_time:   float  "Negative exponential dropoff"
#+ * Actuator|RandomActuator.int_max -> int_max:   int  "Choose a number from a range. Upper boundary of the range"
#+ * Actuator|RandomActuator.int_mean -> int_mean:   float  "Expected mean value of the distribution"
#+ * Actuator|RandomActuator.int_min -> int_min:   int  "Choose a number from a range. Lower boundary of the range"
#+ * Actuator|RandomActuator.int_value -> int_value:   int  "Always return this number"
#+ * Actuator|RandomActuator.property -> property:   string  "Assign the random value to this property"
#+ * Actuator|RandomActuator.seed -> seed:   int  "Initial seed of the random generator. Use Python for more freedom (choose 0 for not random)"
#+ * Actuator|RandomActuator.standard_derivation -> standard_derivation:   float  "A normal distribution. Standard deviation of the distribution"
#Actuator|RandomActuator.use_always_true -> use_always_true:   boolean  "Always false or always true"
#+ * Actuator|SceneActuator.camera -> camera:   pointer  "Set this Camera. Leave empty to refer to self object"
#+ * Actuator|SceneActuator.mode -> mode:   enum  "NO DESCRIPTION"
#+ * Actuator|SceneActuator.scene -> scene:   pointer  "Set the Scene to be added/removed/paused/resumed"
#+ * Actuator|ShapeActionActuator.action -> action:   pointer  "NO DESCRIPTION"
#Actuator|ShapeActionActuator.frame_blend_in -> frame_blend_in:   int  "Number of frames of motion blending"
#+ * Actuator|ShapeActionActuator.frame_end -> frame_end:   int  "NO DESCRIPTION"
#+ * Actuator|ShapeActionActuator.frame_property -> frame_property:   string  "Assign the actions current frame number to this property"
#+ * Actuator|ShapeActionActuator.frame_start -> frame_start:   int  "NO DESCRIPTION"
#+ * Actuator|ShapeActionActuator.mode -> mode:   enum  "Action playback type"
#+ * Actuator|ShapeActionActuator.priority -> priority:   int  "Execution priority - lower numbers will override actions with higher numbers. With 2 or more actions at once, the overriding channels must be lower in the stack"
#+ * Actuator|ShapeActionActuator.property -> property:   string  "Use this property to define the Action position"
#Actuator|ShapeActionActuator.use_continue_last_frame -> use_continue_last_frame:   boolean  "Restore last frame when switching on/off, otherwise play from the start each time"
#+ * Actuator|SoundActuator.cone_inner_angle_3d -> cone_inner_angle_3d:   float  "The angle of the inner cone"
#+ * Actuator|SoundActuator.cone_outer_angle_3d -> cone_outer_angle_3d:   float  "The angle of the outer cone"
#+ * Actuator|SoundActuator.cone_outer_gain_3d -> cone_outer_gain_3d:   float  "The gain outside the outer cone. The gain in the outer cone will be interpolated between this value and the normal gain in the inner cone"
#Actuator|SoundActuator.distance_3d_max -> distance_3d_max:   float  "The maximum distance at which you can hear the sound"
#Actuator|SoundActuator.distance_3d_reference -> distance_3d_reference:   float  "The distance where the sound has a gain of 1.0"
#Actuator|SoundActuator.gain_3d_max -> gain_3d_max:   float  "The maximum gain of the sound, no matter how near it is"
#Actuator|SoundActuator.gain_3d_min -> gain_3d_min:   float  "The minimum gain of the sound, no matter how far it is away"
#+ * Actuator|SoundActuator.mode -> mode:   enum  "NO DESCRIPTION"
#+ * Actuator|SoundActuator.pitch -> pitch:   float  "Sets the pitch of the sound"
#+ * Actuator|SoundActuator.rolloff_factor_3d -> rolloff_factor_3d:   float  "The influence factor on volume depending on distance"
#+ * Actuator|SoundActuator.sound -> sound:   pointer  "NO DESCRIPTION"
#Actuator|SoundActuator.use_sound_3d -> use_sound_3d:   boolean  "Enable/Disable 3D Sound"
#+ * Actuator|SoundActuator.volume -> volume:   float  "Sets the initial volume of the sound"
#+ * Actuator|StateActuator.operation -> operation:   enum  "Select the bit operation on object state mask"
#Actuator|StateActuator.states -> states:   boolean[30]  "NO DESCRIPTION"
#Actuator|VisibilityActuator.apply_to_children -> apply_to_children:   boolean  "Set all the children of this object to the same visibility/occlusion recursively"
#Actuator|VisibilityActuator.use_occlusion -> use_occlusion:   boolean  "Set the object to occlude objects behind it. Initialized from the object type in physics button"
#Actuator|VisibilityActuator.use_visible -> use_visible:   boolean  "Set the objects visible. Initialized from the objects render restriction toggle (access in the outliner)"
#+ * Addon.module -> module:   string  "Module name"
#+ * AnimData.action -> action:   pointer  "Active Action for this datablock"
#AnimData.action_blend_type -> action_blend_type:   enum  "Method used for combining Active Actions result with result of NLA stack"
#+ * AnimData.action_extrapolation -> action_extrapolation:   enum  "Action to take for gaps past the Active Actions range (when evaluating with NLA)"
#+ * AnimData.action_influence -> action_influence:   float  "Amount the Active Action contributes to the result of the NLA stack"
#+ * AnimData.drivers -> drivers:   collection,  "(read-only)    The Drivers/Expressions for this datablock"
#+ * AnimData.nla_tracks -> nla_tracks:   collection,  "(read-only)    NLA Tracks (i.e. Animation Layers)"
#AnimData.use_nla -> use_nla:   boolean  "NLA stack is evaluated when evaluating this block"
#AnimViz.motion_path -> motion_path:   pointer,  "(read-only)    Motion Path settings for visualisation"
#AnimViz.onion_skin_frames -> onion_skin_frames:   pointer,  "(read-only)    Onion Skinning (ghosting) settings for visualisation"
#+ * AnimVizMotionPaths.bake_location -> bake_location:   enum  "When calculating Bone Paths, use Head or Tips"
#AnimVizMotionPaths.frame_after -> frame_after:   int  "Number of frames to show after the current frame (only for Around Current Frame Onion-skinning method)"
#AnimVizMotionPaths.frame_before -> frame_before:   int  "Number of frames to show before the current frame (only for Around Current Frame Onion-skinning method)"
#+ * AnimVizMotionPaths.frame_end -> frame_end:   int  "End frame of range of paths to display/calculate (not for Around Current Frame Onion-skinning method)"
#+ * AnimVizMotionPaths.frame_start -> frame_start:   int  "Starting frame of range of paths to display/calculate (not for Around Current Frame Onion-skinning method)"
#+ * AnimVizMotionPaths.frame_step -> frame_step:   int  "Number of frames between paths shown (not for On Keyframes Onion-skinning method)"
#+ * AnimVizMotionPaths.show_frame_numbers -> show_frame_numbers:   boolean  "Show frame numbers on Motion Paths"
#AnimVizMotionPaths.show_keyframe_action_all -> show_keyframe_action_all:   boolean  "For bone motion paths, search whole Action for keyframes instead of in group with matching name only (is slower)"
#AnimVizMotionPaths.show_keyframe_highlight -> show_keyframe_highlight:   boolean  "Emphasize position of keyframes on Motion Paths"
#+ * AnimVizMotionPaths.show_keyframe_numbers -> show_keyframe_numbers:   boolean  "Show frame numbers of Keyframes on Motion Paths"
#+ * AnimVizMotionPaths.type -> type:   enum  "Type of range to show for Motion Paths"
#AnimVizOnionSkinning.frame_after -> frame_after:   int  "Number of frames to show after the current frame (only for Around Current Frame Onion-skinning method)"
#AnimVizOnionSkinning.frame_before -> frame_before:   int  "Number of frames to show before the current frame (only for Around Current Frame Onion-skinning method)"
#+ * AnimVizOnionSkinning.frame_end -> frame_end:   int  "End frame of range of Ghosts to display (not for Around Current Frame Onion-skinning method)"
#+ * AnimVizOnionSkinning.frame_start -> frame_start:   int  "Starting frame of range of Ghosts to display (not for Around Current Frame Onion-skinning method)"
#+ * AnimVizOnionSkinning.frame_step -> frame_step:   int  "Number of frames between ghosts shown (not for On Keyframes Onion-skinning method)"
#AnimVizOnionSkinning.show_only_selected -> show_only_selected:   boolean  "For Pose-Mode drawing, only draw ghosts for selected bones"
#+ * AnimVizOnionSkinning.type -> type:   enum  "Method used for determining what ghosts get drawn"
#MAKE PROPERTY OF A COLLECTION * Area.active_space -> active_space:   pointer,  "(read-only)    Space currently being displayed in this area"
#+ * Area.regions -> regions:   collection,  "(read-only)    Regions this area is subdivided in"
#+ * Area.show_menus -> show_menus:   boolean  "Show menus in the header"
#+ * Area.spaces -> spaces:   collection,  "(read-only)    Spaces contained in this area, the first space is active"
#+ * Area.type -> type:   enum  "Space type"
#+ * ArmatureBones.active -> active:   pointer  "Armatures active bone"
#+ * ArmatureEditBones.active -> active:   pointer  "Armatures active edit bone"
#+ * BackgroundImage.image -> image:   pointer  "Image displayed and edited in this space"
#+ * BackgroundImage.image_user -> image_user:   pointer,  "(read-only)    Parameters defining which layer, pass and frame of the image is displayed"
#+ * BackgroundImage.offset_x -> offset_x:   float  "Offsets image horizontally from the world origin"
#+ * BackgroundImage.offset_y -> offset_y:   float  "Offsets image vertically from the world origin"
#+ * BackgroundImage.show_expanded -> show_expanded:   boolean  "Show the expanded in the user interface"
#+ * BackgroundImage.size -> size:   float  "Scaling factor for the background image"
#+ * BackgroundImage.transparency -> transparency:   float  "Amount to blend the image against the background color"
#+ * BackgroundImage.view_axis -> view_axis:   enum  "The axis to display the image on"
#+ * BezierSplinePoint.co -> co:   float[3]  "Coordinates of the control point"
#BezierSplinePoint.handle_left -> handle_left:   float[3]  "Coordinates of the first handle"
#BezierSplinePoint.handle_left_type -> handle_left_type:   enum  "Handle types"
#BezierSplinePoint.handle_right -> handle_right:   float[3]  "Coordinates of the second handle"
#BezierSplinePoint.handle_right_type -> handle_right_type:   enum  "Handle types"
#+ * BezierSplinePoint.hide -> hide:   boolean  "Visibility status"
#+ * BezierSplinePoint.radius -> radius:   float,  "(read-only)    Radius for bevelling"
#+ * BezierSplinePoint.select_control_point -> select_control_point:   boolean  "Control point selection status"
#+ * BezierSplinePoint.select_left_handle -> select_left_handle:   boolean  "Handle 1 selection status"
#+ * BezierSplinePoint.select_right_handle -> select_right_handle:   boolean  "Handle 2 selection status"
#+ * BezierSplinePoint.tilt -> tilt:   float  "Tilt in 3D View"
#+ * BezierSplinePoint.weight -> weight:   float  "Softbody goal weight"
#+ * BlenderRNA.structs -> structs:   collection,  "(read-only)"
#+ * BoidRule.name -> name:   string  "Boid rule name"
#+ * BoidRule.type -> type:   enum,  "(read-only)"
#BoidRule.use_in_air -> use_in_air:   boolean  "Use rule when boid is flying"
#BoidRule.use_on_land -> use_on_land:   boolean  "Use rule when boid is on land"
#+ * BoidRule|BoidRuleAverageSpeed.level -> level:   float  "How much velocitys z-component is kept constant"
#+ * BoidRule|BoidRuleAverageSpeed.speed -> speed:   float  "Percentage of maximum speed"
#+ * BoidRule|BoidRuleAverageSpeed.wander -> wander:   float  "How fast velocitys direction is randomized"
#+ * BoidRule|BoidRuleAvoid.fear_factor -> fear_factor:   float  "Avoid object if danger from it is above this threshold"
#+ * BoidRule|BoidRuleAvoid.object -> object:   pointer  "Object to avoid"
#BoidRule|BoidRuleAvoid.use_predict -> use_predict:   boolean  "Predict target movement"
#+ * BoidRule|BoidRuleAvoidCollision.look_ahead -> look_ahead:   float  "Time to look ahead in seconds"
#BoidRule|BoidRuleAvoidCollision.use_avoid -> use_avoid:   boolean  "Avoid collision with other boids"
#BoidRule|BoidRuleAvoidCollision.use_avoid_collision -> use_avoid_collision:   boolean  "Avoid collision with deflector objects"
#+ * BoidRule|BoidRuleFight.distance -> distance:   float  "Attack boids at max this distance"
#+ * BoidRule|BoidRuleFight.flee_distance -> flee_distance:   float  "Flee to this distance"
#+ * BoidRule|BoidRuleFollowLeader.distance -> distance:   float  "Distance behind leader to follow"
#+ * BoidRule|BoidRuleFollowLeader.object -> object:   pointer  "Follow this object instead of a boid"
#BoidRule|BoidRuleFollowLeader.queue_count -> queue_count:   int  "How many boids in a line"
#BoidRule|BoidRuleFollowLeader.use_line -> use_line:   boolean  "Follow leader in a line"
#+ * BoidRule|BoidRuleGoal.object -> object:   pointer  "Goal object"
#BoidRule|BoidRuleGoal.use_predict -> use_predict:   boolean  "Predict target movement"
#+ * BoidSettings.accuracy -> accuracy:   float  "Accuracy of attack"
#+ * BoidSettings.active_boid_state -> active_boid_state:   pointer,  "(read-only)"
#+ * BoidSettings.active_boid_state_index -> active_boid_state_index:   int  "NO DESCRIPTION"
#+ * BoidSettings.aggression -> aggression:   float  "Boid will fight this times stronger enemy"
#BoidSettings.air_acc_max -> air_acc_max:   float  "Maximum acceleration in air (relative to maximum speed)"
#BoidSettings.air_ave_max -> air_ave_max:   float  "Maximum angular velocity in air (relative to 180 degrees)"
#+ * BoidSettings.air_personal_space -> air_personal_space:   float  "Radius of boids personal space in air (% of particle size)"
#BoidSettings.air_speed_max -> air_speed_max:   float  "Maximum speed in air"
#BoidSettings.air_speed_min -> air_speed_min:   float  "Minimum speed in air (relative to maximum speed)"
#BoidSettings.bank -> bank:   float  "Amount of rotation around velocity vector on turns"
#+ * BoidSettings.health -> health:   float  "Initial boid health when born"
#+ * BoidSettings.height -> height:   float  "Boid height relative to particle size"
#BoidSettings.land_acc_max -> land_acc_max:   float  "Maximum acceleration on land (relative to maximum speed)"
#BoidSettings.land_ave_max -> land_ave_max:   float  "Maximum angular velocity on land (relative to 180 degrees)"
#+ * BoidSettings.land_jump_speed -> land_jump_speed:   float  "Maximum speed for jumping"
#+ * BoidSettings.land_personal_space -> land_personal_space:   float  "Radius of boids personal space on land (% of particle size)"
#BoidSettings.land_smooth -> land_smooth:   float  "How smoothly the boids land"
#BoidSettings.land_speed_max -> land_speed_max:   float  "Maximum speed on land"
#+ * BoidSettings.land_stick_force -> land_stick_force:   float  "How strong a force must be to start effecting a boid on land"
#+ * BoidSettings.range -> range:   float  "The maximum distance from which a boid can attack"
#+ * BoidSettings.states -> states:   collection,  "(read-only)"
#+ * BoidSettings.strength -> strength:   float  "Maximum caused damage on attack per second"
#BoidSettings.use_climb -> use_climb:   boolean  "Allow boids to climb goal objects"
#BoidSettings.use_flight -> use_flight:   boolean  "Allow boids to move in air"
#BoidSettings.use_land -> use_land:   boolean  "Allow boids to move on land"
#+ * BoidState.active_boid_rule -> active_boid_rule:   pointer,  "(read-only)"
#+ * BoidState.active_boid_rule_index -> active_boid_rule_index:   int  "NO DESCRIPTION"
#+ * BoidState.falloff -> falloff:   float  "NO DESCRIPTION"
#+ * BoidState.name -> name:   string  "Boid state name"
#BoidState.rule_fuzzy -> rule_fuzzy:   float  "NO DESCRIPTION"
#+ * BoidState.rules -> rules:   collection,  "(read-only)"
#+ * BoidState.ruleset_type -> ruleset_type:   enum  "How the rules in the list are evaluated"
#+ * BoidState.volume -> volume:   float  "NO DESCRIPTION"
#+ * Bone.bbone_in -> bbone_in:   float  "Length of first Bezier Handle (for B-Bones only)"
#+ * Bone.bbone_out -> bbone_out:   float  "Length of second Bezier Handle (for B-Bones only)"
#+ * Bone.bbone_segments -> bbone_segments:   int  "Number of subdivisions of bone (for B-Bones only)"
#+ * Bone.children -> children:   collection,  "(read-only)    Bones which are children of this bone"
#+ * Bone.envelope_distance -> envelope_distance:   float  "Bone deformation distance (for Envelope deform only)"
#+ * Bone.envelope_weight -> envelope_weight:   float  "Bone deformation weight (for Envelope deform only)"
#+ * Bone.head -> head:   float[3]  "Location of head end of the bone relative to its parent"
#+ * Bone.head_local -> head_local:   float[3]  "Location of head end of the bone relative to armature"
#+ * Bone.head_radius -> head_radius:   float  "Radius of head of bone (for Envelope deform only)"
#+ * Bone.hide -> hide:   boolean  "Bone is not visible when it is not in Edit Mode (i.e. in Object or Pose Modes)"
#+ * Bone.hide_select -> hide_select:   boolean  "Bone is able to be selected"
#Bone.layers -> layers:   boolean[32]  "Layers bone exists in"
#+ * Bone.matrix -> matrix:   float[9]  "3x3 bone matrix"
#+ * Bone.matrix_local -> matrix_local:   float[16]  "4x4 bone matrix relative to armature"
#+ * Bone.name -> name:   string  "NO DESCRIPTION"
#+ * Bone.parent -> parent:   pointer,  "(read-only)    Parent bone (in same Armature)"
#+ * Bone.select -> select:   boolean  "NO DESCRIPTION"
#Bone.show_wire -> show_wire:   boolean  "Bone is always drawn as Wireframe regardless of viewport draw mode. Useful for non-obstructive custom bone shapes"
#+ * Bone.tail -> tail:   float[3]  "Location of tail end of the bone"
#+ * Bone.tail_local -> tail_local:   float[3]  "Location of tail end of the bone relative to armature"
#+ * Bone.tail_radius -> tail_radius:   float  "Radius of tail of bone (for Envelope deform only)"
#Bone.use_connect -> use_connect:   boolean,  "(read-only)    When bone has a parent, bones head is struck to the parents tail"
#Bone.use_cyclic_offset -> use_cyclic_offset:   boolean  "When bone doesnt have a parent, it receives cyclic offset effects"
#Bone.use_deform -> use_deform:   boolean  "Bone does not deform any geometry"
#Bone.use_envelope_multiply -> use_envelope_multiply:   boolean  "When deforming bone, multiply effects of Vertex Group weights with Envelope influence"
#Bone.use_hinge -> use_hinge:   boolean  "Bone inherits rotation or scale from parent bone"
#Bone.use_inherit_scale -> use_inherit_scale:   boolean  "Bone inherits scaling from parent bone"
#Bone.use_local_location -> use_local_location:   boolean  "Bone location is set in local space"
#+ * BoneGroup.color_set -> color_set:   enum  "Custom color set to use"
#+ * BoneGroup.colors -> colors:   pointer,  "(read-only)    Copy of the colors associated with the groups color set"
#+ * BoneGroup.name -> name:   string  "NO DESCRIPTION"
#BoneGroups.active -> active:   pointer  "Active bone group for this pose"
#+ * ClothCollisionSettings.collision_quality -> collision_quality:   int  "How many collision iterations should be done. (higher is better quality but slower)"
#ClothCollisionSettings.distance_min -> distance_min:   float  "Minimum distance between collision objects before collision response takes in"
#+ * ClothCollisionSettings.friction -> friction:   float  "Friction force if a collision happened. (higher = less movement)"
#+ * ClothCollisionSettings.group -> group:   pointer  "Limit colliders to this Group"
#+ * ClothCollisionSettings.self_collision_quality -> self_collision_quality:   int  "How many self collision iterations should be done. (higher is better quality but slower)"
#ClothCollisionSettings.self_distance_min -> self_distance_min:   float  "0.5 means no distance at all, 1.0 is maximum distance"
#+ * ClothCollisionSettings.self_friction -> self_friction:   float  "Friction/damping with self contact"
#ClothCollisionSettings.use_collision -> use_collision:   boolean  "Enable collisions with other objects"
#ClothCollisionSettings.use_self_collision -> use_self_collision:   boolean  "Enable self collisions"
#+ * ClothSettings.air_damping -> air_damping:   float  "Air has normally some thickness which slows falling things down"
#+ * ClothSettings.bending_stiffness -> bending_stiffness:   float  "Wrinkle coefficient. (higher = less smaller but more big wrinkles)"
#+ * ClothSettings.bending_stiffness_max -> bending_stiffness_max:   float  "Maximum bending stiffness value"
#+ * ClothSettings.bending_vertex_group -> bending_vertex_group:   string  "Vertex group for fine control over bending stiffness"
#+ * ClothSettings.collider_friction -> collider_friction:   float  "NO DESCRIPTION"
#+ * ClothSettings.effector_weights -> effector_weights:   pointer,  "(read-only)"
#+ * ClothSettings.goal_default -> goal_default:   float  "Default Goal (vertex target position) value, when no Vertex Group used"
#+ * ClothSettings.goal_friction -> goal_friction:   float  "Goal (vertex target position) friction"
#+ * ClothSettings.goal_max -> goal_max:   float  "Goal maximum, vertex group weights are scaled to match this range"
#+ * ClothSettings.goal_min -> goal_min:   float  "Goal minimum, vertex group weights are scaled to match this range"
#+ * ClothSettings.goal_spring -> goal_spring:   float  "Goal (vertex target position) spring stiffness"
#+ * ClothSettings.gravity -> gravity:   float[3]  "Gravity or external force vector"
#+ * ClothSettings.internal_friction -> internal_friction:   float  "NO DESCRIPTION"
#+ * ClothSettings.mass -> mass:   float  "Mass of cloth material"
#+ * ClothSettings.mass_vertex_group -> mass_vertex_group:   string  "Vertex Group for pinning of vertices"
#+ * ClothSettings.pin_stiffness -> pin_stiffness:   float  "Pin (vertex target position) spring stiffness"
#+ * ClothSettings.pre_roll -> pre_roll:   int  "Simulation starts on this frame"
#+ * ClothSettings.quality -> quality:   int  "Quality of the simulation in steps per frame. (higher is better quality but slower)"
#+ * ClothSettings.rest_shape_key -> rest_shape_key:   pointer  "Shape key to use the rest spring lengths from"
#+ * ClothSettings.spring_damping -> spring_damping:   float  "Damping of cloth velocity. (higher = more smooth, less jiggling)"
#+ * ClothSettings.structural_stiffness -> structural_stiffness:   float  "Overall stiffness of structure"
#+ * ClothSettings.structural_stiffness_max -> structural_stiffness_max:   float  "Maximum structural stiffness value"
#+ * ClothSettings.structural_stiffness_vertex_group -> structural_stiffness_vertex_group:   string  "Vertex group for fine control over structural stiffness"
#ClothSettings.use_pin_cloth -> use_pin_cloth:   boolean  "Enable pinning of cloth vertices to other objects/positions"
#ClothSettings.use_stiffness_scale -> use_stiffness_scale:   boolean  "If enabled, stiffness can be scaled along a weight painted vertex group"
#+ * CollisionSettings.absorption -> absorption:   float  "How much of effector force gets lost during collision with this object (in percent)"
#+ * CollisionSettings.damping -> damping:   float  "Amount of damping during collision"
#+ * CollisionSettings.damping_factor -> damping_factor:   float  "Amount of damping during particle collision"
#CollisionSettings.damping_random -> damping_random:   float  "Random variation of damping"
#+ * CollisionSettings.friction_factor -> friction_factor:   float  "Amount of friction during particle collision"
#CollisionSettings.friction_random -> friction_random:   float  "Random variation of friction"
#+ * CollisionSettings.permeability -> permeability:   float  "Chance that the particle will pass through the mesh"
#+ * CollisionSettings.stickness -> stickness:   float  "Amount of stickness to surface collision"
#CollisionSettings.thickness_inner -> thickness_inner:   float  "Inner face thickness"
#CollisionSettings.thickness_outer -> thickness_outer:   float  "Outer face thickness"
#+ * CollisionSettings.use -> use:   boolean  "Enable this objects as a collider for physics systems"
#CollisionSettings.use_particle_kill -> use_particle_kill:   boolean  "Kill collided particles"
#+ * ColorRamp.elements -> elements:   collection,  "(read-only)"
#+ * ColorRamp.interpolation -> interpolation:   enum  "NO DESCRIPTION"
#+ * ColorRampElement.color -> color:   float[4]  "NO DESCRIPTION"
#+ * ColorRampElement.position -> position:   float  "NO DESCRIPTION"
#ConsoleLine.body -> body:   string  "Text in the line"
#+ * ConsoleLine.current_character -> current_character:   int  "NO DESCRIPTION"
#+ * Constraint.active -> active:   boolean  "Constraint is the one being edited"
#Constraint.error_location -> error_location:   float,  "(read-only)    Amount of residual error in Blender space unit for constraints that work on position"
#Constraint.error_rotation -> error_rotation:   float,  "(read-only)    Amount of residual error in radiant for constraints that work on orientation"
#+ * Constraint.influence -> influence:   float  "Amount of influence constraint will have on the final solution"
#Constraint.is_proxy_local -> is_proxy_local:   boolean  "Constraint was added in this proxy instance (i.e. did not belong to source Armature)"
#Constraint.is_valid -> is_valid:   boolean,  "(read-only)    Constraint has invalid settings and will not be evaluated"
#+ * Constraint.mute -> mute:   boolean  "Enable/Disable Constraint"
#+ * Constraint.name -> name:   string  "Constraint name"
#+ * Constraint.owner_space -> owner_space:   enum  "Space that owner is evaluated in"
#Constraint.show_expanded -> show_expanded:   boolean  "Constraints panel is expanded in UI"
#+ * Constraint.target_space -> target_space:   enum  "Space that target is evaluated in"
#+ * Constraint.type -> type:   enum,  "(read-only)"
#+ * ConstraintTarget.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * ConstraintTarget.target -> target:   pointer  "Target Object"
#+ * Constraint|ActionConstraint.action -> action:   pointer  "NO DESCRIPTION"
#+ * Constraint|ActionConstraint.frame_end -> frame_end:   int  "Last frame of the Action to use"
#+ * Constraint|ActionConstraint.frame_start -> frame_start:   int  "First frame of the Action to use"
#Constraint|ActionConstraint.max -> max:   float  "Maximum value for target channel range"
#Constraint|ActionConstraint.min -> min:   float  "Minimum value for target channel range"
#+ * Constraint|ActionConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|ActionConstraint.target -> target:   pointer  "Target Object"
#+ * Constraint|ActionConstraint.transform_channel -> transform_channel:   enum  "Transformation channel from the target that is used to key the Action"
#+ * Constraint|ChildOfConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|ChildOfConstraint.target -> target:   pointer  "Target Object"
#+ * Constraint|ChildOfConstraint.use_location_x -> use_location_x:   boolean  "Use X Location of Parent"
#+ * Constraint|ChildOfConstraint.use_location_y -> use_location_y:   boolean  "Use Y Location of Parent"
#+ * Constraint|ChildOfConstraint.use_location_z -> use_location_z:   boolean  "Use Z Location of Parent"
#+ * Constraint|ChildOfConstraint.use_rotation_x -> use_rotation_x:   boolean  "Use X Rotation of Parent"
#+ * Constraint|ChildOfConstraint.use_rotation_y -> use_rotation_y:   boolean  "Use Y Rotation of Parent"
#+ * Constraint|ChildOfConstraint.use_rotation_z -> use_rotation_z:   boolean  "Use Z Rotation of Parent"
#+ * Constraint|ChildOfConstraint.use_scale_x -> use_scale_x:   boolean  "Use X Scale of Parent"
#+ * Constraint|ChildOfConstraint.use_scale_y -> use_scale_y:   boolean  "Use Y Scale of Parent"
#+ * Constraint|ChildOfConstraint.use_scale_z -> use_scale_z:   boolean  "Use Z Scale of Parent"
#+ * Constraint|ClampToConstraint.main_axis -> main_axis:   enum  "Main axis of movement"
#+ * Constraint|ClampToConstraint.target -> target:   pointer  "Target Object"
#Constraint|ClampToConstraint.use_cyclic -> use_cyclic:   boolean  "Treat curve as cyclic curve (no clamping to curve bounding box"
#+ * Constraint|CopyLocationConstraint.head_tail -> head_tail:   float  "Target along length of bone: Head=0, Tail=1"
#+ * Constraint|CopyLocationConstraint.invert_x -> invert_x:   boolean  "Invert the X location"
#+ * Constraint|CopyLocationConstraint.invert_y -> invert_y:   boolean  "Invert the Y location"
#+ * Constraint|CopyLocationConstraint.invert_z -> invert_z:   boolean  "Invert the Z location"
#+ * Constraint|CopyLocationConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|CopyLocationConstraint.target -> target:   pointer  "Target Object"
#+ * Constraint|CopyLocationConstraint.use_offset -> use_offset:   boolean  "Add original location into copied location"
#+ * Constraint|CopyLocationConstraint.use_x -> use_x:   boolean  "Copy the targets X location"
#+ * Constraint|CopyLocationConstraint.use_y -> use_y:   boolean  "Copy the targets Y location"
#+ * Constraint|CopyLocationConstraint.use_z -> use_z:   boolean  "Copy the targets Z location"
#+ * Constraint|CopyRotationConstraint.invert_x -> invert_x:   boolean  "Invert the X rotation"
#+ * Constraint|CopyRotationConstraint.invert_y -> invert_y:   boolean  "Invert the Y rotation"
#+ * Constraint|CopyRotationConstraint.invert_z -> invert_z:   boolean  "Invert the Z rotation"
#+ * Constraint|CopyRotationConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|CopyRotationConstraint.target -> target:   pointer  "Target Object"
#+ * Constraint|CopyRotationConstraint.use_offset -> use_offset:   boolean  "Add original rotation into copied rotation"
#+ * Constraint|CopyRotationConstraint.use_x -> use_x:   boolean  "Copy the targets X rotation"
#+ * Constraint|CopyRotationConstraint.use_y -> use_y:   boolean  "Copy the targets Y rotation"
#+ * Constraint|CopyRotationConstraint.use_z -> use_z:   boolean  "Copy the targets Z rotation"
#+ * Constraint|CopyScaleConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|CopyScaleConstraint.target -> target:   pointer  "Target Object"
#+ * Constraint|CopyScaleConstraint.use_offset -> use_offset:   boolean  "Add original scale into copied scale"
#+ * Constraint|CopyScaleConstraint.use_x -> use_x:   boolean  "Copy the targets X scale"
#+ * Constraint|CopyScaleConstraint.use_y -> use_y:   boolean  "Copy the targets Y scale"
#+ * Constraint|CopyScaleConstraint.use_z -> use_z:   boolean  "Copy the targets Z scale"
#+ * Constraint|CopyTransformsConstraint.head_tail -> head_tail:   float  "Target along length of bone: Head=0, Tail=1"
#+ * Constraint|CopyTransformsConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|CopyTransformsConstraint.target -> target:   pointer  "Target Object"
#+ * Constraint|DampedTrackConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|DampedTrackConstraint.target -> target:   pointer  "Target Object"
#Constraint|DampedTrackConstraint.track_axis -> track_axis:   enum  "Axis that points to the target object"
#+ * Constraint|FloorConstraint.floor_location -> floor_location:   enum  "Location of target that object will not pass through"
#+ * Constraint|FloorConstraint.offset -> offset:   float  "Offset of floor from object origin"
#+ * Constraint|FloorConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|FloorConstraint.target -> target:   pointer  "Target Object"
#+ * Constraint|FloorConstraint.use_rotation -> use_rotation:   boolean  "Use the targets rotation to determine floor"
#Constraint|FloorConstraint.use_sticky -> use_sticky:   boolean  "Immobilize object while constrained"
#Constraint|FollowPathConstraint.forward_axis -> forward_axis:   enum  "Axis that points forward along the path"
#+ * Constraint|FollowPathConstraint.offset -> offset:   int  "Offset from the position corresponding to the time frame"
#+ * Constraint|FollowPathConstraint.offset_factor -> offset_factor:   float  "Percentage value defining target position along length of bone"
#+ * Constraint|FollowPathConstraint.target -> target:   pointer  "Target Object"
#Constraint|FollowPathConstraint.up_axis -> up_axis:   enum  "Axis that points upward"
#+ * Constraint|FollowPathConstraint.use_curve_follow -> use_curve_follow:   boolean  "Object will follow the heading and banking of the curve"
#+ * Constraint|FollowPathConstraint.use_curve_radius -> use_curve_radius:   boolean  "Objects scale by the curve radius"
#Constraint|FollowPathConstraint.use_fixed_location -> use_fixed_location:   boolean  "Object will stay locked to a single point somewhere along the length of the curve regardless of time"
#Constraint|KinematicConstraint.chain_count -> chain_count:   int  "How many bones are included in the IK effect - 0 uses all bones"
#+ * Constraint|KinematicConstraint.distance -> distance:   float  "Radius of limiting sphere"
#+ * Constraint|KinematicConstraint.ik_type -> ik_type:   enum  "NO DESCRIPTION"
#+ * Constraint|KinematicConstraint.iterations -> iterations:   int  "Maximum number of solving iterations"
#+ * Constraint|KinematicConstraint.limit_mode -> limit_mode:   enum  "Distances in relation to sphere of influence to allow"
#Constraint|KinematicConstraint.lock_location_x -> lock_location_x:   boolean  "Constraint position along X axis"
#Constraint|KinematicConstraint.lock_location_y -> lock_location_y:   boolean  "Constraint position along Y axis"
#Constraint|KinematicConstraint.lock_location_z -> lock_location_z:   boolean  "Constraint position along Z axis"
#Constraint|KinematicConstraint.lock_rotation_x -> lock_rotation_x:   boolean  "Constraint rotation along X axis"
#Constraint|KinematicConstraint.lock_rotation_y -> lock_rotation_y:   boolean  "Constraint rotation along Y axis"
#Constraint|KinematicConstraint.lock_rotation_z -> lock_rotation_z:   boolean  "Constraint rotation along Z axis"
#+ * Constraint|KinematicConstraint.orient_weight -> orient_weight:   float  "For Tree-IK: Weight of orientation control for this target"
#+ * Constraint|KinematicConstraint.pole_angle -> pole_angle:   float  "Pole rotation offset"
#+ * Constraint|KinematicConstraint.pole_subtarget -> pole_subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|KinematicConstraint.pole_target -> pole_target:   pointer  "Object for pole rotation"
#Constraint|KinematicConstraint.reference_axis -> reference_axis:   enum  "Constraint axis Lock options relative to Bone or Target reference"
#+ * Constraint|KinematicConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|KinematicConstraint.target -> target:   pointer  "Target Object"
#Constraint|KinematicConstraint.use_location -> use_location:   boolean  "Chain follows position of target"
#+ * Constraint|KinematicConstraint.use_rotation -> use_rotation:   boolean  "Chain follows rotation of target"
#+ * Constraint|KinematicConstraint.use_stretch -> use_stretch:   boolean  "Enable IK Stretching"
#+ * Constraint|KinematicConstraint.use_tail -> use_tail:   boolean  "Include bones tail as last element in chain"
#+ * Constraint|KinematicConstraint.use_target -> use_target:   boolean  "Disable for targetless IK"
#+ * Constraint|KinematicConstraint.weight -> weight:   float  "For Tree-IK: Weight of position control for this target"
#+ * Constraint|LimitDistanceConstraint.distance -> distance:   float  "Radius of limiting sphere"
#+ * Constraint|LimitDistanceConstraint.limit_mode -> limit_mode:   enum  "Distances in relation to sphere of influence to allow"
#+ * Constraint|LimitDistanceConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|LimitDistanceConstraint.target -> target:   pointer  "Target Object"
#Constraint|LimitLocationConstraint.max_x -> max_x:   float  "Highest X value to allow"
#Constraint|LimitLocationConstraint.max_y -> max_y:   float  "Highest Y value to allow"
#Constraint|LimitLocationConstraint.max_z -> max_z:   float  "Highest Z value to allow"
#Constraint|LimitLocationConstraint.min_x -> min_x:   float  "Lowest X value to allow"
#Constraint|LimitLocationConstraint.min_y -> min_y:   float  "Lowest Y value to allow"
#Constraint|LimitLocationConstraint.min_z -> min_z:   float  "Lowest Z value to allow"
#Constraint|LimitLocationConstraint.use_max_x -> use_max_x:   boolean  "Use the maximum X value"
#Constraint|LimitLocationConstraint.use_max_y -> use_max_y:   boolean  "Use the maximum Y value"
#Constraint|LimitLocationConstraint.use_max_z -> use_max_z:   boolean  "Use the maximum Z value"
#Constraint|LimitLocationConstraint.use_min_x -> use_min_x:   boolean  "Use the minimum X value"
#Constraint|LimitLocationConstraint.use_min_y -> use_min_y:   boolean  "Use the minimum Y value"
#Constraint|LimitLocationConstraint.use_min_z -> use_min_z:   boolean  "Use the minimum Z value"
#Constraint|LimitLocationConstraint.use_transform_limit -> use_transform_limit:   boolean  "Transforms are affected by this constraint as well"
#Constraint|LimitRotationConstraint.max_x -> max_x:   float  "Highest X value to allow"
#Constraint|LimitRotationConstraint.max_y -> max_y:   float  "Highest Y value to allow"
#Constraint|LimitRotationConstraint.max_z -> max_z:   float  "Highest Z value to allow"
#Constraint|LimitRotationConstraint.min_x -> min_x:   float  "Lowest X value to allow"
#Constraint|LimitRotationConstraint.min_y -> min_y:   float  "Lowest Y value to allow"
#Constraint|LimitRotationConstraint.min_z -> min_z:   float  "Lowest Z value to allow"
#+ * Constraint|LimitRotationConstraint.use_limit_x -> use_limit_x:   boolean  "Use the minimum X value"
#+ * Constraint|LimitRotationConstraint.use_limit_y -> use_limit_y:   boolean  "Use the minimum Y value"
#+ * Constraint|LimitRotationConstraint.use_limit_z -> use_limit_z:   boolean  "Use the minimum Z value"
#Constraint|LimitRotationConstraint.use_transform_limit -> use_transform_limit:   boolean  "Transforms are affected by this constraint as well"
#Constraint|LimitScaleConstraint.max_x -> max_x:   float  "Highest X value to allow"
#Constraint|LimitScaleConstraint.max_y -> max_y:   float  "Highest Y value to allow"
#Constraint|LimitScaleConstraint.max_z -> max_z:   float  "Highest Z value to allow"
#Constraint|LimitScaleConstraint.min_x -> min_x:   float  "Lowest X value to allow"
#Constraint|LimitScaleConstraint.min_y -> min_y:   float  "Lowest Y value to allow"
#Constraint|LimitScaleConstraint.min_z -> min_z:   float  "Lowest Z value to allow"
#Constraint|LimitScaleConstraint.use_max_x -> use_max_x:   boolean  "Use the maximum X value"
#Constraint|LimitScaleConstraint.use_max_y -> use_max_y:   boolean  "Use the maximum Y value"
#Constraint|LimitScaleConstraint.use_max_z -> use_max_z:   boolean  "Use the maximum Z value"
#Constraint|LimitScaleConstraint.use_min_x -> use_min_x:   boolean  "Use the minimum X value"
#Constraint|LimitScaleConstraint.use_min_y -> use_min_y:   boolean  "Use the minimum Y value"
#Constraint|LimitScaleConstraint.use_min_z -> use_min_z:   boolean  "Use the minimum Z value"
#Constraint|LimitScaleConstraint.use_transform_limit -> use_transform_limit:   boolean  "Transforms are affected by this constraint as well"
#Constraint|LockedTrackConstraint.lock_axis -> lock_axis:   enum  "Axis that points upward"
#+ * Constraint|LockedTrackConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|LockedTrackConstraint.target -> target:   pointer  "Target Object"
#Constraint|LockedTrackConstraint.track_axis -> track_axis:   enum  "Axis that points to the target object"
#Constraint|MaintainVolumeConstraint.free_axis -> free_axis:   enum  "The free scaling axis of the object"
#+ * Constraint|MaintainVolumeConstraint.volume -> volume:   float  "Volume of the bone at rest"
#+ * Constraint|PivotConstraint.head_tail -> head_tail:   float  "Target along length of bone: Head=0, Tail=1"
#+ * Constraint|PivotConstraint.offset -> offset:   float[3]  "Offset of pivot from target (when set), or from owners location (when Fixed Position is off), or the absolute pivot point"
#Constraint|PivotConstraint.rotation_range -> rotation_range:   enum  "Rotation range on which pivoting should occur"
#+ * Constraint|PivotConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|PivotConstraint.target -> target:   pointer  "Target Object, defining the position of the pivot when defined"
#Constraint|PivotConstraint.use_relative_location -> use_relative_location:   boolean  "Offset will be an absolute point in space instead of relative to the target"
#Constraint|PythonConstraint.has_script_error -> has_script_error:   boolean,  "(read-only)    The linked Python script has thrown an error"
#Constraint|PythonConstraint.target_count -> target_count:   int  "Usually only 1-3 are needed"
#+ * Constraint|PythonConstraint.targets -> targets:   collection,  "(read-only)    Target Objects"
#+ * Constraint|PythonConstraint.text -> text:   pointer  "The text object that contains the Python script"
#+ * Constraint|PythonConstraint.use_targets -> use_targets:   boolean  "Use the targets indicated in the constraint panel"
#+ * Constraint|RigidBodyJointConstraint.axis_x -> axis_x:   float  "Rotate pivot on X axis in degrees"
#+ * Constraint|RigidBodyJointConstraint.axis_y -> axis_y:   float  "Rotate pivot on Y axis in degrees"
#+ * Constraint|RigidBodyJointConstraint.axis_z -> axis_z:   float  "Rotate pivot on Z axis in degrees"
#+ * Constraint|RigidBodyJointConstraint.child -> child:   pointer  "Child object"
#+ * Constraint|RigidBodyJointConstraint.pivot_type -> pivot_type:   enum  "NO DESCRIPTION"
#+ * Constraint|RigidBodyJointConstraint.pivot_x -> pivot_x:   float  "Offset pivot on X"
#+ * Constraint|RigidBodyJointConstraint.pivot_y -> pivot_y:   float  "Offset pivot on Y"
#+ * Constraint|RigidBodyJointConstraint.pivot_z -> pivot_z:   float  "Offset pivot on Z"
#Constraint|RigidBodyJointConstraint.show_pivot -> show_pivot:   boolean  "Display the pivot point and rotation in 3D view"
#+ * Constraint|RigidBodyJointConstraint.target -> target:   pointer  "Target Object"
#Constraint|RigidBodyJointConstraint.use_linked_collision -> use_linked_collision:   boolean  "Disable collision between linked bodies"
#+ * Constraint|ShrinkwrapConstraint.distance -> distance:   float  "Distance to Target"
#+ * Constraint|ShrinkwrapConstraint.shrinkwrap_type -> shrinkwrap_type:   enum  "Selects type of shrinkwrap algorithm for target position"
#+ * Constraint|ShrinkwrapConstraint.target -> target:   pointer  "Target Object"
#+ * Constraint|ShrinkwrapConstraint.use_x -> use_x:   boolean  "Projection over X Axis"
#+ * Constraint|ShrinkwrapConstraint.use_y -> use_y:   boolean  "Projection over Y Axis"
#+ * Constraint|ShrinkwrapConstraint.use_z -> use_z:   boolean  "Projection over Z Axis"
#Constraint|SplineIKConstraint.chain_count -> chain_count:   int  "How many bones are included in the chain"
#+ * Constraint|SplineIKConstraint.joint_bindings -> joint_bindings:   float[32]  "(EXPERIENCED USERS ONLY) The relative positions of the joints along the chain as percentages"
#+ * Constraint|SplineIKConstraint.target -> target:   pointer  "Curve that controls this relationship"
#Constraint|SplineIKConstraint.use_chain_offset -> use_chain_offset:   boolean  "Offset the entire chain relative to the root joint"
#+ * Constraint|SplineIKConstraint.use_curve_radius -> use_curve_radius:   boolean  "Average radius of the endpoints is used to tweak the X and Z Scaling of the bones, on top of XZ Scale mode"
#Constraint|SplineIKConstraint.use_even_divisions -> use_even_divisions:   boolean  "Ignore the relative lengths of the bones when fitting to the curve"
#Constraint|SplineIKConstraint.use_y_stretch -> use_y_stretch:   boolean  "Stretch the Y axis of the bones to fit the curve"
#Constraint|SplineIKConstraint.xz_scale_mode -> xz_scale_mode:   enum  "Method used for determining the scaling of the X and Z axes of the bones"
#+ * Constraint|StretchToConstraint.bulge -> bulge:   float  "Factor between volume variation and stretching"
#+ * Constraint|StretchToConstraint.head_tail -> head_tail:   float  "Target along length of bone: Head=0, Tail=1"
#+ * Constraint|StretchToConstraint.keep_axis -> keep_axis:   enum  "Axis to maintain during stretch"
#Constraint|StretchToConstraint.rest_length -> rest_length:   float  "Length at rest position"
#+ * Constraint|StretchToConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|StretchToConstraint.target -> target:   pointer  "Target Object"
#+ * Constraint|StretchToConstraint.volume -> volume:   enum  "Maintain the objects volume as it stretches"
#+ * Constraint|TrackToConstraint.head_tail -> head_tail:   float  "Target along length of bone: Head=0, Tail=1"
#+ * Constraint|TrackToConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|TrackToConstraint.target -> target:   pointer  "Target Object"
#Constraint|TrackToConstraint.track_axis -> track_axis:   enum  "Axis that points to the target object"
#Constraint|TrackToConstraint.up_axis -> up_axis:   enum  "Axis that points upward"
#Constraint|TrackToConstraint.use_target_z -> use_target_z:   boolean  "Targets Z axis, not World Z axis, will constraint the Up direction"
#+ * Constraint|TransformConstraint.from_max_x -> from_max_x:   float  "Top range of X axis source motion"
#+ * Constraint|TransformConstraint.from_max_y -> from_max_y:   float  "Top range of Y axis source motion"
#+ * Constraint|TransformConstraint.from_max_z -> from_max_z:   float  "Top range of Z axis source motion"
#+ * Constraint|TransformConstraint.from_min_x -> from_min_x:   float  "Bottom range of X axis source motion"
#+ * Constraint|TransformConstraint.from_min_y -> from_min_y:   float  "Bottom range of Y axis source motion"
#+ * Constraint|TransformConstraint.from_min_z -> from_min_z:   float  "Bottom range of Z axis source motion"
#+ * Constraint|TransformConstraint.map_from -> map_from:   enum  "The transformation type to use from the target"
#+ * Constraint|TransformConstraint.map_to -> map_to:   enum  "The transformation type to affect of the constrained object"
#+ * Constraint|TransformConstraint.map_to_x_from -> map_to_x_from:   enum  "The source axis constrained objects X axis uses"
#+ * Constraint|TransformConstraint.map_to_y_from -> map_to_y_from:   enum  "The source axis constrained objects Y axis uses"
#+ * Constraint|TransformConstraint.map_to_z_from -> map_to_z_from:   enum  "The source axis constrained objects Z axis uses"
#+ * Constraint|TransformConstraint.subtarget -> subtarget:   string  "NO DESCRIPTION"
#+ * Constraint|TransformConstraint.target -> target:   pointer  "Target Object"
#+ * Constraint|TransformConstraint.to_max_x -> to_max_x:   float  "Top range of X axis destination motion"
#+ * Constraint|TransformConstraint.to_max_y -> to_max_y:   float  "Top range of Y axis destination motion"
#+ * Constraint|TransformConstraint.to_max_z -> to_max_z:   float  "Top range of Z axis destination motion"
#+ * Constraint|TransformConstraint.to_min_x -> to_min_x:   float  "Bottom range of X axis destination motion"
#+ * Constraint|TransformConstraint.to_min_y -> to_min_y:   float  "Bottom range of Y axis destination motion"
#+ * Constraint|TransformConstraint.to_min_z -> to_min_z:   float  "Bottom range of Z axis destination motion"
#Constraint|TransformConstraint.use_motion_extrapolate -> use_motion_extrapolate:   boolean  "Extrapolate ranges"
#+ * Context.area -> area:   pointer,  "(read-only)"
#+ * Context.main -> main:   pointer,  "(read-only)"
#+ * Context.mode -> mode:   enum,  "(read-only)"
#+ * Context.region -> region:   pointer,  "(read-only)"
#+ * Context.region_data -> region_data:   pointer,  "(read-only)"
#+ * Context.scene -> scene:   pointer,  "(read-only)"
#+ * Context.screen -> screen:   pointer,  "(read-only)"
#+ * Context.space_data -> space_data:   pointer,  "(read-only)"
#+ * Context.tool_settings -> tool_settings:   pointer,  "(read-only)"
#+ * Context.user_preferences -> user_preferences:   pointer,  "(read-only)"
#+ * Context.window -> window:   pointer,  "(read-only)"
 + * Context.manager -> wm:   pointer,  "(read-only)"
#+ * Controller.name -> name:   string  "NO DESCRIPTION"
#Controller.show_expanded -> show_expanded:   boolean  "Set controller expanded in the user interface"
#Controller.states -> states:   int  "Set Controller state index (1 to 30)"
#+ * Controller.type -> type:   enum  "NO DESCRIPTION"
#Controller.use_priority -> use_priority:   boolean  "Mark controller for execution before all non-marked controllers (good for startup scripts)"
#+ * Controller|ExpressionController.expression -> expression:   string  "NO DESCRIPTION"
#+ * Controller|PythonController.mode -> mode:   enum  "Python script type (textblock or module - faster)"
#+ * Controller|PythonController.module -> module:   string  "Module name and function to run e.g. someModule.main. Internal texts and external python files can be used"
#+ * Controller|PythonController.text -> text:   pointer  "Text datablock with the python script"
#Controller|PythonController.use_debug -> use_debug:   boolean  "Continuously reload the module from disk for editing external modules without restarting"
#+ * CurveMap.extend -> extend:   enum,  "(read-only)    Extrapolate the curve or extend it horizontally"
#+ * CurveMap.points -> points:   collection,  "(read-only)"
#+ * CurveMapPoint.handle_type -> handle_type:   enum,  "(read-only)    Curve interpolation at this point: bezier or vector"
#+ * CurveMapPoint.location -> location:   float[2],  "(read-only)    X/Y coordinates of the curve point"
#+ * CurveMapPoint.select -> select:   boolean  "Selection state of the curve point"
#+ * CurveMapping.black_level -> black_level:   float[3]  "For RGB curves, the color that black is mapped to"
#+ * CurveMapping.clip_max_x -> clip_max_x:   float  "NO DESCRIPTION"
#+ * CurveMapping.clip_max_y -> clip_max_y:   float  "NO DESCRIPTION"
#+ * CurveMapping.clip_min_x -> clip_min_x:   float  "NO DESCRIPTION"
#+ * CurveMapping.clip_min_y -> clip_min_y:   float  "NO DESCRIPTION"
#+ * CurveMapping.curves -> curves:   collection,  "(read-only)"
#CurveMapping.use_clip -> use_clip:   boolean  "Force the curve view to fit a defined boundary"
#+ * CurveMapping.white_level -> white_level:   float[3]  "For RGB curves, the color that white is mapped to"
#+ * CurveSplines.active -> active:   pointer  "Active curve spline"
#DopeSheet.filter_group -> filter_group:   pointer  "Group that included Object should be a member of"
#DopeSheet.show_armatures -> show_armatures:   boolean  "Include visualization of Armature related Animation data"
#DopeSheet.show_cameras -> show_cameras:   boolean  "Include visualization of Camera related Animation data"
#DopeSheet.show_curves -> show_curves:   boolean  "Include visualization of Curve related Animation data"
#DopeSheet.show_expanded_summary -> show_expanded_summary:   boolean  "Collapse summary when shown, so all other channels get hidden. (DopeSheet Editors Only)"
#DopeSheet.show_hidden -> show_hidden:   boolean  "Include channels from objects/bone that arent visible"
#DopeSheet.show_lamps -> show_lamps:   boolean  "Include visualization of Lamp related Animation data"
#DopeSheet.show_materials -> show_materials:   boolean  "Include visualization of Material related Animation data"
#DopeSheet.show_meshes -> show_meshes:   boolean  "Include visualization of Mesh related Animation data"
#DopeSheet.show_metaballs -> show_metaballs:   boolean  "Include visualization of Metaball related Animation data"
#DopeSheet.show_missing_nla -> show_missing_nla:   boolean  "Include Animation Data blocks with no NLA data. (NLA Editor only)"
#DopeSheet.show_nodes -> show_nodes:   boolean  "Include visualization of Node related Animation data"
#DopeSheet.show_only_group_objects -> show_only_group_objects:   boolean  "Only include channels from Objects in the specified Group"
#DopeSheet.show_only_selected -> show_only_selected:   boolean  "Only include channels relating to selected objects and data"
#DopeSheet.show_particles -> show_particles:   boolean  "Include visualization of Particle related Animation data"
#DopeSheet.show_scenes -> show_scenes:   boolean  "Include visualization of Scene related Animation data"
#DopeSheet.show_shapekeys -> show_shapekeys:   boolean  "Include visualization of ShapeKey related Animation data"
#DopeSheet.show_summary -> show_summary:   boolean  "Display an additional summary line. (DopeSheet Editors only)"
#DopeSheet.show_textures -> show_textures:   boolean  "Include visualization of Texture related Animation data"
#DopeSheet.show_transforms -> show_transforms:   boolean  "Include visualization of Object-level Animation data (mostly Transforms)"
#DopeSheet.show_worlds -> show_worlds:   boolean  "Include visualization of World related Animation data"
#+ * DopeSheet.source -> source:   pointer,  "(read-only)    ID-Block representing source data, currently ID_SCE (for Dopesheet), and ID_SC (for Grease Pencil)"
#+ * Driver.expression -> expression:   string  "Expression to use for Scripted Expression"
#Driver.is_valid -> is_valid:   boolean  "Driver could not be evaluated in past, so should be skipped"
#+ * Driver.show_debug_info -> show_debug_info:   boolean  "Show intermediate values for the driver calculations to allow debugging of drivers"
#+ * Driver.type -> type:   enum  "Driver type"
#+ * Driver.variables -> variables:   collection,  "(read-only)    Properties acting as inputs for this driver"
#+ * DriverTarget.bone_target -> bone_target:   string  "Name of PoseBone to use as target"
#+ * DriverTarget.data_path -> data_path:   string  "RNA Path (from ID-block) to property used"
#+ * DriverTarget.id -> id:   pointer  "ID-block that the specific property used can be found from (id_type property must be set first)"
#+ * DriverTarget.id_type -> id_type:   enum  "Type of ID-block that can be used"
#+ * DriverTarget.transform_type -> transform_type:   enum  "Driver variable type"
#DriverTarget.use_local_space_transform -> use_local_space_transform:   boolean  "Use transforms in Local Space (as opposed to the worldspace default)"
#+ * DriverVariable.name -> name:   string  "Name to use in scripted expressions/functions. (No spaces or dots are allowed. Also, must not start with a symbol or digit)"
#+ * DriverVariable.targets -> targets:   collection,  "(read-only)    Sources of input data for evaluating this variable"
#+ * DriverVariable.type -> type:   enum  "Driver variable type"
#+ * DupliObject.matrix -> matrix:   float[16]  "Object duplicate transformation matrix"
#+ * DupliObject.matrix_original -> matrix_original:   float[16]  "The original matrix of this object before it was duplicated"
#+ * DupliObject.object -> object:   pointer,  "(read-only)    Object being duplicated"
#+ * EditBone.bbone_in -> bbone_in:   float  "Length of first Bezier Handle (for B-Bones only)"
#+ * EditBone.bbone_out -> bbone_out:   float  "Length of second Bezier Handle (for B-Bones only)"
#+ * EditBone.bbone_segments -> bbone_segments:   int  "Number of subdivisions of bone (for B-Bones only)"
#+ * EditBone.envelope_distance -> envelope_distance:   float  "Bone deformation distance (for Envelope deform only)"
#+ * EditBone.envelope_weight -> envelope_weight:   float  "Bone deformation weight (for Envelope deform only)"
#+ * EditBone.head -> head:   float[3]  "Location of head end of the bone"
#+ * EditBone.head_radius -> head_radius:   float  "Radius of head of bone (for Envelope deform only)"
#+ * EditBone.hide -> hide:   boolean  "Bone is not visible when in Edit Mode"
#+ * EditBone.hide_select -> hide_select:   boolean  "Bone is able to be selected"
#EditBone.layers -> layers:   boolean[32]  "Layers bone exists in"
#+ * EditBone.lock -> lock:   boolean  "Bone is not able to be transformed when in Edit Mode"
#+ * EditBone.matrix -> matrix:   float[16],  "(read-only)    Read-only matrix calculated from the roll (armature space)"
#+ * EditBone.name -> name:   string  "NO DESCRIPTION"
#+ * EditBone.parent -> parent:   pointer  "Parent edit bone (in same Armature)"
#+ * EditBone.roll -> roll:   float  "Bone rotation around head-tail axis"
#+ * EditBone.select -> select:   boolean  "NO DESCRIPTION"
#+ * EditBone.select_head -> select_head:   boolean  "NO DESCRIPTION"
#+ * EditBone.select_tail -> select_tail:   boolean  "NO DESCRIPTION"
#EditBone.show_wire -> show_wire:   boolean  "Bone is always drawn as Wireframe regardless of viewport draw mode. Useful for non-obstructive custom bone shapes"
#+ * EditBone.tail -> tail:   float[3]  "Location of tail end of the bone"
#+ * EditBone.tail_radius -> tail_radius:   float  "Radius of tail of bone (for Envelope deform only)"
#EditBone.use_connect -> use_connect:   boolean  "When bone has a parent, bones head is struck to the parents tail"
#EditBone.use_cyclic_offset -> use_cyclic_offset:   boolean  "When bone doesnt have a parent, it receives cyclic offset effects"
#EditBone.use_deform -> use_deform:   boolean  "Bone does not deform any geometry"
#EditBone.use_envelope_multiply -> use_envelope_multiply:   boolean  "When deforming bone, multiply effects of Vertex Group weights with Envelope influence"
#EditBone.use_hinge -> use_hinge:   boolean  "Bone inherits rotation or scale from parent bone"
#EditBone.use_inherit_scale -> use_inherit_scale:   boolean  "Bone inherits scaling from parent bone"
#EditBone.use_local_location -> use_local_location:   boolean  "Bone location is set in local space"
#+ * EffectorWeights.all -> all:   float  "All effectors weight"
#EffectorWeights.apply_to_hair_growing -> apply_to_hair_growing:   boolean  "Use force fields when growing hair"
#+ * EffectorWeights.boid -> boid:   float  "Boid effector weight"
#+ * EffectorWeights.charge -> charge:   float  "Charge effector weight"
#EffectorWeights.curve_guide -> curve_guide:   float  "Curve guide effector weight"
#+ * EffectorWeights.drag -> drag:   float  "Drag effector weight"
#+ * EffectorWeights.force -> force:   float  "Force effector weight"
#+ * EffectorWeights.gravity -> gravity:   float  "Global gravity weight"
#+ * EffectorWeights.group -> group:   pointer  "Limit effectors to this Group"
#+ * EffectorWeights.harmonic -> harmonic:   float  "Harmonic effector weight"
#+ * EffectorWeights.lennardjones -> lennardjones:   float  "Lennard-Jones effector weight"
#+ * EffectorWeights.magnetic -> magnetic:   float  "Magnetic effector weight"
#+ * EffectorWeights.texture -> texture:   float  "Texture effector weight"
#+ * EffectorWeights.turbulence -> turbulence:   float  "Turbulence effector weight"
#+ * EffectorWeights.vortex -> vortex:   float  "Vortex effector weight"
#+ * EffectorWeights.wind -> wind:   float  "Wind effector weight"
#+ * EnumPropertyItem.description -> description:   string,  "(read-only)    Description of the items purpose"
#+ * EnumPropertyItem.identifier -> identifier:   string,  "(read-only)    Unique name used in the code and scripting"
#+ * EnumPropertyItem.name -> name:   string,  "(read-only)    Human readable name"
#+ * EnumPropertyItem.value -> value:   int,  "(read-only)    Value of the item"
#+ * EnvironmentMap.clip_end -> clip_end:   float  "Objects further than this are not visible to map"
#+ * EnvironmentMap.clip_start -> clip_start:   float  "Objects nearer than this are not visible to map"
#+ * EnvironmentMap.depth -> depth:   int  "Number of times a map will be rendered recursively (mirror effects.)"
#EnvironmentMap.layers_ignore -> layers_ignore:   boolean[20]  "Hide objects on these layers when generating the Environment Map"
#+ * EnvironmentMap.mapping -> mapping:   enum  "NO DESCRIPTION"
#+ * EnvironmentMap.resolution -> resolution:   int  "Pixel resolution of the rendered environment map"
#+ * EnvironmentMap.source -> source:   enum  "NO DESCRIPTION"
#+ * EnvironmentMap.viewpoint_object -> viewpoint_object:   pointer  "Object to use as the environment maps viewpoint location"
#+ * EnvironmentMap.zoom -> zoom:   float  "NO DESCRIPTION"
#+ * Event.ascii -> ascii:   string,  "(read-only)    Single ASCII character for this event"
 + * Event.alt -> is_pressed_alt:   boolean,  "(read-only)    True when the Alt/Option key is held"
 + * Event.oskey -> is_pressed_cmd:   boolean,  "(read-only)    True when the Cmd key is held"
 + * Event.ctrl -> is_pressed_ctrl:   boolean,  "(read-only)    True when the Ctrl key is held"
 + * Event.shift -> is_pressed_shift:   boolean,  "(read-only)    True when the Shift key is held"
#+ * Event.mouse_prev_x -> mouse_prev_x:   int,  "(read-only)    The window relative vertical location of the mouse"
#+ * Event.mouse_prev_y -> mouse_prev_y:   int,  "(read-only)    The window relative horizontal location of the mouse"
#+ * Event.mouse_region_x -> mouse_region_x:   int,  "(read-only)    The region relative vertical location of the mouse"
#+ * Event.mouse_region_y -> mouse_region_y:   int,  "(read-only)    The region relative horizontal location of the mouse"
#+ * Event.mouse_x -> mouse_x:   int,  "(read-only)    The window relative vertical location of the mouse"
#+ * Event.mouse_y -> mouse_y:   int,  "(read-only)    The window relative horizontal location of the mouse"
#+ * Event.type -> type:   enum,  "(read-only)"
#+ * Event.value -> value:   enum,  "(read-only)    The type of event, only applies to some"
#+ * FCurve.array_index -> array_index:   int  "Index to the specific property affected by F-Curve if applicable"
#+ * FCurve.color -> color:   float[3]  "Color of the F-Curve in the Graph Editor"
#+ * FCurve.color_mode -> color_mode:   enum  "Method used to determine color of F-Curve in Graph Editor"
#+ * FCurve.data_path -> data_path:   string  "RNA Path to property affected by F-Curve"
#+ * FCurve.driver -> driver:   pointer,  "(read-only)    Channel Driver (only set for Driver F-Curves)"
#+ * FCurve.extrapolation -> extrapolation:   enum  "NO DESCRIPTION"
#+ * FCurve.group -> group:   pointer  "Action Group that this F-Curve belongs to"
#+ * FCurve.hide -> hide:   boolean  "F-Curve and its keyframes are hidden in the Graph Editor graphs"
#+ * FCurve.is_valid -> is_valid:   boolean  "False when F-Curve could not be evaluated in past, so should be skipped when evaluating"
#+ * FCurve.keyframe_points -> keyframe_points:   collection,  "(read-only)    User-editable keyframes"
#+ * FCurve.lock -> lock:   boolean  "F-Curves settings cannot be edited"
#+ * FCurve.modifiers -> modifiers:   collection,  "(read-only)    Modifiers affecting the shape of the F-Curve"
#+ * FCurve.mute -> mute:   boolean  "F-Curve is not evaluated"
#+ * FCurve.sampled_points -> sampled_points:   collection,  "(read-only)    Sampled animation data"
#+ * FCurve.select -> select:   boolean  "F-Curve is selected for editing"
#+ * FCurve.use_auto_handle_clamp -> use_auto_handle_clamp:   boolean  "All auto-handles for F-Curve are clamped"
#+ * FCurveModifiers.active -> active:   pointer  "Active F-Curve Modifier"
#+ * FCurveSample.co -> co:   float[2]  "Point coordinates"
#+ * FCurveSample.select -> select:   boolean  "Selection status"
#REMOVE * FModifier.active -> active:   boolean  "F-Curve Modifier is the one being edited"
#FModifier.is_valid -> is_valid:   boolean,  "(read-only)    F-Curve Modifier has invalid settings and will not be evaluated"
#+ * FModifier.mute -> mute:   boolean  "F-Curve Modifier will not be evaluated"
#FModifier.show_expanded -> show_expanded:   boolean  "F-Curve Modifiers panel is expanded in UI"
#+ * FModifier.type -> type:   enum,  "(read-only)    F-Curve Modifier Type"
#+ * FModifierEnvelopeControlPoint.frame -> frame:   float  "Frame this control-point occurs on"
#FModifierEnvelopeControlPoint.max -> max:   float  "Upper bound of envelope at this control-point"
#FModifierEnvelopeControlPoint.min -> min:   float  "Lower bound of envelope at this control-point"
#FModifier|FModifierCycles.cycles_after -> cycles_after:   float  "Maximum number of cycles to allow after last keyframe. (0 = infinite)"
#FModifier|FModifierCycles.cycles_before -> cycles_before:   float  "Maximum number of cycles to allow before first keyframe. (0 = infinite)"
#FModifier|FModifierCycles.mode_after -> mode_after:   enum  "Cycling mode to use after last keyframe"
#FModifier|FModifierCycles.mode_before -> mode_before:   enum  "Cycling mode to use before first keyframe"
#+ * FModifier|FModifierEnvelope.control_points -> control_points:   collection,  "(read-only)    Control points defining the shape of the envelope"
#FModifier|FModifierEnvelope.default_max -> default_max:   float  "Upper distance from Reference Value for 1:1 default influence"
#FModifier|FModifierEnvelope.default_min -> default_min:   float  "Lower distance from Reference Value for 1:1 default influence"
#+ * FModifier|FModifierEnvelope.reference_value -> reference_value:   float  "Value that envelopes influence is centered around / based on"
#+ * FModifier|FModifierFunctionGenerator.amplitude -> amplitude:   float  "Scale factor determining the maximum/minimum values"
#+ * FModifier|FModifierFunctionGenerator.function_type -> function_type:   enum  "Type of built-in function to use"
#+ * FModifier|FModifierFunctionGenerator.phase_multiplier -> phase_multiplier:   float  "Scale factor determining the speed of the function"
#+ * FModifier|FModifierFunctionGenerator.phase_offset -> phase_offset:   float  "Constant factor to offset time by for function"
#FModifier|FModifierFunctionGenerator.use_additive -> use_additive:   boolean  "Values generated by this modifier are applied on top of the existing values instead of overwriting them"
#+ * FModifier|FModifierFunctionGenerator.value_offset -> value_offset:   float  "Constant factor to offset values by"
#+ * FModifier|FModifierGenerator.coefficients -> coefficients:   float[32]  "Coefficients for x (starting from lowest power of x^0)"
#+ * FModifier|FModifierGenerator.mode -> mode:   enum  "Type of generator to use"
#+ * FModifier|FModifierGenerator.poly_order -> poly_order:   int  "The highest power of x for this polynomial. (number of coefficients - 1)"
#FModifier|FModifierGenerator.use_additive -> use_additive:   boolean  "Values generated by this modifier are applied on top of the existing values instead of overwriting them"
#FModifier|FModifierLimits.max_x -> max_x:   float  "Highest X value to allow"
#FModifier|FModifierLimits.max_y -> max_y:   float  "Highest Y value to allow"
#FModifier|FModifierLimits.min_x -> min_x:   float  "Lowest X value to allow"
#FModifier|FModifierLimits.min_y -> min_y:   float  "Lowest Y value to allow"
#FModifier|FModifierLimits.use_max_x -> use_max_x:   boolean  "Use the maximum X value"
#FModifier|FModifierLimits.use_max_y -> use_max_y:   boolean  "Use the maximum Y value"
#FModifier|FModifierLimits.use_min_x -> use_min_x:   boolean  "Use the minimum X value"
#FModifier|FModifierLimits.use_min_y -> use_min_y:   boolean  "Use the minimum Y value"
#FModifier|FModifierNoise.blend_type -> blend_type:   enum  "Method of modifying the existing F-Curve"
#+ * FModifier|FModifierNoise.depth -> depth:   int  "Amount of fine level detail present in the noise"
#+ * FModifier|FModifierNoise.phase -> phase:   float  "A random seed for the noise effect"
#FModifier|FModifierNoise.scale -> scale:   float  "Scaling (in time) of the noise"
#+ * FModifier|FModifierNoise.strength -> strength:   float  "Amplitude of the noise - the amount that it modifies the underlying curve"
#+ * FModifier|FModifierStepped.frame_end -> frame_end:   float  "Frame that modifiers influence ends (if applicable)"
#FModifier|FModifierStepped.frame_offset -> frame_offset:   float  "Reference number of frames before frames get held. Use to get hold for 1-3 vs 5-7 holding patterns"
#+ * FModifier|FModifierStepped.frame_start -> frame_start:   float  "Frame that modifiers influence starts (if applicable)"
#FModifier|FModifierStepped.frame_step -> frame_step:   float  "Number of frames to hold each value"
#+ * FModifier|FModifierStepped.use_frame_end -> use_frame_end:   boolean  "Restrict modifier to only act before its end frame"
#+ * FModifier|FModifierStepped.use_frame_start -> use_frame_start:   boolean  "Restrict modifier to only act after its start frame"
#FieldSettings.apply_to_location -> apply_to_location:   boolean  "Effect particles location"
#FieldSettings.apply_to_rotation -> apply_to_rotation:   boolean  "Effect particles dynamic rotation"
#FieldSettings.distance_max -> distance_max:   float  "Maximum distance for the field to work"
#FieldSettings.distance_min -> distance_min:   float  "Minimum distance for the fields fall-off"
#+ * FieldSettings.falloff_power -> falloff_power:   float  "Falloff power (real gravitational falloff = 2)"
#+ * FieldSettings.falloff_type -> falloff_type:   enum  "Fall-off shape"
#+ * FieldSettings.flow -> flow:   float  "Convert effector force into air flow velocity"
#+ * FieldSettings.guide_clump_amount -> guide_clump_amount:   float  "Amount of clumping"
#+ * FieldSettings.guide_clump_shape -> guide_clump_shape:   float  "Shape of clumping"
#+ * FieldSettings.guide_free -> guide_free:   float  "Guide-free time from particle lifes end"
#+ * FieldSettings.guide_kink_amplitude -> guide_kink_amplitude:   float  "The amplitude of the offset"
#+ * FieldSettings.guide_kink_axis -> guide_kink_axis:   enum  "Which axis to use for offset"
#+ * FieldSettings.guide_kink_frequency -> guide_kink_frequency:   float  "The frequency of the offset (1/total length)"
#+ * FieldSettings.guide_kink_shape -> guide_kink_shape:   float  "Adjust the offset to the beginning/end"
#+ * FieldSettings.guide_kink_type -> guide_kink_type:   enum  "Type of periodic offset on the curve"
#+ * FieldSettings.guide_minimum -> guide_minimum:   float  "The distance from which particles are affected fully"
#+ * FieldSettings.harmonic_damping -> harmonic_damping:   float  "Damping of the harmonic force"
#+ * FieldSettings.inflow -> inflow:   float  "Inwards component of the vortex force"
#+ * FieldSettings.linear_drag -> linear_drag:   float  "Drag component proportional to velocity"
#+ * FieldSettings.noise -> noise:   float  "Noise of the force"
#+ * FieldSettings.quadratic_drag -> quadratic_drag:   float  "Drag component proportional to the square of velocity"
#+ * FieldSettings.radial_falloff -> radial_falloff:   float  "Radial falloff power (real gravitational falloff = 2)"
#FieldSettings.radial_max -> radial_max:   float  "Maximum radial distance for the field to work"
#FieldSettings.radial_min -> radial_min:   float  "Minimum radial distance for the fields fall-off"
#+ * FieldSettings.rest_length -> rest_length:   float  "Rest length of the harmonic force"
#+ * FieldSettings.seed -> seed:   int  "Seed of the noise"
#+ * FieldSettings.shape -> shape:   enum  "Which direction is used to calculate the effector force"
#+ * FieldSettings.size -> size:   float  "Size of the noise"
#+ * FieldSettings.strength -> strength:   float  "Strength of force field"
#+ * FieldSettings.texture -> texture:   pointer  "Texture to use as force"
#+ * FieldSettings.texture_mode -> texture_mode:   enum  "How the texture effect is calculated (RGB & Curl need a RGB texture else Gradient will be used instead)"
#+ * FieldSettings.texture_nabla -> texture_nabla:   float  "Defines size of derivative offset used for calculating gradient and curl"
#+ * FieldSettings.type -> type:   enum  "Type of field"
#FieldSettings.use_2d_force -> use_2d_force:   boolean  "Apply force only in 2d"
#FieldSettings.use_absorption -> use_absorption:   boolean  "Force gets absorbed by collision objects"
#FieldSettings.use_global_coords -> use_global_coords:   boolean  "Use effector/global coordinates for turbulence"
#FieldSettings.use_guide_path_add -> use_guide_path_add:   boolean  "Based on distance/falloff it adds a portion of the entire path"
#+ * FieldSettings.use_guide_path_weight -> use_guide_path_weight:   boolean  "Use curve weights to influence the particle influence along the curve"
#+ * FieldSettings.use_max_distance -> use_max_distance:   boolean  "Use a maximum distance for the field to work"
#+ * FieldSettings.use_min_distance -> use_min_distance:   boolean  "Use a minimum distance for the fields fall-off"
#FieldSettings.use_multiple_springs -> use_multiple_springs:   boolean  "Every point is effected by multiple springs"
#FieldSettings.use_object_coords -> use_object_coords:   boolean  "Use object/global coordinates for texture"
#+ * FieldSettings.use_radial_max -> use_radial_max:   boolean  "Use a maximum radial distance for the field to work"
#+ * FieldSettings.use_radial_min -> use_radial_min:   boolean  "Use a minimum radial distance for the fields fall-off"
#FieldSettings.use_root_coords -> use_root_coords:   boolean  "Texture coordinates from root particle locations"
#+ * FieldSettings.z_direction -> z_direction:   enum  "Effect in full or only positive/negative Z direction"
#+ * FileSelectParams.directory -> directory:   string  "Directory displayed in the file browser"
#FileSelectParams.display_type -> display_type:   enum  "Display mode for the file list"
#FileSelectParams.filename -> filename:   string  "Active file in the file browser"
#FileSelectParams.show_hidden -> show_hidden:   boolean  "Hide hidden dot files"
#FileSelectParams.sort_method -> sort_method:   enum  "NO DESCRIPTION"
#+ * FileSelectParams.title -> title:   string,  "(read-only)    Title for the file browser"
#FileSelectParams.use_filter -> use_filter:   boolean  "Enable filtering of files"
#FileSelectParams.use_filter_blender -> use_filter_blender:   boolean  "Show .blend files"
#FileSelectParams.use_filter_folder -> use_filter_folder:   boolean  "Show folders"
#FileSelectParams.use_filter_font -> use_filter_font:   boolean  "Show font files"
#FileSelectParams.use_filter_image -> use_filter_image:   boolean  "Show image files"
#FileSelectParams.use_filter_movie -> use_filter_movie:   boolean  "Show movie files"
#FileSelectParams.use_filter_script -> use_filter_script:   boolean  "Show script files"
#FileSelectParams.use_filter_sound -> use_filter_sound:   boolean  "Show sound files"
#FileSelectParams.use_filter_text -> use_filter_text:   boolean  "Show text files"
#+ * FluidSettings.type -> type:   enum  "Type of participation in the fluid simulation"
#+ * FluidSettings|ControlFluidSettings.attraction_radius -> attraction_radius:   float  "Specifies the force field radius around the control object"
#+ * FluidSettings|ControlFluidSettings.attraction_strength -> attraction_strength:   float  "Force strength for directional attraction towards the control object"
#+ * FluidSettings|ControlFluidSettings.end_time -> end_time:   float  "Specifies time when the control particles are deactivated"
#+ * FluidSettings|ControlFluidSettings.quality -> quality:   float  "Specifies the quality which is used for object sampling. (higher = better but slower)"
#+ * FluidSettings|ControlFluidSettings.start_time -> start_time:   float  "Specifies time when the control particles are activated"
#FluidSettings|ControlFluidSettings.use -> use:   boolean  "Object contributes to the fluid simulation"
#FluidSettings|ControlFluidSettings.use_reverse_frames -> use_reverse_frames:   boolean  "Reverse control object movement"
#+ * FluidSettings|ControlFluidSettings.velocity_radius -> velocity_radius:   float  "Specifies the force field radius around the control object"
#+ * FluidSettings|ControlFluidSettings.velocity_strength -> velocity_strength:   float  "Force strength of how much of the control objects velocity is influencing the fluid velocity"
#+ * FluidSettings|DomainFluidSettings.compressibility -> compressibility:   float  "Allowed compressibility due to gravitational force for standing fluid. (directly affects simulation step size)"
#+ * FluidSettings|DomainFluidSettings.end_time -> end_time:   float  "Simulation time of the last blender frame (in seconds)"
#FluidSettings|DomainFluidSettings.filepath -> filepath:   string  "Directory (and/or filename prefix) to store baked fluid simulation files in"
#+ * FluidSettings|DomainFluidSettings.generate_particles -> generate_particles:   float  "Amount of particles to generate (0=off, 1=normal, >1=more)"
#+ * FluidSettings|DomainFluidSettings.gravity -> gravity:   float[3]  "Gravity in X, Y and Z direction"
#+ * FluidSettings|DomainFluidSettings.grid_levels -> grid_levels:   int  "Number of coarsened grids to use (-1 for automatic)"
#+ * FluidSettings|DomainFluidSettings.memory_estimate -> memory_estimate:   string,  "(read-only)    Estimated amount of memory needed for baking the domain"
#+ * FluidSettings|DomainFluidSettings.partial_slip_factor -> partial_slip_factor:   float  "Amount of mixing between no- and free-slip, 0 is no slip and 1 is free slip"
#+ * FluidSettings|DomainFluidSettings.preview_resolution -> preview_resolution:   int  "Preview resolution in X,Y and Z direction"
#+ * FluidSettings|DomainFluidSettings.render_display_mode -> render_display_mode:   enum  "How to display the mesh for rendering"
#+ * FluidSettings|DomainFluidSettings.resolution -> resolution:   int  "Domain resolution in X,Y and Z direction"
#FluidSettings|DomainFluidSettings.simulation_scale -> simulation_scale:   float  "Size of the simulation domain in metres"
#+ * FluidSettings|DomainFluidSettings.slip_type -> slip_type:   enum  "NO DESCRIPTION"
#+ * FluidSettings|DomainFluidSettings.start_time -> start_time:   float  "Simulation time of the first blender frame (in seconds)"
#FluidSettings|DomainFluidSettings.surface_smooth -> surface_smooth:   float  "Amount of surface smoothing. A value of 0 is off, 1 is normal smoothing and more than 1 is extra smoothing"
#+ * FluidSettings|DomainFluidSettings.surface_subdivisions -> surface_subdivisions:   int  "Number of isosurface subdivisions. This is necessary for the inclusion of particles into the surface generation. Warning - can lead to longer computation times!"
#+ * FluidSettings|DomainFluidSettings.tracer_particles -> tracer_particles:   int  "Number of tracer particles to generate"
#FluidSettings|DomainFluidSettings.use_reverse_frames -> use_reverse_frames:   boolean  "Reverse fluid frames"
#FluidSettings|DomainFluidSettings.use_speed_vectors -> use_speed_vectors:   boolean  "Generate speed vectors for vector blur"
#FluidSettings|DomainFluidSettings.use_time_override -> use_time_override:   boolean  "Use a custom start and end time (in seconds) instead of the scenes timeline"
#+ * FluidSettings|DomainFluidSettings.viewport_display_mode -> viewport_display_mode:   enum  "How to display the mesh in the viewport"
#+ * FluidSettings|DomainFluidSettings.viscosity_base -> viscosity_base:   float  "Viscosity setting: value that is multiplied by 10 to the power of (exponent*-1)"
#+ * FluidSettings|DomainFluidSettings.viscosity_exponent -> viscosity_exponent:   int  "Negative exponent for the viscosity value (to simplify entering small values e.g. 5*10^-6.)"
#+ * FluidSettings|DomainFluidSettings.viscosity_preset -> viscosity_preset:   enum  "Set viscosity of the fluid to a preset value, or use manual input"
#+ * FluidSettings|FluidFluidSettings.initial_velocity -> initial_velocity:   float[3]  "Initial velocity of fluid"
#FluidSettings|FluidFluidSettings.use -> use:   boolean  "Object contributes to the fluid simulation"
#FluidSettings|FluidFluidSettings.use_animated_mesh -> use_animated_mesh:   boolean  "Export this mesh as an animated one. Slower, only use if really necessary (e.g. armatures or parented objects), animated pos/rot/scale IPOs do not require it"
#+ * FluidSettings|FluidFluidSettings.volume_initialization -> volume_initialization:   enum  "Volume initialization type"
#+ * FluidSettings|InflowFluidSettings.inflow_velocity -> inflow_velocity:   float[3]  "Initial velocity of fluid"
#FluidSettings|InflowFluidSettings.use -> use:   boolean  "Object contributes to the fluid simulation"
#FluidSettings|InflowFluidSettings.use_animated_mesh -> use_animated_mesh:   boolean  "Export this mesh as an animated one. Slower, only use if really necessary (e.g. armatures or parented objects), animated pos/rot/scale IPOs do not require it"
#FluidSettings|InflowFluidSettings.use_local_coords -> use_local_coords:   boolean  "Use local coordinates for inflow. (e.g. for rotating objects)"
#+ * FluidSettings|InflowFluidSettings.volume_initialization -> volume_initialization:   enum  "Volume initialization type"
#+ * FluidSettings|ObstacleFluidSettings.impact_factor -> impact_factor:   float  "This is an unphysical value for moving objects - it controls the impact an obstacle has on the fluid, =0 behaves a bit like outflow (deleting fluid), =1 is default, while >1 results in high forces. Can be used to tweak total mass"
#+ * FluidSettings|ObstacleFluidSettings.partial_slip_factor -> partial_slip_factor:   float  "Amount of mixing between no- and free-slip, 0 is no slip and 1 is free slip"
#+ * FluidSettings|ObstacleFluidSettings.slip_type -> slip_type:   enum  "NO DESCRIPTION"
#FluidSettings|ObstacleFluidSettings.use -> use:   boolean  "Object contributes to the fluid simulation"
#FluidSettings|ObstacleFluidSettings.use_animated_mesh -> use_animated_mesh:   boolean  "Export this mesh as an animated one. Slower, only use if really necessary (e.g. armatures or parented objects), animated pos/rot/scale IPOs do not require it"
#+ * FluidSettings|ObstacleFluidSettings.volume_initialization -> volume_initialization:   enum  "Volume initialization type"
#FluidSettings|OutflowFluidSettings.use -> use:   boolean  "Object contributes to the fluid simulation"
#FluidSettings|OutflowFluidSettings.use_animated_mesh -> use_animated_mesh:   boolean  "Export this mesh as an animated one. Slower, only use if really necessary (e.g. armatures or parented objects), animated pos/rot/scale IPOs do not require it"
#+ * FluidSettings|OutflowFluidSettings.volume_initialization -> volume_initialization:   enum  "Volume initialization type"
#+ * FluidSettings|ParticleFluidSettings.alpha_influence -> alpha_influence:   float  "Amount of particle alpha change, inverse of size influence: 0=off (all same alpha), 1=full. (large particles get lower alphas, smaller ones higher values)"
#FluidSettings|ParticleFluidSettings.filepath -> filepath:   string  "Directory (and/or filename prefix) to store and load particles from"
#+ * FluidSettings|ParticleFluidSettings.particle_influence -> particle_influence:   float  "Amount of particle size scaling: 0=off (all same size), 1=full (range 0.2-2.0), >1=stronger"
#FluidSettings|ParticleFluidSettings.show_tracer -> show_tracer:   boolean  "Show tracer particles"
#FluidSettings|ParticleFluidSettings.use_drops -> use_drops:   boolean  "Show drop particles"
#FluidSettings|ParticleFluidSettings.use_floats -> use_floats:   boolean  "Show floating foam particles"
#+ * Function.description -> description:   string,  "(read-only)    Description of the Functions purpose"
#+ * Function.identifier -> identifier:   string,  "(read-only)    Unique name used in the code and scripting"
#Function.is_registered -> is_registered:   boolean,  "(read-only)    Function is registered as callback as part of type registration"
#Function.is_registered_optional -> is_registered_optional:   boolean,  "(read-only)    Function is optionally registered as callback part of type registration"
#+ * Function.parameters -> parameters:   collection,  "(read-only)    Parameters for the function"
#Function.use_self -> use_self:   boolean,  "(read-only)    Function does not pass its self as an argument (becomes a class method in python)"
#+ * GPencilFrame.frame_number -> frame_number:   int  "The frame on which this sketch appears"
#GPencilFrame.is_edited -> is_edited:   boolean  "Frame is being edited (painted on)"
#+ * GPencilFrame.select -> select:   boolean  "Frame is selected for editing in the DopeSheet"
#+ * GPencilFrame.strokes -> strokes:   collection,  "(read-only)    Freehand curves defining the sketch on this frame"
#+ * GPencilLayer.active -> active:   boolean  "Set active layer for editing"
#+ * GPencilLayer.active_frame -> active_frame:   pointer,  "(read-only)    Frame currently being displayed for this layer"
#GPencilLayer.alpha -> alpha:   float  "Layer Opacity"
#+ * GPencilLayer.color -> color:   float[3]  "Color for all strokes in this layer"
#+ * GPencilLayer.frames -> frames:   collection,  "(read-only)    Sketches for this layer on different frames"
#GPencilLayer.ghost_range_max -> ghost_range_max:   int  "Maximum number of frames on either side of the active frame to show (0 = show the first available sketch on either side)"
#+ * GPencilLayer.hide -> hide:   boolean  "Set layer Visibility"
#+ * GPencilLayer.info -> info:   string  "Layer name"
#GPencilLayer.line_width -> line_width:   int  "Thickness of strokes (in pixels)"
#+ * GPencilLayer.lock -> lock:   boolean  "Protect layer from further editing and/or frame changes"
#GPencilLayer.lock_frame -> lock_frame:   boolean  "Lock current frame displayed by layer"
#+ * GPencilLayer.select -> select:   boolean  "Layer is selected for editing in the DopeSheet"
#+ * GPencilLayer.show_points -> show_points:   boolean  "Draw the points which make up the strokes (for debugging purposes)"
#+ * GPencilLayer.use_onion_skinning -> use_onion_skinning:   boolean  "Ghost frames on either side of frame"
#+ * GPencilStroke.points -> points:   collection,  "(read-only)    Stroke data points"
#+ * GPencilStrokePoint.co -> co:   float[3]  "NO DESCRIPTION"
#+ * GPencilStrokePoint.pressure -> pressure:   float  "Pressure of tablet at point when drawing it"
#+ * GameObjectSettings.actuators -> actuators:   collection,  "(read-only)    Game engine actuators to act on events"
#GameObjectSettings.collision_bounds_type -> collision_bounds_type:   enum  "Selects the collision type"
#+ * GameObjectSettings.collision_margin -> collision_margin:   float  "Extra margin around object for collision detection, small amount required for stability"
#+ * GameObjectSettings.controllers -> controllers:   collection,  "(read-only)    Game engine controllers to process events, connecting sensor to actuators"
#+ * GameObjectSettings.damping -> damping:   float  "General movement damping"
#+ * GameObjectSettings.form_factor -> form_factor:   float  "Form factor scales the inertia tensor"
#+ * GameObjectSettings.friction_coefficients -> friction_coefficients:   float[3]  "Relative friction coefficient in the in the X, Y and Z directions, when anisotropic friction is enabled"
#GameObjectSettings.lock_location_x -> lock_location_x:   boolean  "Disable simulation of linear motion along the X axis"
#GameObjectSettings.lock_location_y -> lock_location_y:   boolean  "Disable simulation of linear motion along the Y axis"
#GameObjectSettings.lock_location_z -> lock_location_z:   boolean  "Disable simulation of linear motion along the Z axis"
#GameObjectSettings.lock_rotation_x -> lock_rotation_x:   boolean  "Disable simulation of angular  motion along the X axis"
#GameObjectSettings.lock_rotation_y -> lock_rotation_y:   boolean  "Disable simulation of angular  motion along the Y axis"
#GameObjectSettings.lock_rotation_z -> lock_rotation_z:   boolean  "Disable simulation of angular  motion along the Z axis"
#+ * GameObjectSettings.mass -> mass:   float  "Mass of the object"
#+ * GameObjectSettings.physics_type -> physics_type:   enum  "Selects the type of physical representation"
#+ * GameObjectSettings.properties -> properties:   collection,  "(read-only)    Game engine properties"
#+ * GameObjectSettings.radius -> radius:   float  "Radius of bounding sphere and material physics"
#+ * GameObjectSettings.rotation_damping -> rotation_damping:   float  "General rotation damping"
#+ * GameObjectSettings.sensors -> sensors:   collection,  "(read-only)    Game engine sensor to detect events"
#+ * GameObjectSettings.show_actuators -> show_actuators:   boolean  "Shows actuators for this object in the user interface"
#+ * GameObjectSettings.show_controllers -> show_controllers:   boolean  "Shows controllers for this object in the user interface"
#GameObjectSettings.show_debug_state -> show_debug_state:   boolean  "Print state debug info in the game engine"
#+ * GameObjectSettings.show_sensors -> show_sensors:   boolean  "Shows sensors for this object in the user interface"
#+ * GameObjectSettings.show_state_panel -> show_state_panel:   boolean  "Show state panel"
#+ * GameObjectSettings.soft_body -> soft_body:   pointer,  "(read-only)    Settings for Bullet soft body simulation"
#GameObjectSettings.states_initial -> states_initial:   boolean[30]  "Initial state when the game starts"
#GameObjectSettings.states_visible -> states_visible:   boolean[30]  "State determining which controllers are displayed"
#+ * GameObjectSettings.use_activity_culling -> use_activity_culling:   boolean  "Disable simulation of angular  motion along the Z axis"
#GameObjectSettings.use_actor -> use_actor:   boolean  "Object is detected by the Near and Radar sensor"
#GameObjectSettings.use_all_states -> use_all_states:   boolean  "Set all state bits"
#GameObjectSettings.use_anisotropic_friction -> use_anisotropic_friction:   boolean  "Enable anisotropic friction"
#+ * GameObjectSettings.use_collision_bounds -> use_collision_bounds:   boolean  "Specify a collision bounds type other than the default"
#GameObjectSettings.use_collision_compound -> use_collision_compound:   boolean  "Add children to form a compound collision object"
#GameObjectSettings.use_ghost -> use_ghost:   boolean  "Object does not restitute collisions, like a ghost"
#GameObjectSettings.use_material_physics -> use_material_physics:   boolean  "Use physics settings in materials"
#GameObjectSettings.use_rotate_from_normal -> use_rotate_from_normal:   boolean  "Use face normal to rotate object, so that it points away from the surface"
#GameObjectSettings.use_sleep -> use_sleep:   boolean  "Disable auto (de)activation in physics simulation"
#GameObjectSettings.used_states -> used_states:   boolean[30],  "(read-only)    States which are being used by controllers"
#GameObjectSettings.velocity_max -> velocity_max:   float  "Clamp velocity to this maximum speed"
#GameObjectSettings.velocity_min -> velocity_min:   float  "Clamp velocity to this minimum speed (except when totally still)"
#+ * GameProperty.name -> name:   string  "Available as GameObject attributes in the game engines python API"
#GameProperty.show_debug -> show_debug:   boolean  "Print debug information for this property"
#+ * GameProperty.type -> type:   enum  "NO DESCRIPTION"
#+ * GameProperty|GameBooleanProperty.value -> value:   boolean  "Property value"
#+ * GameProperty|GameFloatProperty.value -> value:   float  "Property value"
#+ * GameProperty|GameIntProperty.value -> value:   int  "Property value"
#+ * GameProperty|GameStringProperty.value -> value:   string  "Property value"
#+ * GameProperty|GameTimerProperty.value -> value:   float  "Property value"
#+ * GameSoftBodySettings.cluster_iterations -> cluster_iterations:   int  "Specify the number of cluster iterations"
#GameSoftBodySettings.collision_margin -> collision_margin:   float  "Collision margin for soft body. Small value makes the algorithm unstable"
#+ * GameSoftBodySettings.dynamic_friction -> dynamic_friction:   float  "Dynamic Friction"
#GameSoftBodySettings.linear_stiffness -> linear_stiffness:   float  "Linear stiffness of the soft body links"
#GameSoftBodySettings.location_iterations -> location_iterations:   int  "Position solver iterations"
#GameSoftBodySettings.shape_threshold -> shape_threshold:   float  "Shape matching threshold"
#GameSoftBodySettings.use_bending_constraints -> use_bending_constraints:   boolean  "Enable bending constraints"
#GameSoftBodySettings.use_cluster_rigid_to_softbody -> use_cluster_rigid_to_softbody:   boolean  "Enable cluster collision between soft and rigid body"
#GameSoftBodySettings.use_cluster_soft_to_softbody -> use_cluster_soft_to_softbody:   boolean  "Enable cluster collision between soft and soft body"
#GameSoftBodySettings.use_shape_match -> use_shape_match:   boolean  "Enable soft body shape matching goal"
#GameSoftBodySettings.weld_threshold -> weld_threshold:   float  "Welding threshold: distance between nearby vertices to be considered equal => set to 0.0 to disable welding test and speed up scene loading (ok if the mesh has no duplicates)"
#+ * Header.bl_idname -> bl_idname:   string  "If this is set, the header gets a custom ID, otherwise it takes the name of the class used to define the panel. For example, if the class name is OBJECT_HT_hello, and bl_idname is not set by the script, then bl_idname = OBJECT_HT_hello"
#+ * Header.bl_space_type -> bl_space_type:   enum  "The space where the header is going to be used in."
#+ * Header.layout -> layout:   pointer,  "(read-only)    Defines the structure of the header in the UI."
#+ * Histogram.mode -> mode:   enum  "Channels to display when drawing the histogram"
#+ * ID.library -> library:   pointer,  "(read-only)    Library file the datablock is linked from"
#+ * ID.name -> name:   string  "Unique datablock ID name"
#+ * ID.tag -> tag:   boolean  "Tools can use this to tag data, (initial state is undefined)"
#ID.use_fake_user -> use_fake_user:   boolean  "Saves this datablock even if it has no users"
#+ * ID.users -> users:   int,  "(read-only)    Number of times this datablock is referenced"
#+ * IDProperty.collection -> collection:   collection,  "(read-only)"
#+ * IDProperty.double -> double:   float  "NO DESCRIPTION"
#+ * IDProperty.double_array -> double_array:   float[1]  "NO DESCRIPTION"
#+ * IDProperty.float -> float:   float  "NO DESCRIPTION"
#+ * IDProperty.float_array -> float_array:   float[1]  "NO DESCRIPTION"
#+ * IDProperty.group -> group:   pointer,  "(read-only)"
#+ * IDProperty.int -> int:   int  "NO DESCRIPTION"
#+ * IDProperty.int_array -> int_array:   int[1]  "NO DESCRIPTION"
#+ * IDProperty.string -> string:   string  "NO DESCRIPTION"
#+ * IDPropertyGroup.name -> name:   string  "Unique name used in the code and scripting"
#+ * IDPropertyGroup|NetRenderJob.name -> name:   string  "NO DESCRIPTION"
#+ * IDPropertyGroup|NetRenderSettings.active_blacklisted_slave_index -> active_blacklisted_slave_index:   int  "NO DESCRIPTION"
#+ * IDPropertyGroup|NetRenderSettings.active_job_index -> active_job_index:   int  "NO DESCRIPTION"
#+ * IDPropertyGroup|NetRenderSettings.active_slave_index -> active_slave_index:   int  "NO DESCRIPTION"
#+ * IDPropertyGroup|NetRenderSettings.chunks -> chunks:   int  "Number of frame to dispatch to each slave in one chunk"
#+ * IDPropertyGroup|NetRenderSettings.job_category -> job_category:   string  "Category of the job"
#+ * IDPropertyGroup|NetRenderSettings.job_id -> job_id:   string  "id of the last sent render job"
#+ * IDPropertyGroup|NetRenderSettings.job_name -> job_name:   string  "Name of the job"
#+ * IDPropertyGroup|NetRenderSettings.jobs -> jobs:   collection,  "(read-only)"
#+ * IDPropertyGroup|NetRenderSettings.mode -> mode:   enum  "Mode of operation of this instance"
#+ * IDPropertyGroup|NetRenderSettings.path -> path:   string  "Path for temporary files"
#+ * IDPropertyGroup|NetRenderSettings.priority -> priority:   int  "Priority of the job"
#+ * IDPropertyGroup|NetRenderSettings.server_address -> server_address:   string  "IP or name of the master render server"
#+ * IDPropertyGroup|NetRenderSettings.server_port -> server_port:   int  "port of the master render server"
#+ * IDPropertyGroup|NetRenderSettings.slaves -> slaves:   collection,  "(read-only)"
#+ * IDPropertyGroup|NetRenderSettings.slaves_blacklist -> slaves_blacklist:   collection,  "(read-only)"
#IDPropertyGroup|NetRenderSettings.use_master_broadcast -> use_master_broadcast:   boolean  "broadcast master server address on local network"
#IDPropertyGroup|NetRenderSettings.use_master_clear -> use_master_clear:   boolean  "delete saved files on exit"
#IDPropertyGroup|NetRenderSettings.use_slave_clear -> use_slave_clear:   boolean  "delete downloaded files on exit"
#IDPropertyGroup|NetRenderSettings.use_slave_output_log -> use_slave_output_log:   boolean  "Output render text log to console as well as sending it to the master"
#IDPropertyGroup|NetRenderSettings.use_slave_thumb -> use_slave_thumb:   boolean  "Generate thumbnails on slaves instead of master"
#+ * IDPropertyGroup|NetRenderSlave.name -> name:   string  "NO DESCRIPTION"
#+ * IDPropertyGroup|OperatorFileListElement.name -> name:   string  "the name of a file or directory within a file list"
#+ * IDPropertyGroup|OperatorMousePath.loc -> loc:   float[2]  "Mouse location"
#+ * IDPropertyGroup|OperatorMousePath.time -> time:   float  "Time of mouse location"
#+ * IDPropertyGroup|OperatorStrokeElement.location -> location:   float[3]  "NO DESCRIPTION"
#+ * IDPropertyGroup|OperatorStrokeElement.mouse -> mouse:   float[2]  "NO DESCRIPTION"
#+ * IDPropertyGroup|OperatorStrokeElement.pen_flip -> pen_flip:   boolean  "NO DESCRIPTION"
#+ * IDPropertyGroup|OperatorStrokeElement.pressure -> pressure:   float  "Tablet pressure"
#+ * IDPropertyGroup|OperatorStrokeElement.time -> time:   float  "NO DESCRIPTION"
#+ * IDPropertyGroup|PoseTemplate.name -> name:   string  "NO DESCRIPTION"
#+ * IDPropertyGroup|PoseTemplateSettings.active_template_index -> active_template_index:   int  "NO DESCRIPTION"
#+ * IDPropertyGroup|PoseTemplateSettings.templates -> templates:   collection,  "(read-only)"
#IDPropertyGroup|PoseTemplateSettings.use_generate_deform_rig -> use_generate_deform_rig:   boolean  "Create a copy of the metarig, constrainted by the generated rig"
#+ * ID|Action.fcurves -> fcurves:   collection,  "(read-only)    The individual F-Curves that make up the Action"
#+ * ID|Action.groups -> groups:   collection,  "(read-only)    Convenient groupings of F-Curves"
#+ * ID|Action.pose_markers -> pose_markers:   collection,  "(read-only)    Markers specific to this Action, for labeling poses"
#+ * ID|Armature.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
#+ * ID|Armature.bones -> bones:   collection,  "(read-only)"
#ID|Armature.draw_type -> draw_type:   enum  "NO DESCRIPTION"
#+ * ID|Armature.edit_bones -> edit_bones:   collection,  "(read-only)"
#+ * ID|Armature.ghost_frame_end -> ghost_frame_end:   int  "End frame of range of Ghosts to display (not for Around Current Frame Onion-skinning method)"
#+ * ID|Armature.ghost_frame_start -> ghost_frame_start:   int  "Starting frame of range of Ghosts to display (not for Around Current Frame Onion-skinning method)"
#+ * ID|Armature.ghost_size -> ghost_size:   int  "Frame step for Ghosts (not for On Keyframes Onion-skinning method)"
#+ * ID|Armature.ghost_step -> ghost_step:   int  "Number of frame steps on either side of current frame to show as ghosts (only for Around Current Frame Onion-skinning method)"
#+ * ID|Armature.ghost_type -> ghost_type:   enum  "Method of Onion-skinning for active Action"
#ID|Armature.layers -> layers:   boolean[32]  "Armature layer visibility"
#ID|Armature.layers_protected -> layers_protected:   boolean[32]  "Protected layers in Proxy Instances are restored to Proxy settings on file reload and undo"
#+ * ID|Armature.pose_position -> pose_position:   enum  "Show armature in binding pose or final posed state"
#ID|Armature.show_axes -> show_axes:   boolean  "Draw bone axes"
#ID|Armature.show_bone_custom_shapes -> show_bone_custom_shapes:   boolean  "Draw bones with their custom shapes"
#ID|Armature.show_group_colors -> show_group_colors:   boolean  "Draw bone group colors"
#ID|Armature.show_names -> show_names:   boolean  "Draw bone names"
#ID|Armature.show_only_ghost_selected -> show_only_ghost_selected:   boolean  "NO DESCRIPTION"
#ID|Armature.use_auto_ik -> use_auto_ik:   boolean  "Add temporaral IK constraints while grabbing bones in Pose Mode"
#ID|Armature.use_deform_delay -> use_deform_delay:   boolean  "Dont deform children when manipulating bones in Pose Mode"
#ID|Armature.use_deform_envelopes -> use_deform_envelopes:   boolean  "Enable Bone Envelopes when defining deform"
#ID|Armature.use_deform_preserve_volume -> use_deform_preserve_volume:   boolean  "Enable deform rotation with Quaternions"
#ID|Armature.use_deform_vertex_groups -> use_deform_vertex_groups:   boolean  "Enable Vertex Groups when defining deform"
#ID|Armature.use_mirror_x -> use_mirror_x:   boolean  "Apply changes to matching bone on opposite side of X-Axis"
#ID|Brush.auto_smooth_factor -> auto_smooth_factor:   float  "Amount of smoothing to automatically apply to each stroke"
#+ * ID|Brush.blend -> blend:   enum  "Brush blending mode"
#+ * ID|Brush.clone_alpha -> clone_alpha:   float  "Opacity of clone image display"
#+ * ID|Brush.clone_image -> clone_image:   pointer  "Image for clone tool"
#+ * ID|Brush.clone_offset -> clone_offset:   float[2]  "NO DESCRIPTION"
#+ * ID|Brush.color -> color:   float[3]  "NO DESCRIPTION"
#+ * ID|Brush.crease_pinch_factor -> crease_pinch_factor:   float  "How much the crease brush pinches"
#ID|Brush.cursor_color_add -> cursor_color_add:   float[3]  "Color of cursor when adding"
#ID|Brush.cursor_color_subtract -> cursor_color_subtract:   float[3]  "Color of cursor when subtracting"
#+ * ID|Brush.curve -> curve:   pointer,  "(read-only)    Editable falloff curve"
#+ * ID|Brush.direction -> direction:   enum  "NO DESCRIPTION"
#+ * ID|Brush.icon_filepath -> icon_filepath:   string  "File path to brush icon"
#+ * ID|Brush.imagepaint_tool -> imagepaint_tool:   enum  "NO DESCRIPTION"
#+ * ID|Brush.jitter -> jitter:   float  "Jitter the position of the brush while painting"
#+ * ID|Brush.normal_weight -> normal_weight:   float  "How much grab will pull vertexes out of surface during a grab"
#+ * ID|Brush.plane_offset -> plane_offset:   float  "Adjusts plane on which the brush acts towards or away from the object surface"
#+ * ID|Brush.plane_trim -> plane_trim:   float  "If a vertex is further from offset plane than this then it is not affected"
#+ * ID|Brush.rate -> rate:   float  "Interval between paints for Airbrush"
#+ * ID|Brush.sculpt_plane -> sculpt_plane:   enum  "NO DESCRIPTION"
#+ * ID|Brush.sculpt_tool -> sculpt_tool:   enum  "NO DESCRIPTION"
#+ * ID|Brush.size -> size:   int  "Radius of the brush in pixels"
#+ * ID|Brush.smooth_stroke_factor -> smooth_stroke_factor:   float  "Higher values give a smoother stroke"
#+ * ID|Brush.smooth_stroke_radius -> smooth_stroke_radius:   int  "Minimum distance from last point before stroke continues"
#ID|Brush.spacing -> spacing:   int  "Spacing between brush daubs as a percentage of brush diameter"
#+ * ID|Brush.strength -> strength:   float  "How powerful the effect of the brush is when applied"
#+ * ID|Brush.stroke_method -> stroke_method:   enum  "NO DESCRIPTION"
#+ * ID|Brush.texture -> texture:   pointer  "NO DESCRIPTION"
#ID|Brush.texture_angle_source_no_random -> texture_angle_source_no_random:   enum  "NO DESCRIPTION"
#ID|Brush.texture_angle_source_random -> texture_angle_source_random:   enum  "NO DESCRIPTION"
#+ * ID|Brush.texture_overlay_alpha -> texture_overlay_alpha:   int  "NO DESCRIPTION"
#+ * ID|Brush.texture_sample_bias -> texture_sample_bias:   float  "Value added to texture samples"
#+ * ID|Brush.texture_slot -> texture_slot:   pointer,  "(read-only)"
#+ * ID|Brush.unprojected_radius -> unprojected_radius:   float  "Radius of brush in Blender units"
#+ * ID|Brush.use_accumulate -> use_accumulate:   boolean  "Accumulate stroke dabs on top of each other"
#+ * ID|Brush.use_adaptive_space -> use_adaptive_space:   boolean  "Space daubs according to surface orientation instead of screen space"
#+ * ID|Brush.use_airbrush -> use_airbrush:   boolean  "Keep applying paint effect while holding mouse (spray)"
#+ * ID|Brush.use_alpha -> use_alpha:   boolean  "When this is disabled, lock alpha while painting"
#+ * ID|Brush.use_anchor -> use_anchor:   boolean  "Keep the brush anchored to the initial location"
#+ * ID|Brush.use_custom_icon -> use_custom_icon:   boolean  "Set the brush icon from an image file"
#ID|Brush.use_edge_to_edge -> use_edge_to_edge:   boolean  "Drag anchor brush from edge-to-edge"
#+ * ID|Brush.use_frontface -> use_frontface:   boolean  "Brush only affects vertexes that face the viewer"
#+ * ID|Brush.use_inverse_smooth_pressure -> use_inverse_smooth_pressure:   boolean  "Lighter pressure causes more smoothing to be applied"
#+ * ID|Brush.use_locked_size -> use_locked_size:   boolean  "When locked brush stays same size relative to object; when unlocked brush size is given in pixels"
#+ * ID|Brush.use_offset_pressure -> use_offset_pressure:   boolean  "Enable tablet pressure sensitivity for offset"
#+ * ID|Brush.use_original_normal -> use_original_normal:   boolean  "When locked keep using normal of surface where stroke was initiated"
#+ * ID|Brush.use_paint_sculpt -> use_paint_sculpt:   boolean  "Use this brush in sculpt mode"
#+ * ID|Brush.use_paint_texture -> use_paint_texture:   boolean  "Use this brush in texture paint mode"
#+ * ID|Brush.use_paint_vertex -> use_paint_vertex:   boolean  "Use this brush in vertex paint mode"
#+ * ID|Brush.use_paint_weight -> use_paint_weight:   boolean  "Use this brush in weight paint mode"
#+ * ID|Brush.use_persistent -> use_persistent:   boolean  "Sculpts on a persistent layer of the mesh"
#+ * ID|Brush.use_plane_trim -> use_plane_trim:   boolean  "Enable Plane Trim"
#ID|Brush.use_pressure_jitter -> use_pressure_jitter:   boolean  "Enable tablet pressure sensitivity for jitter"
#ID|Brush.use_pressure_size -> use_pressure_size:   boolean  "Enable tablet pressure sensitivity for size"
#ID|Brush.use_pressure_spacing -> use_pressure_spacing:   boolean  "Enable tablet pressure sensitivity for spacing"
#ID|Brush.use_pressure_strength -> use_pressure_strength:   boolean  "Enable tablet pressure sensitivity for strength"
#+ * ID|Brush.use_rake -> use_rake:   boolean  "Rotate the brush texture to match the stroke direction"
#+ * ID|Brush.use_random_rotation -> use_random_rotation:   boolean  "Rotate the brush texture at random"
#ID|Brush.use_restore_mesh -> use_restore_mesh:   boolean  "Allows a single dot to be carefully positioned"
#+ * ID|Brush.use_smooth_stroke -> use_smooth_stroke:   boolean  "Brush lags behind mouse and follows a smoother path"
#+ * ID|Brush.use_space -> use_space:   boolean  "Limit brush application to the distance specified by spacing"
#+ * ID|Brush.use_space_atten -> use_space_atten:   boolean  "Automatically adjusts strength to give consistent results for different spacings"
#+ * ID|Brush.use_texture_overlay -> use_texture_overlay:   boolean  "Show texture in viewport"
#+ * ID|Brush.use_wrap -> use_wrap:   boolean  "Enable torus wrapping while painting"
#+ * ID|Brush.vertexpaint_tool -> vertexpaint_tool:   enum  "NO DESCRIPTION"
#+ * ID|Camera.angle -> angle:   float  "Perspective Camera lens field of view in degrees"
#+ * ID|Camera.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
#+ * ID|Camera.clip_end -> clip_end:   float  "Camera far clipping distance"
#+ * ID|Camera.clip_start -> clip_start:   float  "Camera near clipping distance"
#+ * ID|Camera.dof_distance -> dof_distance:   float  "Distance to the focus point for depth of field"
#+ * ID|Camera.dof_object -> dof_object:   pointer  "Use this object to define the depth of field focal point"
#+ * ID|Camera.draw_size -> draw_size:   float  "Apparent size of the Camera object in the 3D View"
#+ * ID|Camera.lens -> lens:   float  "Perspective Camera lens value in millimeters"
#+ * ID|Camera.lens_unit -> lens_unit:   enum  "Unit to edit lens in for the user interface"
#+ * ID|Camera.ortho_scale -> ortho_scale:   float  "Orthographic Camera scale (similar to zoom)"
#+ * ID|Camera.passepartout_alpha -> passepartout_alpha:   float  "Opacity (alpha) of the darkened overlay in Camera view"
#+ * ID|Camera.shift_x -> shift_x:   float  "Perspective Camera horizontal shift"
#+ * ID|Camera.shift_y -> shift_y:   float  "Perspective Camera vertical shift"
#+ * ID|Camera.show_limits -> show_limits:   boolean  "Draw the clipping range and focus point on the camera"
#+ * ID|Camera.show_mist -> show_mist:   boolean  "Draw a line from the Camera to indicate the mist area"
#+ * ID|Camera.show_name -> show_name:   boolean  "Show the active Cameras name in Camera view"
#+ * ID|Camera.show_passepartout -> show_passepartout:   boolean  "Show a darkened overlay outside the image area in Camera view"
#+ * ID|Camera.show_title_safe -> show_title_safe:   boolean  "Show indicators for the title safe zone in Camera view"
#+ * ID|Camera.type -> type:   enum  "Camera types"
#ID|Camera.use_panorama -> use_panorama:   boolean  "Render the scene with a cylindrical camera for pseudo-fisheye lens effects"
#+ * ID|Curve.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
#+ * ID|Curve.bevel_depth -> bevel_depth:   float  "Bevel depth when not using a bevel object"
#+ * ID|Curve.bevel_object -> bevel_object:   pointer  "Curve object name that defines the bevel shape"
#+ * ID|Curve.bevel_resolution -> bevel_resolution:   int  "Bevel resolution when depth is non-zero and no specific bevel object has been defined"
#+ * ID|Curve.dimensions -> dimensions:   enum  "Select 2D or 3D curve type"
#+ * ID|Curve.eval_time -> eval_time:   float  "Parametric position along the length of the curve that Objects following it should be at. Position is evaluated by dividing by the Path Length value"
#+ * ID|Curve.extrude -> extrude:   float  "Amount of curve extrusion when not using a bevel object"
#+ * ID|Curve.materials -> materials:   collection,  "(read-only)"
#ID|Curve.offset -> offset:   float  "Scale the original width (1.0) based on given factor"
#ID|Curve.path_duration -> path_duration:   int  "The number of frames that are needed to traverse the path, defining the maximum value for the Evaluation Time setting"
#+ * ID|Curve.render_resolution_u -> render_resolution_u:   int  "Surface resolution in U direction used while rendering. Zero skips this property"
#+ * ID|Curve.render_resolution_v -> render_resolution_v:   int  "Surface resolution in V direction used while rendering. Zero skips this property"
#+ * ID|Curve.resolution_u -> resolution_u:   int  "Surface resolution in U direction"
#+ * ID|Curve.resolution_v -> resolution_v:   int  "Surface resolution in V direction"
#+ * ID|Curve.shape_keys -> shape_keys:   pointer,  "(read-only)"
#ID|Curve.show_handles -> show_handles:   boolean  "Display bezier handles in editmode"
#ID|Curve.show_normal_face -> show_normal_face:   boolean  "Display 3D curve normals in editmode"
#+ * ID|Curve.splines -> splines:   collection,  "(read-only)    Collection of splines in this curve data object"
#+ * ID|Curve.taper_object -> taper_object:   pointer  "Curve object name that defines the taper (width)"
#ID|Curve.texspace_location -> texspace_location:   float[3]  "Texture space location"
#+ * ID|Curve.texspace_size -> texspace_size:   float[3]  "Texture space size"
#+ * ID|Curve.twist_mode -> twist_mode:   enum  "The type of tilt calculation for 3D Curves"
#+ * ID|Curve.twist_smooth -> twist_smooth:   float  "Smoothing iteration for tangents"
#ID|Curve.use_auto_texspace -> use_auto_texspace:   boolean  "Adjusts active objects texture space automatically when transforming object"
#+ * ID|Curve.use_deform_bounds -> use_deform_bounds:   boolean  "Use the mesh bounds to clamp the deformation"
#ID|Curve.use_fill_back -> use_fill_back:   boolean  "Draw filled back for extruded/beveled curves"
#ID|Curve.use_fill_deform -> use_fill_deform:   boolean  "Fill curve after applying deformation"
#ID|Curve.use_fill_front -> use_fill_front:   boolean  "Draw filled front for extruded/beveled curves"
#ID|Curve.use_map_on_length -> use_map_on_length:   boolean  "Generate texture mapping coordinates following the curve direction, rather than the local bounding box"
#+ * ID|Curve.use_path -> use_path:   boolean  "Enable the curve to become a translation path"
#+ * ID|Curve.use_path_follow -> use_path_follow:   boolean  "Make curve path children to rotate along the path"
#+ * ID|Curve.use_radius -> use_radius:   boolean  "Option for paths: apply the curve radius with path following it and deforming"
#+ * ID|Curve.use_stretch -> use_stretch:   boolean  "Option for curve-deform: makes deformed child to stretch along entire path"
#+ * ID|Curve.use_time_offset -> use_time_offset:   boolean  "Children will use TimeOffs value as path distance offset"
#ID|Curve|SurfaceCurve.use_map_on_length -> use_map_on_length:   boolean  "Generate texture mapping coordinates following the curve direction, rather than the local bounding box"
#MAKE COLLECTION ATTR * ID|Curve|TextCurve.active_textbox -> active_textbox:   int  "NO DESCRIPTION"
#ID|Curve|TextCurve.align -> align:   enum  "Text align from the object center"
#+ * ID|Curve|TextCurve.body -> body:   string  "contents of this text object"
#+ * ID|Curve|TextCurve.body_format -> body_format:   collection,  "(read-only)    Stores the style of each character"
#+ * ID|Curve|TextCurve.edit_format -> edit_format:   pointer,  "(read-only)    Editing settings character formatting"
#+ * ID|Curve|TextCurve.family -> family:   string  "Use Blender Objects as font characters. Give font objects a common name followed by the character it represents, eg. familya, familyb etc, and turn on Verts Duplication"
#ID|Curve|TextCurve.follow_curve -> follow_curve:   pointer  "Curve deforming text object"
#+ * ID|Curve|TextCurve.font -> font:   pointer  "NO DESCRIPTION"
#+ * ID|Curve|TextCurve.offset_x -> offset_x:   float  "Horizontal offset from the object origin"
#+ * ID|Curve|TextCurve.offset_y -> offset_y:   float  "Vertical offset from the object origin"
#+ * ID|Curve|TextCurve.shear -> shear:   float  "Italic angle of the characters"
#ID|Curve|TextCurve.size -> size:   float  "NO DESCRIPTION"
#+ * ID|Curve|TextCurve.small_caps_scale -> small_caps_scale:   float  "Scale of small capitals"
#ID|Curve|TextCurve.space_character -> space_character:   float  "NO DESCRIPTION"
#ID|Curve|TextCurve.space_line -> space_line:   float  "NO DESCRIPTION"
#ID|Curve|TextCurve.space_word -> space_word:   float  "NO DESCRIPTION"
#ID|Curve|TextCurve.text_boxes -> text_boxes:   collection,  "(read-only)"
#ID|Curve|TextCurve.underline_height -> underline_height:   float  "NO DESCRIPTION"
#ID|Curve|TextCurve.underline_position -> underline_position:   float  "Vertical position of underline"
#ID|Curve|TextCurve.use_fast_edit -> use_fast_edit:   boolean  "Dont fill polygons while editing"
#ID|Curve|TextCurve.use_map_on_length -> use_map_on_length:   boolean  "Generate texture mapping coordinates following the curve direction, rather than the local bounding box"
#+ * ID|GreasePencil.draw_mode -> draw_mode:   enum  "NO DESCRIPTION"
#+ * ID|GreasePencil.layers -> layers:   collection,  "(read-only)"
#+ * ID|GreasePencil.use_stroke_endpoints -> use_stroke_endpoints:   boolean  "Only use the first and last parts of the stroke for snapping"
#+ * ID|Group.dupli_offset -> dupli_offset:   float[3]  "Offset from the origin to use when instancing as DupliGroup"
#ID|Group.layers -> layers:   boolean[20]  "Layers visible when this groups is instanced as a dupli"
#+ * ID|Group.objects -> objects:   collection,  "(read-only)    A collection of this groups objects"
#+ * ID|Image.bindcode -> bindcode:   int,  "(read-only)    OpenGL bindcode"
#+ * ID|Image.depth -> depth:   int,  "(read-only)    Image bit depth"
#+ * ID|Image.display_aspect -> display_aspect:   float[2]  "Display Aspect for this image, does not affect rendering"
#+ * ID|Image.field_order -> field_order:   enum  "Order of video fields. Select which lines are displayed first"
#+ * ID|Image.file_format -> file_format:   enum  "Format used for re-saving this file"
#+ * ID|Image.filepath -> filepath:   string  "Image/Movie file name"
#+ * ID|Image.filepath_raw -> filepath_raw:   string  "Image/Movie file name (without data refreshing)"
#ID|Image.fps -> fps:   int  "Speed of the animation in frames per second"
#ID|Image.frame_end -> frame_end:   int  "End frame of an animated texture"
#ID|Image.frame_start -> frame_start:   int  "Start frame of an animated texture"
#+ * ID|Image.generated_height -> generated_height:   int  "Generated image height"
#+ * ID|Image.generated_type -> generated_type:   enum  "Generated image type"
#+ * ID|Image.generated_width -> generated_width:   int  "Generated image width"
#+ * ID|Image.has_data -> has_data:   boolean,  "(read-only)    True if this image has data"
#ID|Image.is_dirty -> is_dirty:   boolean,  "(read-only)    Image has changed and is not saved"
#+ * ID|Image.mapping -> mapping:   enum  "Mapping type to use for this image in the game engine"
#+ * ID|Image.packed_file -> packed_file:   pointer,  "(read-only)"
#+ * ID|Image.size -> size:   int[2],  "(read-only)    Width and height in pixels, zero when image data cant be loaded"
#+ * ID|Image.source -> source:   enum  "Where the image comes from"
#+ * ID|Image.tiles_x -> tiles_x:   int  "Degree of repetition in the X direction"
#+ * ID|Image.tiles_y -> tiles_y:   int  "Degree of repetition in the Y direction"
#+ * ID|Image.type -> type:   enum,  "(read-only)    How to generate the image"
#ID|Image.use_animation -> use_animation:   boolean  "Use as animated texture in the game engine"
#ID|Image.use_clamp_x -> use_clamp_x:   boolean  "Disable texture repeating horizontally"
#ID|Image.use_clamp_y -> use_clamp_y:   boolean  "Disable texture repeating vertically"
#ID|Image.use_fields -> use_fields:   boolean  "Use fields of the image"
#ID|Image.use_premultiply -> use_premultiply:   boolean  "Convert RGB from key alpha to premultiplied alpha"
#ID|Image.use_tiles -> use_tiles:   boolean  "Use of tilemode for faces (default shift-LMB to pick the tile for selected faces)"
#+ * ID|Key.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
#+ * ID|Key.keys -> keys:   collection,  "(read-only)    Shape keys"
#+ * ID|Key.reference_key -> reference_key:   pointer,  "(read-only)"
#+ * ID|Key.slurph -> slurph:   int  "Creates a delay in amount of frames in applying keypositions, first vertex goes first"
#ID|Key.use_relative -> use_relative:   boolean  "Makes shape keys relative"
#+ * ID|Key.user -> user:   pointer,  "(read-only)    Datablock using these shape keys"
#+ * ID|Lamp.active_texture -> active_texture:   pointer  "Active texture slot being displayed"
#+ * ID|Lamp.active_texture_index -> active_texture_index:   int  "Index of active texture slot"
#+ * ID|Lamp.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
#+ * ID|Lamp.color -> color:   float[3]  "Light color"
#+ * ID|Lamp.distance -> distance:   float  "Falloff distance - the light is at half the original intensity at this point"
#+ * ID|Lamp.energy -> energy:   float  "Amount of light that the lamp emits"
#+ * ID|Lamp.texture_slots -> texture_slots:   collection,  "(read-only)    Texture slots defining the mapping and influence of textures"
#+ * ID|Lamp.type -> type:   enum  "Type of Lamp"
#ID|Lamp.use_diffuse -> use_diffuse:   boolean  "Lamp does diffuse shading"
#ID|Lamp.use_negative -> use_negative:   boolean  "Lamp casts negative light"
#ID|Lamp.use_own_layer -> use_own_layer:   boolean  "Illuminates objects only on the same layer the lamp is on"
#ID|Lamp.use_specular -> use_specular:   boolean  "Lamp creates specular highlights"
#+ * ID|Lamp|AreaLamp.gamma -> gamma:   float  "Light gamma correction value"
#+ * ID|Lamp|AreaLamp.shadow_adaptive_threshold -> shadow_adaptive_threshold:   float  "Threshold for Adaptive Sampling (Raytraced shadows)"
#+ * ID|Lamp|AreaLamp.shadow_color -> shadow_color:   float[3]  "Color of shadows cast by the lamp"
#+ * ID|Lamp|AreaLamp.shadow_method -> shadow_method:   enum  "Method to compute lamp shadow with"
#ID|Lamp|AreaLamp.shadow_ray_sample_method -> shadow_ray_sample_method:   enum  "Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower"
#+ * ID|Lamp|AreaLamp.shadow_ray_samples_x -> shadow_ray_samples_x:   int  "Amount of samples taken extra (samples x samples)"
#+ * ID|Lamp|AreaLamp.shadow_ray_samples_y -> shadow_ray_samples_y:   int  "Amount of samples taken extra (samples x samples)"
#+ * ID|Lamp|AreaLamp.shadow_soft_size -> shadow_soft_size:   float  "Light size for ray shadow sampling (Raytraced shadows)"
#+ * ID|Lamp|AreaLamp.shape -> shape:   enum  "Shape of the area lamp"
#+ * ID|Lamp|AreaLamp.size -> size:   float  "Size of the area of the area Lamp, X direction size for Rectangle shapes"
#+ * ID|Lamp|AreaLamp.size_y -> size_y:   float  "Size of the area of the area Lamp in the Y direction for Rectangle shapes"
#ID|Lamp|AreaLamp.use_dither -> use_dither:   boolean  "Use 2x2 dithering for sampling  (Constant Jittered sampling)"
#ID|Lamp|AreaLamp.use_jitter -> use_jitter:   boolean  "Use noise for sampling  (Constant Jittered sampling)"
#ID|Lamp|AreaLamp.use_only_shadow -> use_only_shadow:   boolean  "Causes light to cast shadows only without illuminating objects"
#ID|Lamp|AreaLamp.use_shadow_layer -> use_shadow_layer:   boolean  "Causes only objects on the same layer to cast shadows"
#ID|Lamp|AreaLamp.use_umbra -> use_umbra:   boolean  "Emphasize parts that are fully shadowed (Constant Jittered sampling)"
#+ * ID|Lamp|PointLamp.falloff_curve -> falloff_curve:   pointer,  "(read-only)    Custom Lamp Falloff Curve"
#+ * ID|Lamp|PointLamp.falloff_type -> falloff_type:   enum  "Intensity Decay with distance"
#+ * ID|Lamp|PointLamp.linear_attenuation -> linear_attenuation:   float  "Linear distance attenuation"
#+ * ID|Lamp|PointLamp.quadratic_attenuation -> quadratic_attenuation:   float  "Quadratic distance attenuation"
#+ * ID|Lamp|PointLamp.shadow_adaptive_threshold -> shadow_adaptive_threshold:   float  "Threshold for Adaptive Sampling (Raytraced shadows)"
#+ * ID|Lamp|PointLamp.shadow_color -> shadow_color:   float[3]  "Color of shadows cast by the lamp"
#+ * ID|Lamp|PointLamp.shadow_method -> shadow_method:   enum  "Method to compute lamp shadow with"
#ID|Lamp|PointLamp.shadow_ray_sample_method -> shadow_ray_sample_method:   enum  "Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower"
#+ * ID|Lamp|PointLamp.shadow_ray_samples -> shadow_ray_samples:   int  "Amount of samples taken extra (samples x samples)"
#+ * ID|Lamp|PointLamp.shadow_soft_size -> shadow_soft_size:   float  "Light size for ray shadow sampling (Raytraced shadows)"
#ID|Lamp|PointLamp.use_only_shadow -> use_only_shadow:   boolean  "Causes light to cast shadows only without illuminating objects"
#ID|Lamp|PointLamp.use_shadow_layer -> use_shadow_layer:   boolean  "Causes only objects on the same layer to cast shadows"
#ID|Lamp|PointLamp.use_sphere -> use_sphere:   boolean  "Sets light intensity to zero beyond lamp distance"
#+ * ID|Lamp|SpotLamp.compression_threshold -> compression_threshold:   float  "Deep shadow map compression threshold"
#+ * ID|Lamp|SpotLamp.falloff_curve -> falloff_curve:   pointer,  "(read-only)    Custom Lamp Falloff Curve"
#+ * ID|Lamp|SpotLamp.falloff_type -> falloff_type:   enum  "Intensity Decay with distance"
#+ * ID|Lamp|SpotLamp.halo_intensity -> halo_intensity:   float  "Brightness of the spotlights halo cone  (Buffer Shadows)"
#+ * ID|Lamp|SpotLamp.halo_step -> halo_step:   int  "Volumetric halo sampling frequency"
#+ * ID|Lamp|SpotLamp.linear_attenuation -> linear_attenuation:   float  "Linear distance attenuation"
#+ * ID|Lamp|SpotLamp.quadratic_attenuation -> quadratic_attenuation:   float  "Quadratic distance attenuation"
#+ * ID|Lamp|SpotLamp.shadow_adaptive_threshold -> shadow_adaptive_threshold:   float  "Threshold for Adaptive Sampling (Raytraced shadows)"
#+ * ID|Lamp|SpotLamp.shadow_buffer_bias -> shadow_buffer_bias:   float  "Shadow buffer sampling bias"
#+ * ID|Lamp|SpotLamp.shadow_buffer_clip_end -> shadow_buffer_clip_end:   float  "Shadow map clip end beyond which objects will not generate shadows"
#+ * ID|Lamp|SpotLamp.shadow_buffer_clip_start -> shadow_buffer_clip_start:   float  "Shadow map clip start: objects closer will not generate shadows"
#+ * ID|Lamp|SpotLamp.shadow_buffer_samples -> shadow_buffer_samples:   int  "Number of shadow buffer samples"
#+ * ID|Lamp|SpotLamp.shadow_buffer_size -> shadow_buffer_size:   int  "Resolution of the shadow buffer, higher values give crisper shadows but use more memory"
#+ * ID|Lamp|SpotLamp.shadow_buffer_soft -> shadow_buffer_soft:   float  "Size of shadow buffer sampling area"
#+ * ID|Lamp|SpotLamp.shadow_buffer_type -> shadow_buffer_type:   enum  "Type of shadow buffer"
#+ * ID|Lamp|SpotLamp.shadow_color -> shadow_color:   float[3]  "Color of shadows cast by the lamp"
#+ * ID|Lamp|SpotLamp.shadow_filter_type -> shadow_filter_type:   enum  "Type of shadow filter (Buffer Shadows)"
#+ * ID|Lamp|SpotLamp.shadow_method -> shadow_method:   enum  "Method to compute lamp shadow with"
#ID|Lamp|SpotLamp.shadow_ray_sample_method -> shadow_ray_sample_method:   enum  "Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower"
#+ * ID|Lamp|SpotLamp.shadow_ray_samples -> shadow_ray_samples:   int  "Amount of samples taken extra (samples x samples)"
#+ * ID|Lamp|SpotLamp.shadow_sample_buffers -> shadow_sample_buffers:   enum  "Number of shadow buffers to render for better AA, this increases memory usage"
#+ * ID|Lamp|SpotLamp.shadow_soft_size -> shadow_soft_size:   float  "Light size for ray shadow sampling (Raytraced shadows)"
#+ * ID|Lamp|SpotLamp.show_cone -> show_cone:   boolean  "Draw transparent cone in 3D view to visualize which objects are contained in it"
#+ * ID|Lamp|SpotLamp.spot_blend -> spot_blend:   float  "The softness of the spotlight edge"
#+ * ID|Lamp|SpotLamp.spot_size -> spot_size:   float  "Angle of the spotlight beam in degrees"
#ID|Lamp|SpotLamp.use_auto_clip_end -> use_auto_clip_end:   boolean  "Automatic calculation of clipping-end, based on visible vertices"
#ID|Lamp|SpotLamp.use_auto_clip_start -> use_auto_clip_start:   boolean  "Automatic calculation of clipping-start, based on visible vertices"
#ID|Lamp|SpotLamp.use_halo -> use_halo:   boolean  "Renders spotlight with a volumetric halo (Buffer Shadows)"
#ID|Lamp|SpotLamp.use_only_shadow -> use_only_shadow:   boolean  "Causes light to cast shadows only without illuminating objects"
#ID|Lamp|SpotLamp.use_shadow_layer -> use_shadow_layer:   boolean  "Causes only objects on the same layer to cast shadows"
#ID|Lamp|SpotLamp.use_sphere -> use_sphere:   boolean  "Sets light intensity to zero beyond lamp distance"
#ID|Lamp|SpotLamp.use_square -> use_square:   boolean  "Casts a square spot light shape"
#+ * ID|Lamp|SunLamp.shadow_adaptive_threshold -> shadow_adaptive_threshold:   float  "Threshold for Adaptive Sampling (Raytraced shadows)"
#+ * ID|Lamp|SunLamp.shadow_color -> shadow_color:   float[3]  "Color of shadows cast by the lamp"
#+ * ID|Lamp|SunLamp.shadow_method -> shadow_method:   enum  "Method to compute lamp shadow with"
#ID|Lamp|SunLamp.shadow_ray_sample_method -> shadow_ray_sample_method:   enum  "Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower"
#+ * ID|Lamp|SunLamp.shadow_ray_samples -> shadow_ray_samples:   int  "Amount of samples taken extra (samples x samples)"
#+ * ID|Lamp|SunLamp.shadow_soft_size -> shadow_soft_size:   float  "Light size for ray shadow sampling (Raytraced shadows)"
#+ * ID|Lamp|SunLamp.sky -> sky:   pointer,  "(read-only)    Sky related settings for sun lamps"
#ID|Lamp|SunLamp.use_only_shadow -> use_only_shadow:   boolean  "Causes light to cast shadows only without illuminating objects"
#ID|Lamp|SunLamp.use_shadow_layer -> use_shadow_layer:   boolean  "Causes only objects on the same layer to cast shadows"
#+ * ID|Lattice.interpolation_type_u -> interpolation_type_u:   enum  "NO DESCRIPTION"
#+ * ID|Lattice.interpolation_type_v -> interpolation_type_v:   enum  "NO DESCRIPTION"
#+ * ID|Lattice.interpolation_type_w -> interpolation_type_w:   enum  "NO DESCRIPTION"
#+ * ID|Lattice.points -> points:   collection,  "(read-only)    Points of the lattice"
#+ * ID|Lattice.points_u -> points_u:   int  "Points in U direction (cant be changed when there are shape keys)"
#+ * ID|Lattice.points_v -> points_v:   int  "Points in V direction (cant be changed when there are shape keys)"
#+ * ID|Lattice.points_w -> points_w:   int  "Points in W direction (cant be changed when there are shape keys)"
#+ * ID|Lattice.shape_keys -> shape_keys:   pointer,  "(read-only)"
#ID|Lattice.use_outside -> use_outside:   boolean  "Only draw, and take into account, the outer vertices"
#+ * ID|Lattice.vertex_group -> vertex_group:   string  "Vertex group to apply the influence of the lattice"
#+ * ID|Library.filepath -> filepath:   string  "Path to the library .blend file"
#+ * ID|Library.parent -> parent:   pointer,  "(read-only)"
#+ * ID|Material.active_node_material -> active_node_material:   pointer  "Active node material"
#+ * ID|Material.active_texture -> active_texture:   pointer  "Active texture slot being displayed"
#+ * ID|Material.active_texture_index -> active_texture_index:   int  "Index of active texture slot"
#+ * ID|Material.alpha -> alpha:   float  "Alpha transparency of the material"
#+ * ID|Material.ambient -> ambient:   float  "Amount of global ambient color the material receives"
#+ * ID|Material.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
#+ * ID|Material.darkness -> darkness:   float  "Minnaert darkness"
#+ * ID|Material.diffuse_color -> diffuse_color:   float[3]  "NO DESCRIPTION"
#+ * ID|Material.diffuse_fresnel -> diffuse_fresnel:   float  "Power of Fresnel"
#+ * ID|Material.diffuse_fresnel_factor -> diffuse_fresnel_factor:   float  "Blending factor of Fresnel"
#+ * ID|Material.diffuse_intensity -> diffuse_intensity:   float  "Amount of diffuse reflection"
#+ * ID|Material.diffuse_ramp -> diffuse_ramp:   pointer,  "(read-only)    Color ramp used to affect diffuse shading"
#+ * ID|Material.diffuse_ramp_blend -> diffuse_ramp_blend:   enum  "NO DESCRIPTION"
#+ * ID|Material.diffuse_ramp_factor -> diffuse_ramp_factor:   float  "Blending factor (also uses alpha in Colorband)"
#+ * ID|Material.diffuse_ramp_input -> diffuse_ramp_input:   enum  "NO DESCRIPTION"
#+ * ID|Material.diffuse_shader -> diffuse_shader:   enum  "NO DESCRIPTION"
#+ * ID|Material.diffuse_toon_size -> diffuse_toon_size:   float  "Size of diffuse toon area"
#+ * ID|Material.diffuse_toon_smooth -> diffuse_toon_smooth:   float  "Smoothness of diffuse toon area"
#+ * ID|Material.emit -> emit:   float  "Amount of light to emit"
#+ * ID|Material.halo -> halo:   pointer,  "(read-only)    Halo settings for the material"
#+ * ID|Material.invert_z -> invert_z:   boolean  "Renders materials faces with an inverted Z buffer (scanline only)"
#+ * ID|Material.light_group -> light_group:   pointer  "Limit lighting to lamps in this Group"
#+ * ID|Material.mirror_color -> mirror_color:   float[3]  "Mirror color of the material"
#+ * ID|Material.node_tree -> node_tree:   pointer,  "(read-only)    Node tree for node based materials"
#ID|Material.offset_z -> offset_z:   float  "Gives faces an artificial offset in the Z buffer for Z transparency"
#+ * ID|Material.physics -> physics:   pointer,  "(read-only)    Game physics settings"
#+ * ID|Material.preview_render_type -> preview_render_type:   enum  "Type of preview render"
#+ * ID|Material.raytrace_mirror -> raytrace_mirror:   pointer,  "(read-only)    Raytraced reflection settings for the material"
#+ * ID|Material.raytrace_transparency -> raytrace_transparency:   pointer,  "(read-only)    Raytraced transparency settings for the material"
#+ * ID|Material.roughness -> roughness:   float  "Oren-Nayar Roughness"
#+ * ID|Material.shadow_buffer_bias -> shadow_buffer_bias:   float  "Factor to multiply shadow buffer bias with (0 is ignore.)"
#ID|Material.shadow_cast_alpha -> shadow_cast_alpha:   float  "Shadow casting alpha, in use for Irregular and Deep shadow buffer"
#+ * ID|Material.shadow_ray_bias -> shadow_ray_bias:   float  "Shadow raytracing bias to prevent terminator problems on shadow boundary"
#+ * ID|Material.specular_alpha -> specular_alpha:   float  "Alpha transparency for specular areas"
#+ * ID|Material.specular_color -> specular_color:   float[3]  "Specular color of the material"
#+ * ID|Material.specular_hardness -> specular_hardness:   int  "NO DESCRIPTION"
#+ * ID|Material.specular_intensity -> specular_intensity:   float  "NO DESCRIPTION"
#+ * ID|Material.specular_ior -> specular_ior:   float  "NO DESCRIPTION"
#+ * ID|Material.specular_ramp -> specular_ramp:   pointer,  "(read-only)    Color ramp used to affect specular shading"
#+ * ID|Material.specular_ramp_blend -> specular_ramp_blend:   enum  "NO DESCRIPTION"
#+ * ID|Material.specular_ramp_factor -> specular_ramp_factor:   float  "Blending factor (also uses alpha in Colorband)"
#+ * ID|Material.specular_ramp_input -> specular_ramp_input:   enum  "NO DESCRIPTION"
#+ * ID|Material.specular_shader -> specular_shader:   enum  "NO DESCRIPTION"
#+ * ID|Material.specular_slope -> specular_slope:   float  "The standard deviation of surface slope"
#+ * ID|Material.specular_toon_size -> specular_toon_size:   float  "Size of specular toon area"
#+ * ID|Material.specular_toon_smooth -> specular_toon_smooth:   float  "Smoothness of specular toon area"
#+ * ID|Material.strand -> strand:   pointer,  "(read-only)    Strand settings for the material"
#+ * ID|Material.subsurface_scattering -> subsurface_scattering:   pointer,  "(read-only)    Subsurface scattering settings for the material"
#+ * ID|Material.texture_slots -> texture_slots:   collection,  "(read-only)    Texture slots defining the mapping and influence of textures"
#+ * ID|Material.translucency -> translucency:   float  "Amount of diffuse shading on the back side"
#+ * ID|Material.transparency_method -> transparency_method:   enum  "Method to use for rendering transparency"
#+ * ID|Material.type -> type:   enum  "Material type defining how the object is rendered"
#ID|Material.use_cast_approximate -> use_cast_approximate:   boolean  "Allow this material to cast shadows when using approximate ambient occlusion."
#ID|Material.use_cast_buffer_shadows -> use_cast_buffer_shadows:   boolean  "Allow this material to cast shadows from shadow buffer lamps"
#ID|Material.use_cast_shadows_only -> use_cast_shadows_only:   boolean  "Makes objects with this material appear invisible, only casting shadows (not rendered)"
#ID|Material.use_cubic -> use_cubic:   boolean  "Use cubic interpolation for diffuse values, for smoother transitions"
#+ * ID|Material.use_diffuse_ramp -> use_diffuse_ramp:   boolean  "Toggle diffuse ramp operations"
#ID|Material.use_face_texture -> use_face_texture:   boolean  "Replaces the objects base color with color from face assigned image textures"
#ID|Material.use_face_texture_alpha -> use_face_texture_alpha:   boolean  "Replaces the objects base alpha value with alpha from face assigned image textures"
#ID|Material.use_full_oversampling -> use_full_oversampling:   boolean  "Force this material to render full shading/textures for all anti-aliasing samples"
#ID|Material.use_light_group_exclusive -> use_light_group_exclusive:   boolean  "Material uses the light group exclusively - these lamps are excluded from other scene lighting"
#ID|Material.use_mist -> use_mist:   boolean  "Use mist with this material (in world settings)"
#+ * ID|Material.use_nodes -> use_nodes:   boolean  "Use shader nodes to render the material"
#ID|Material.use_object_color -> use_object_color:   boolean  "Modulate the result with a per-object color"
#ID|Material.use_only_shadow -> use_only_shadow:   boolean  "Renders shadows as the materials alpha value, making materials transparent except for shadowed areas"
#ID|Material.use_ray_shadow_bias -> use_ray_shadow_bias:   boolean  "Prevents raytraced shadow errors on surfaces with smooth shaded normals (terminator problem)"
#ID|Material.use_raytrace -> use_raytrace:   boolean  "Include this material and geometry that uses it in ray tracing calculations"
#ID|Material.use_shadeless -> use_shadeless:   boolean  "Makes this material insensitive to light or shadow"
#ID|Material.use_shadows -> use_shadows:   boolean  "Allows this material to receive shadows"
#+ * ID|Material.use_sky -> use_sky:   boolean  "Renders this material with zero alpha, with sky background in place (scanline only)"
#+ * ID|Material.use_specular_ramp -> use_specular_ramp:   boolean  "Toggle specular ramp operations"
#ID|Material.use_tangent_shading -> use_tangent_shading:   boolean  "Use the materials tangent vector instead of the normal for shading - for anisotropic shading effects"
#+ * ID|Material.use_textures -> use_textures:   boolean[18]  "Enable/Disable each texture"
#ID|Material.use_transparency -> use_transparency:   boolean  "Render material as transparent"
#ID|Material.use_transparent_shadows -> use_transparent_shadows:   boolean  "Allow this object to receive transparent shadows casted through other objects"
#ID|Material.use_vertex_color_light -> use_vertex_color_light:   boolean  "Add vertex colors as additional lighting"
#ID|Material.use_vertex_color_paint -> use_vertex_color_paint:   boolean  "Replaces object base color with vertex colors (multiplies with texture face face assigned textures)"
#+ * ID|Material.volume -> volume:   pointer,  "(read-only)    Volume settings for the material"
#+ * ID|Mesh.active_uv_texture_index -> active_uv_texture_index:   int  "Active UV texture index"
#+ * ID|Mesh.active_vertex_color_index -> active_vertex_color_index:   int  "Active vertex color index"
#+ * ID|Mesh.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
#ID|Mesh.auto_smooth_angle -> auto_smooth_angle:   int  "Defines maximum angle between face normals that Auto Smooth will operate on"
#+ * ID|Mesh.edges -> edges:   collection,  "(read-only)    Edges of the mesh"
#+ * ID|Mesh.faces -> faces:   collection,  "(read-only)    Faces of the mesh"
#ID|Mesh.layers_float -> layers_float:   collection,  "(read-only)"
#ID|Mesh.layers_int -> layers_int:   collection,  "(read-only)"
#ID|Mesh.layers_string -> layers_string:   collection,  "(read-only)"
#+ * ID|Mesh.materials -> materials:   collection,  "(read-only)"
#+ * ID|Mesh.shape_keys -> shape_keys:   pointer,  "(read-only)"
#ID|Mesh.show_all_edges -> show_all_edges:   boolean  "Displays all edges for wireframe in all view modes in the 3D view"
#ID|Mesh.show_double_sided -> show_double_sided:   boolean  "Render/display the mesh with double or single sided lighting"
#ID|Mesh.show_edge_bevel_weight -> show_edge_bevel_weight:   boolean  "Displays weights created for the Bevel modifier"
#ID|Mesh.show_edge_crease -> show_edge_crease:   boolean  "Displays creases created for subsurf weighting"
#ID|Mesh.show_edge_seams -> show_edge_seams:   boolean  "Displays UV unwrapping seams"
#ID|Mesh.show_edge_sharp -> show_edge_sharp:   boolean  "Displays sharp edges, used with the EdgeSplit modifier"
#ID|Mesh.show_edges -> show_edges:   boolean  "Displays selected edges using highlights in the 3D view and UV editor"
#ID|Mesh.show_extra_edge_angle -> show_extra_edge_angle:   boolean  "Displays the angles in the selected edges in degrees, Using global values when set in the transform panel"
#ID|Mesh.show_extra_edge_length -> show_extra_edge_length:   boolean  "Displays selected edge lengths, Using global values when set in the transform panel"
#ID|Mesh.show_extra_face_area -> show_extra_face_area:   boolean  "Displays the area of selected faces, Using global values when set in the transform panel"
#ID|Mesh.show_faces -> show_faces:   boolean  "Displays all faces as shades in the 3D view and UV editor"
#ID|Mesh.show_normal_face -> show_normal_face:   boolean  "Displays face normals as lines"
#ID|Mesh.show_normal_vertex -> show_normal_vertex:   boolean  "Displays vertex normals as lines"
#+ * ID|Mesh.sticky -> sticky:   collection,  "(read-only)    Sticky texture coordinates"
#+ * ID|Mesh.texco_mesh -> texco_mesh:   pointer  "Derive texture coordinates from another mesh"
#ID|Mesh.texspace_location -> texspace_location:   float[3]  "Texture space location"
#+ * ID|Mesh.texspace_size -> texspace_size:   float[3]  "Texture space size"
#+ * ID|Mesh.texture_mesh -> texture_mesh:   pointer  "Use another mesh for texture indices (vertex indices must be aligned)"
#+ * ID|Mesh.total_edge_sel -> total_edge_sel:   int,  "(read-only)    Selected edge count in editmode"
#+ * ID|Mesh.total_face_sel -> total_face_sel:   int,  "(read-only)    Selected face count in editmode"
#+ * ID|Mesh.total_vert_sel -> total_vert_sel:   int,  "(read-only)    Selected vertex count in editmode"
#ID|Mesh.use_auto_smooth -> use_auto_smooth:   boolean  "Treats all set-smoothed faces with angles less than the specified angle as smooth during render"
#ID|Mesh.use_auto_texspace -> use_auto_texspace:   boolean  "Adjusts active objects texture space automatically when transforming object"
#+ * ID|Mesh.use_mirror_topology -> use_mirror_topology:   boolean  "Use topology based mirroring"
#+ * ID|Mesh.use_mirror_x -> use_mirror_x:   boolean  "X Axis mirror editing"
#+ * ID|Mesh.use_paint_mask -> use_paint_mask:   boolean  "Face selection masking for painting"
#+ * ID|Mesh.uv_texture_clone -> uv_texture_clone:   pointer  "UV texture to be used as cloning source"
#+ * ID|Mesh.uv_texture_clone_index -> uv_texture_clone_index:   int  "Clone UV texture index"
#+ * ID|Mesh.uv_texture_stencil -> uv_texture_stencil:   pointer  "UV texture to mask the painted area"
#+ * ID|Mesh.uv_texture_stencil_index -> uv_texture_stencil_index:   int  "Mask UV texture index"
#+ * ID|Mesh.uv_textures -> uv_textures:   collection,  "(read-only)"
#+ * ID|Mesh.vertex_colors -> vertex_colors:   collection,  "(read-only)"
#ID|Mesh.vertices -> vertices:   collection,  "(read-only)    Vertices of the mesh"
#+ * ID|MetaBall.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
#+ * ID|MetaBall.elements -> elements:   collection,  "(read-only)    Meta elements"
#+ * ID|MetaBall.materials -> materials:   collection,  "(read-only)"
#ID|MetaBall.render_resolution -> render_resolution:   float  "Polygonization resolution in rendering"
#ID|MetaBall.resolution -> resolution:   float  "Polygonization resolution in the 3D viewport"
#ID|MetaBall.texspace_location -> texspace_location:   float[3]  "Texture space location"
#+ * ID|MetaBall.texspace_size -> texspace_size:   float[3]  "Texture space size"
#+ * ID|MetaBall.threshold -> threshold:   float  "Influence of meta elements"
#ID|MetaBall.update_method -> update_method:   enum  "Metaball edit update behavior"
#ID|MetaBall.use_auto_texspace -> use_auto_texspace:   boolean  "Adjusts active objects texture space automatically when transforming object"
#+ * ID|NodeTree.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
#+ * ID|NodeTree.grease_pencil -> grease_pencil:   pointer  "Grease Pencil datablock"
#+ * ID|NodeTree.nodes -> nodes:   collection,  "(read-only)"
#+ * ID|Object.active_material -> active_material:   pointer  "Active material being displayed"
#+ * ID|Object.active_material_index -> active_material_index:   int  "Index of active material slot"
#+ * ID|Object.active_particle_system -> active_particle_system:   pointer,  "(read-only)    Active particle system being displayed"
#+ * ID|Object.active_particle_system_index -> active_particle_system_index:   int  "Index of active particle system slot"
#+ * ID|Object.active_shape_key -> active_shape_key:   pointer,  "(read-only)    Current shape key"
#+ * ID|Object.active_shape_key_index -> active_shape_key_index:   int  "Current shape key index"
#+ * ID|Object.active_vertex_group -> active_vertex_group:   pointer,  "(read-only)    Vertex groups of the object"
#+ * ID|Object.active_vertex_group_index -> active_vertex_group_index:   int  "Active index in vertex group array"
#+ * ID|Object.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
#+ * ID|Object.animation_visualisation -> animation_visualisation:   pointer,  "(read-only)    Animation data for this datablock"
#+ * ID|Object.bound_box -> bound_box:   float[24],  "(read-only)    Objects bound box in object-space coordinates"
#+ * ID|Object.collision -> collision:   pointer,  "(read-only)    Settings for using the objects as a collider in physics simulation"
#+ * ID|Object.color -> color:   float[4]  "Object color and alpha, used when faces have the ObColor mode enabled"
#+ * ID|Object.constraints -> constraints:   collection,  "(read-only)    Constraints affecting the transformation of the object"
#+ * ID|Object.data -> data:   pointer  "Object data"
#+ * ID|Object.delta_location -> delta_location:   float[3]  "Extra translation added to the location of the object"
#+ * ID|Object.delta_rotation_euler -> delta_rotation_euler:   float[3]  "Extra rotation added to the rotation of the object (when using Euler rotations)"
#+ * ID|Object.delta_rotation_quaternion -> delta_rotation_quaternion:   float[4]  "Extra rotation added to the rotation of the object (when using Quaternion rotations)"
#+ * ID|Object.delta_scale -> delta_scale:   float[3]  "Extra scaling added to the scale of the object"
#+ * ID|Object.dimensions -> dimensions:   float[3]  "Absolute bounding box dimensions of the object"
#+ * ID|Object.draw_bounds_type -> draw_bounds_type:   enum  "Object boundary display type"
#ID|Object.draw_type -> draw_type:   enum  "Maximum draw type to display object with in viewport"
#+ * ID|Object.dupli_faces_scale -> dupli_faces_scale:   float  "Scale the DupliFace objects"
#+ * ID|Object.dupli_frames_end -> dupli_frames_end:   int  "End frame for DupliFrames"
#+ * ID|Object.dupli_frames_off -> dupli_frames_off:   int  "Recurring frames to exclude from the Dupliframes"
#+ * ID|Object.dupli_frames_on -> dupli_frames_on:   int  "Number of frames to use between DupOff frames"
#+ * ID|Object.dupli_frames_start -> dupli_frames_start:   int  "Start frame for DupliFrames"
#+ * ID|Object.dupli_group -> dupli_group:   pointer  "Instance an existing group"
#+ * ID|Object.dupli_list -> dupli_list:   collection,  "(read-only)    Object duplis"
#+ * ID|Object.dupli_type -> dupli_type:   enum  "If not None, object duplication method to use"
#+ * ID|Object.empty_draw_size -> empty_draw_size:   float  "Size of display for empties in the viewport"
#+ * ID|Object.empty_draw_type -> empty_draw_type:   enum  "Viewport display style for empties"
#+ * ID|Object.field -> field:   pointer,  "(read-only)    Settings for using the objects as a field in physics simulation"
#+ * ID|Object.game -> game:   pointer,  "(read-only)    Game engine related settings for the object"
#+ * ID|Object.grease_pencil -> grease_pencil:   pointer  "Grease Pencil datablock"
#+ * ID|Object.hide -> hide:   boolean  "Restrict visibility in the viewport"
#+ * ID|Object.hide_render -> hide_render:   boolean  "Restrict renderability"
#+ * ID|Object.hide_select -> hide_select:   boolean  "Restrict selection in the viewport"
#ID|Object.is_duplicator -> is_duplicator:   boolean,  "(read-only)"
#+ * ID|Object.layers -> layers:   boolean[20]  "Layers the object is on"
#+ * ID|Object.location -> location:   float[3]  "Location of the object"
#+ * ID|Object.lock_location -> lock_location:   boolean[3]  "Lock editing of location in the interface"
#+ * ID|Object.lock_rotation -> lock_rotation:   boolean[3]  "Lock editing of rotation in the interface"
#+ * ID|Object.lock_rotation_w -> lock_rotation_w:   boolean  "Lock editing of angle component of four-component rotations in the interface"
#+ * ID|Object.lock_rotations_4d -> lock_rotations_4d:   boolean  "Lock editing of four component rotations by components (instead of as Eulers)"
#+ * ID|Object.lock_scale -> lock_scale:   boolean[3]  "Lock editing of scale in the interface"
#+ * ID|Object.material_slots -> material_slots:   collection,  "(read-only)    Material slots in the object"
#+ * ID|Object.matrix_local -> matrix_local:   float[16]  "Parent relative transformation matrix"
#+ * ID|Object.matrix_world -> matrix_world:   float[16]  "Worldspace transformation matrix"
#+ * ID|Object.mode -> mode:   enum,  "(read-only)    Object interaction mode"
#+ * ID|Object.modifiers -> modifiers:   collection,  "(read-only)    Modifiers affecting the geometric data of the object"
#+ * ID|Object.motion_path -> motion_path:   pointer,  "(read-only)    Motion Path for this element"
#+ * ID|Object.parent -> parent:   pointer  "Parent Object"
#+ * ID|Object.parent_bone -> parent_bone:   string  "Name of parent bone in case of a bone parenting relation"
#+ * ID|Object.parent_type -> parent_type:   enum  "Type of parent relation"
#+ * ID|Object.parent_vertices -> parent_vertices:   int[3],  "(read-only)    Indices of vertices in cases of a vertex parenting relation"
#+ * ID|Object.particle_systems -> particle_systems:   collection,  "(read-only)    Particle systems emitted from the object"
#+ * ID|Object.pass_index -> pass_index:   int  "Index # for the IndexOB render pass"
#+ * ID|Object.pose -> pose:   pointer,  "(read-only)    Current pose for armatures"
#+ * ID|Object.pose_library -> pose_library:   pointer,  "(read-only)    Action used as a pose library for armatures"
#+ * ID|Object.proxy -> proxy:   pointer,  "(read-only)    Library object this proxy object controls"
#+ * ID|Object.proxy_group -> proxy_group:   pointer,  "(read-only)    Library group duplicator object this proxy object controls"
#+ * ID|Object.rotation_axis_angle -> rotation_axis_angle:   float[4]  "Angle of Rotation for Axis-Angle rotation representation"
#+ * ID|Object.rotation_euler -> rotation_euler:   float[3]  "Rotation in Eulers"
#+ * ID|Object.rotation_mode -> rotation_mode:   enum  "NO DESCRIPTION"
#+ * ID|Object.rotation_quaternion -> rotation_quaternion:   float[4]  "Rotation in Quaternions"
#+ * ID|Object.scale -> scale:   float[3]  "Scaling of the object"
#+ * ID|Object.select -> select:   boolean  "Object selection state"
#ID|Object.show_axis -> show_axis:   boolean  "Displays the objects origin and axis"
#ID|Object.show_bounds -> show_bounds:   boolean  "Displays the objects bounds"
#ID|Object.show_name -> show_name:   boolean  "Displays the objects name"
#ID|Object.show_shape_key -> show_shape_key:   boolean  "Always show the current Shape for this Object"
#ID|Object.show_texture_space -> show_texture_space:   boolean  "Displays the objects texture space"
#ID|Object.show_transparent -> show_transparent:   boolean  "Enables transparent materials for the object (Mesh only)"
#ID|Object.show_wire -> show_wire:   boolean  "Adds the objects wireframe over solid drawing"
#ID|Object.show_x_ray -> show_x_ray:   boolean  "Makes the object draw in front of others"
#+ * ID|Object.soft_body -> soft_body:   pointer,  "(read-only)    Settings for soft body simulation"
#+ * ID|Object.time_offset -> time_offset:   float  "Animation offset in frames for F-Curve and dupligroup instances"
#+ * ID|Object.track_axis -> track_axis:   enum  "Axis that points in forward direction"
#+ * ID|Object.type -> type:   enum,  "(read-only)    Type of Object"
#+ * ID|Object.up_axis -> up_axis:   enum  "Axis that points in the upward direction"
#+ * ID|Object.use_dupli_faces_scale -> use_dupli_faces_scale:   boolean  "Scale dupli based on face size"
#+ * ID|Object.use_dupli_frames_speed -> use_dupli_frames_speed:   boolean  "Set dupliframes to use the frame"
#ID|Object.use_dupli_vertices_rotation -> use_dupli_vertices_rotation:   boolean  "Rotate dupli according to vertex normal"
#ID|Object.use_shape_key_edit_mode -> use_shape_key_edit_mode:   boolean  "Apply shape keys in edit mode (for Meshes only)"
#ID|Object.use_slow_parent -> use_slow_parent:   boolean  "Create a delay in the parent relationship"
#ID|Object.use_time_offset_add_parent -> use_time_offset_add_parent:   boolean  "Add the parents time offset value"
#ID|Object.use_time_offset_edit -> use_time_offset_edit:   boolean  "Use time offset when inserting keys and display time offset for F-Curve and action views"
#ID|Object.use_time_offset_parent -> use_time_offset_parent:   boolean  "Apply the time offset to this objects parent relationship"
#ID|Object.use_time_offset_particle -> use_time_offset_particle:   boolean  "Let the time offset work on the particle effect"
#+ * ID|Object.vertex_groups -> vertex_groups:   collection,  "(read-only)    Vertex groups of the object"
#+ * ID|ParticleSettings.active_dupliweight -> active_dupliweight:   pointer,  "(read-only)"
#+ * ID|ParticleSettings.active_dupliweight_index -> active_dupliweight_index:   int  "NO DESCRIPTION"
#+ * ID|ParticleSettings.adaptive_angle -> adaptive_angle:   int  "How many degrees path has to curve to make another render segment"
#ID|ParticleSettings.adaptive_pixel -> adaptive_pixel:   int  "How many pixels path has to cover to make another render segment"
#+ * ID|ParticleSettings.angular_velocity_factor -> angular_velocity_factor:   float  "Angular velocity amount"
#+ * ID|ParticleSettings.angular_velocity_mode -> angular_velocity_mode:   enum  "Particle angular velocity mode"
#+ * ID|ParticleSettings.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
#ID|ParticleSettings.apply_effector_to_children -> apply_effector_to_children:   boolean  "Apply effectors to children"
#ID|ParticleSettings.apply_guide_to_children -> apply_guide_to_children:   boolean  "NO DESCRIPTION"
#+ * ID|ParticleSettings.billboard_align -> billboard_align:   enum  "In respect to what the billboards are aligned"
#+ * ID|ParticleSettings.billboard_animation -> billboard_animation:   enum  "How to animate billboard textures"
#+ * ID|ParticleSettings.billboard_object -> billboard_object:   pointer  "Billboards face this object (default is active camera)"
#+ * ID|ParticleSettings.billboard_offset -> billboard_offset:   float[2]  "NO DESCRIPTION"
#ID|ParticleSettings.billboard_offset_split -> billboard_offset_split:   enum  "How to offset billboard textures"
#+ * ID|ParticleSettings.billboard_tilt -> billboard_tilt:   float  "Tilt of the billboards"
#ID|ParticleSettings.billboard_tilt_random -> billboard_tilt_random:   float  "Random tilt of the billboards"
#+ * ID|ParticleSettings.billboard_uv_split -> billboard_uv_split:   int  "Amount of rows/columns to split UV coordinates for billboards"
#+ * ID|ParticleSettings.boids -> boids:   pointer,  "(read-only)"
#+ * ID|ParticleSettings.branch_threshold -> branch_threshold:   float  "Threshold of branching"
#+ * ID|ParticleSettings.brownian_factor -> brownian_factor:   float  "Specify the amount of Brownian motion"
#+ * ID|ParticleSettings.child_length -> child_length:   float  "Length of child paths"
#ID|ParticleSettings.child_length_threshold -> child_length_threshold:   float  "Amount of particles left untouched by child path length"
#+ * ID|ParticleSettings.child_nbr -> child_nbr:   int  "Amount of children/parent"
#+ * ID|ParticleSettings.child_radius -> child_radius:   float  "Radius of children around parent"
#+ * ID|ParticleSettings.child_roundness -> child_roundness:   float  "Roundness of children around parent"
#+ * ID|ParticleSettings.child_size -> child_size:   float  "A multiplier for the child particle size"
#ID|ParticleSettings.child_size_random -> child_size_random:   float  "Random variation to the size of the child particles"
#+ * ID|ParticleSettings.child_type -> child_type:   enum  "Create child particles"
#+ * ID|ParticleSettings.clump_factor -> clump_factor:   float  "Amount of clumping"
#ID|ParticleSettings.clump_shape -> clump_shape:   float  "Shape of clumping"
#ID|ParticleSettings.count -> count:   int  "Total number of particles"
#ID|ParticleSettings.damping -> damping:   float  "Specify the amount of damping"
#+ * ID|ParticleSettings.distribution -> distribution:   enum  "How to distribute particles on selected element"
#+ * ID|ParticleSettings.drag_factor -> drag_factor:   float  "Specify the amount of air-drag"
#ID|ParticleSettings.draw_method -> draw_method:   enum  "How particles are drawn in viewport"
#ID|ParticleSettings.draw_percentage -> draw_percentage:   int  "Percentage of particles to display in 3D view"
#+ * ID|ParticleSettings.draw_size -> draw_size:   int  "Size of particles on viewport in pixels (0=default)"
#+ * ID|ParticleSettings.draw_step -> draw_step:   int  "How many steps paths are drawn with (power of 2)"
#+ * ID|ParticleSettings.dupli_group -> dupli_group:   pointer  "Show Objects in this Group in place of particles"
#+ * ID|ParticleSettings.dupli_object -> dupli_object:   pointer  "Show this Object in place of particles"
#ID|ParticleSettings.dupli_weights -> dupli_weights:   collection,  "(read-only)    Weights for all of the objects in the dupli group"
#+ * ID|ParticleSettings.effect_hair -> effect_hair:   float  "Hair stiffness for effectors"
#+ * ID|ParticleSettings.effector_weights -> effector_weights:   pointer,  "(read-only)"
#+ * ID|ParticleSettings.emit_from -> emit_from:   enum  "Where to emit particles from"
#ID|ParticleSettings.factor_random -> factor_random:   float  "Give the starting speed a random variation"
#+ * ID|ParticleSettings.fluid -> fluid:   pointer,  "(read-only)"
#+ * ID|ParticleSettings.force_field_1 -> force_field_1:   pointer,  "(read-only)"
#+ * ID|ParticleSettings.force_field_2 -> force_field_2:   pointer,  "(read-only)"
#+ * ID|ParticleSettings.frame_end -> frame_end:   float  "Frame # to stop emitting particles"
#+ * ID|ParticleSettings.frame_start -> frame_start:   float  "Frame # to start emitting particles"
#+ * ID|ParticleSettings.grid_resolution -> grid_resolution:   int  "The resolution of the particle grid"
#+ * ID|ParticleSettings.hair_step -> hair_step:   int  "Number of hair segments"
#+ * ID|ParticleSettings.integrator -> integrator:   enum  "Select physics integrator type"
#ID|ParticleSettings.invert_grid -> invert_grid:   boolean  "Invert what is considered object and what is not"
#+ * ID|ParticleSettings.jitter_factor -> jitter_factor:   float  "Amount of jitter applied to the sampling"
#+ * ID|ParticleSettings.keyed_loops -> keyed_loops:   int  "Number of times the keys are looped"
#+ * ID|ParticleSettings.keys_step -> keys_step:   int  "NO DESCRIPTION"
#+ * ID|ParticleSettings.kink -> kink:   enum  "Type of periodic offset on the path"
#+ * ID|ParticleSettings.kink_amplitude -> kink_amplitude:   float  "The amplitude of the offset"
#+ * ID|ParticleSettings.kink_axis -> kink_axis:   enum  "Which axis to use for offset"
#+ * ID|ParticleSettings.kink_frequency -> kink_frequency:   float  "The frequency of the offset (1/total length)"
#+ * ID|ParticleSettings.kink_shape -> kink_shape:   float  "Adjust the offset to the beginning/end"
#ID|ParticleSettings.length_random -> length_random:   float  "Give path length a random variation"
#+ * ID|ParticleSettings.lifetime -> lifetime:   float  "Specify the life span of the particles"
#ID|ParticleSettings.lifetime_random -> lifetime_random:   float  "Give the particle life a random variation"
#+ * ID|ParticleSettings.line_length_head -> line_length_head:   float  "Length of the lines head"
#+ * ID|ParticleSettings.line_length_tail -> line_length_tail:   float  "Length of the lines tail"
#ID|ParticleSettings.lock_billboard -> lock_billboard:   boolean  "Lock the billboards align axis"
#ID|ParticleSettings.lock_boids_to_surface -> lock_boids_to_surface:   boolean  "Constrain boids to a surface"
#+ * ID|ParticleSettings.mass -> mass:   float  "Specify the mass of the particles"
#+ * ID|ParticleSettings.material -> material:   int  "Specify material used for the particles"
#+ * ID|ParticleSettings.normal_factor -> normal_factor:   float  "Let the surface normal give the particle a starting speed"
#ID|ParticleSettings.object_align_factor -> object_align_factor:   float[3]  "Let the emitter object orientation give the particle a starting speed"
#+ * ID|ParticleSettings.object_factor -> object_factor:   float  "Let the object give the particle a starting speed"
#+ * ID|ParticleSettings.particle_factor -> particle_factor:   float  "Let the target particle give the particle a starting speed"
#+ * ID|ParticleSettings.particle_size -> particle_size:   float  "The size of the particles"
#+ * ID|ParticleSettings.path_end -> path_end:   float  "End time of drawn path"
#+ * ID|ParticleSettings.path_start -> path_start:   float  "Starting time of drawn path"
#+ * ID|ParticleSettings.phase_factor -> phase_factor:   float  "Initial rotation phase"
#ID|ParticleSettings.phase_factor_random -> phase_factor_random:   float  "Randomize rotation phase"
#+ * ID|ParticleSettings.physics_type -> physics_type:   enum  "Particle physics type"
#+ * ID|ParticleSettings.react_event -> react_event:   enum  "The event of target particles to react on"
#+ * ID|ParticleSettings.reaction_shape -> reaction_shape:   float  "Power of reaction strength dependence on distance to target"
#+ * ID|ParticleSettings.reactor_factor -> reactor_factor:   float  "Let the vector away from the target particles location give the particle a starting speed"
#+ * ID|ParticleSettings.render_step -> render_step:   int  "How many steps paths are rendered with (power of 2)"
#ID|ParticleSettings.render_type -> render_type:   enum  "How particles are rendered"
#ID|ParticleSettings.rendered_child_count -> rendered_child_count:   int  "Amount of children/parent for rendering"
#ID|ParticleSettings.rotation_factor_random -> rotation_factor_random:   float  "Randomize rotation"
#+ * ID|ParticleSettings.rotation_mode -> rotation_mode:   enum  "Particles initial rotation"
#ID|ParticleSettings.roughness_1 -> roughness_1:   float  "Amount of location dependent rough"
#ID|ParticleSettings.roughness_1_size -> roughness_1_size:   float  "Size of location dependent rough"
#ID|ParticleSettings.roughness_2 -> roughness_2:   float  "Amount of random rough"
#ID|ParticleSettings.roughness_2_size -> roughness_2_size:   float  "Size of random rough"
#ID|ParticleSettings.roughness_2_threshold -> roughness_2_threshold:   float  "Amount of particles left untouched by random rough"
#ID|ParticleSettings.roughness_end_shape -> roughness_end_shape:   float  "Shape of end point rough"
#ID|ParticleSettings.roughness_endpoint -> roughness_endpoint:   float  "Amount of end point rough"
#ID|ParticleSettings.show_health -> show_health:   boolean  "Draw boid health"
#ID|ParticleSettings.show_material_color -> show_material_color:   boolean  "Draw particles using materials diffuse color"
#ID|ParticleSettings.show_number -> show_number:   boolean  "Show particle number"
#+ * ID|ParticleSettings.show_size -> show_size:   boolean  "Show particle size"
#ID|ParticleSettings.show_unborn -> show_unborn:   boolean  "Show particles before they are emitted"
#ID|ParticleSettings.show_velocity -> show_velocity:   boolean  "Show particle velocity"
#+ * ID|ParticleSettings.simplify_rate -> simplify_rate:   float  "Speed of simplification"
#+ * ID|ParticleSettings.simplify_refsize -> simplify_refsize:   int  "Reference size in pixels, after which simplification begins"
#+ * ID|ParticleSettings.simplify_transition -> simplify_transition:   float  "Transition period for fading out strands"
#+ * ID|ParticleSettings.simplify_viewport -> simplify_viewport:   float  "Speed of Simplification"
#ID|ParticleSettings.size_random -> size_random:   float  "Give the particle size a random variation"
#+ * ID|ParticleSettings.subframes -> subframes:   int  "Subframes to simulate for improved stability and finer granularity simulations"
#+ * ID|ParticleSettings.tangent_factor -> tangent_factor:   float  "Let the surface tangent give the particle a starting speed"
#+ * ID|ParticleSettings.tangent_phase -> tangent_phase:   float  "Rotate the surface tangent"
#+ * ID|ParticleSettings.time_tweak -> time_tweak:   float  "A multiplier for physics timestep (1.0 means one frame = 1/25 seconds)"
#+ * ID|ParticleSettings.trail_count -> trail_count:   int  "Number of trail particles"
#+ * ID|ParticleSettings.type -> type:   enum  "NO DESCRIPTION"
#ID|ParticleSettings.use_absolute_path_time -> use_absolute_path_time:   boolean  "Path timing is in absolute frames"
#ID|ParticleSettings.use_animate_branching -> use_animate_branching:   boolean  "Animate branching"
#ID|ParticleSettings.use_branching -> use_branching:   boolean  "Branch child paths from each other"
#ID|ParticleSettings.use_dead -> use_dead:   boolean  "Show particles after they have died"
#ID|ParticleSettings.use_die_on_collision -> use_die_on_collision:   boolean  "Particles die when they collide with a deflector object"
#ID|ParticleSettings.use_dynamic_rotation -> use_dynamic_rotation:   boolean  "Sets rotation to dynamic/constant"
#ID|ParticleSettings.use_emit_random -> use_emit_random:   boolean  "Emit in random order of elements"
#ID|ParticleSettings.use_even_distribution -> use_even_distribution:   boolean  "Use even distribution from faces based on face areas or edge lengths"
#+ * ID|ParticleSettings.use_global_dupli -> use_global_dupli:   boolean  "Use objects global coordinates for duplication"
#+ * ID|ParticleSettings.use_group_count -> use_group_count:   boolean  "Use object multiple times in the same group"
#ID|ParticleSettings.use_group_pick_random -> use_group_pick_random:   boolean  "Pick objects from group randomly"
#ID|ParticleSettings.use_hair_bspline -> use_hair_bspline:   boolean  "Interpolate hair using B-Splines"
#ID|ParticleSettings.use_multiply_size_mass -> use_multiply_size_mass:   boolean  "Multiply mass by particle size"
#ID|ParticleSettings.use_parent_particles -> use_parent_particles:   boolean  "Render parent particles"
#ID|ParticleSettings.use_react_multiple -> use_react_multiple:   boolean  "React multiple times"
#ID|ParticleSettings.use_react_start_end -> use_react_start_end:   boolean  "Give birth to unreacted particles eventually"
#ID|ParticleSettings.use_render_adaptive -> use_render_adaptive:   boolean  "Draw steps of the particle path"
#ID|ParticleSettings.use_render_emitter -> use_render_emitter:   boolean  "Render emitter Object also"
#ID|ParticleSettings.use_self_effect -> use_self_effect:   boolean  "Particle effectors effect themselves"
#ID|ParticleSettings.use_simplify -> use_simplify:   boolean  "Remove child strands as the object becomes smaller on the screen"
#ID|ParticleSettings.use_simplify_viewport -> use_simplify_viewport:   boolean  "NO DESCRIPTION"
#ID|ParticleSettings.use_size_deflect -> use_size_deflect:   boolean  "Use particles size in deflection"
#ID|ParticleSettings.use_strand_primitive -> use_strand_primitive:   boolean  "Use the strand primitive for rendering"
#ID|ParticleSettings.use_symmetric_branching -> use_symmetric_branching:   boolean  "Start and end points are the same"
#ID|ParticleSettings.use_velocity_length -> use_velocity_length:   boolean  "Multiply line length by particle speed"
#ID|ParticleSettings.use_whole_group -> use_whole_group:   boolean  "Use whole group at once"
#+ * ID|ParticleSettings.userjit -> userjit:   int  "Emission locations / face (0 = automatic)"
#+ * ID|ParticleSettings.virtual_parents -> virtual_parents:   float  "Relative amount of virtual parents"
#+ * ID|Scene.active_keying_set_index -> active_keying_set_index:   int  "Current Keying Set index (negative for builtin and positive for absolute)"
#+ * ID|Scene.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
#ID|Scene.audio_distance_model -> audio_distance_model:   enum  "Distance model for distance attenuation calculation"
#ID|Scene.audio_doppler_factor -> audio_doppler_factor:   float  "Pitch factor for Doppler effect calculation"
#ID|Scene.audio_doppler_speed -> audio_doppler_speed:   float  "Speed of sound for Doppler effect calculation"
#ID|Scene.background_set -> background_set:   pointer  "Background set scene"
#+ * ID|Scene.camera -> camera:   pointer  "Active camera used for rendering the scene"
#+ * ID|Scene.cursor_location -> cursor_location:   float[3]  "3D cursor location"
#+ * ID|Scene.frame_current -> frame_current:   int  "NO DESCRIPTION"
#+ * ID|Scene.frame_end -> frame_end:   int  "Final frame of the playback/rendering range"
#ID|Scene.frame_preview_end -> frame_preview_end:   int  "Alternative end frame for UI playback"
#ID|Scene.frame_preview_start -> frame_preview_start:   int  "Alternative start frame for UI playback"
#+ * ID|Scene.frame_start -> frame_start:   int  "First frame of the playback/rendering range"
#+ * ID|Scene.frame_step -> frame_step:   int  "Number of frames to skip forward while rendering/playing back each frame"
#ID|Scene.game_settings -> game_settings:   pointer,  "(read-only)"
#+ * ID|Scene.gravity -> gravity:   float[3]  "Constant acceleration in a given direction"
#+ * ID|Scene.grease_pencil -> grease_pencil:   pointer  "Grease Pencil datablock"
#ID|Scene.is_nla_tweakmode -> is_nla_tweakmode:   boolean,  "(read-only)    Indicates whether there is any action referenced by NLA being edited. Strictly read-only"
#+ * ID|Scene.keying_sets -> keying_sets:   collection,  "(read-only)    Absolute Keying Sets for this Scene"
#ID|Scene.keying_sets_all -> keying_sets_all:   collection,  "(read-only)    All Keying Sets available for use (builtins and Absolute Keying Sets for this Scene)"
#+ * ID|Scene.layers -> layers:   boolean[20]  "Layers visible when rendering the scene"
#+ * ID|Scene.network_render -> network_render:   pointer,  "(read-only)    Network Render Settings"
#+ * ID|Scene.nodetree -> nodetree:   pointer,  "(read-only)    Compositing node tree"
#ID|Scene.object_bases -> object_bases:   collection,  "(read-only)"
#+ * ID|Scene.objects -> objects:   collection,  "(read-only)"
#+ * ID|Scene.orientations -> orientations:   collection,  "(read-only)"
#+ * ID|Scene.pose_templates -> pose_templates:   pointer,  "(read-only)    Pose Template Settings"
#+ * ID|Scene.render -> render:   pointer,  "(read-only)"
#+ * ID|Scene.sequence_editor -> sequence_editor:   pointer,  "(read-only)"
#+ * ID|Scene.sync_mode -> sync_mode:   enum  "How to sync playback"
#+ * ID|Scene.timeline_markers -> timeline_markers:   collection,  "(read-only)    Markers used in all timelines for the current scene"
#+ * ID|Scene.tool_settings -> tool_settings:   pointer,  "(read-only)"
#+ * ID|Scene.unit_settings -> unit_settings:   pointer,  "(read-only)    Unit editing settings"
#ID|Scene.use_audio -> use_audio:   boolean  "Play back of audio from Sequence Editor will be muted"
#ID|Scene.use_audio_scrub -> use_audio_scrub:   boolean  "Play audio from Sequence Editor while scrubbing"
#ID|Scene.use_audio_sync -> use_audio_sync:   boolean  "Play back and sync with audio clock, dropping frames if frame display is too slow"
#ID|Scene.use_frame_drop -> use_frame_drop:   boolean  "Play back dropping frames if frame display is too slow"
#+ * ID|Scene.use_gravity -> use_gravity:   boolean  "Use global gravity for all dynamics"
#+ * ID|Scene.use_nodes -> use_nodes:   boolean  "Enable the compositing node tree"
#+ * ID|Scene.use_preview_range -> use_preview_range:   boolean  "Use an alternative start/end frame for UI playback, rather than the scene start/end frame"
#ID|Scene.use_stamp_note -> use_stamp_note:   string  "User define note for the render stamping"
#+ * ID|Scene.world -> world:   pointer  "World used for rendering the scene"
#+ * ID|Screen.areas -> areas:   collection,  "(read-only)    Areas the screen is subdivided into"
#ID|Screen.is_animation_playing -> is_animation_playing:   boolean,  "(read-only)    Animation playback is active"
#+ * ID|Screen.scene -> scene:   pointer  "Active scene to be edited in the screen"
#ID|Screen.show_fullscreen -> show_fullscreen:   boolean,  "(read-only)    An area is maximised, filling this screen"
#+ * ID|Sound.filepath -> filepath:   string  "Sound sample file used by this Sound datablock"
#+ * ID|Sound.packed_file -> packed_file:   pointer,  "(read-only)"
#ID|Sound.use_memory_cache -> use_memory_cache:   boolean  "The sound file is decoded and loaded into RAM"
#+ * ID|Text.current_character -> current_character:   int,  "(read-only)    Index of current character in current line, and also start index of character in selection if one exists"
#+ * ID|Text.current_line -> current_line:   pointer,  "(read-only)    Current line, and start line of selection if one exists"
#+ * ID|Text.filepath -> filepath:   string  "Filename of the text file"
#ID|Text.is_dirty -> is_dirty:   boolean,  "(read-only)    Text file has been edited since last save"
#ID|Text.is_in_memory -> is_in_memory:   boolean,  "(read-only)    Text file is in memory, without a corresponding file on disk"
#ID|Text.is_modified -> is_modified:   boolean,  "(read-only)    Text file on disk is different than the one in memory"
#+ * ID|Text.lines -> lines:   collection,  "(read-only)    Lines of text"
#+ * ID|Text.markers -> markers:   collection,  "(read-only)    Text markers highlighting part of the text"
#ID|Text.select_end_character -> select_end_character:   int,  "(read-only)    Index of character after end of selection in the selection end line"
#ID|Text.select_end_line -> select_end_line:   pointer,  "(read-only)    End line of selection"
#+ * ID|Text.use_module -> use_module:   boolean  "Register this text as a module on loading, Text name must end with .py"
#ID|Text.use_tabs_as_spaces -> use_tabs_as_spaces:   boolean  "Automatically converts all new tabs into spaces"
#+ * ID|Texture.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
#+ * ID|Texture.color_ramp -> color_ramp:   pointer,  "(read-only)"
#+ * ID|Texture.contrast -> contrast:   float  "NO DESCRIPTION"
#+TODO MAKE COLOR * ID|Texture.factor_blue -> factor_blue:   float  "NO DESCRIPTION"
#+TODO MAKE COLOR * ID|Texture.factor_green -> factor_green:   float  "NO DESCRIPTION"
#+TODO MAKE COLOR * ID|Texture.factor_red -> factor_red:   float  "NO DESCRIPTION"
#ID|Texture.intensity -> intensity:   float  "NO DESCRIPTION"
#+ * ID|Texture.node_tree -> node_tree:   pointer,  "(read-only)    Node tree for node-based textures"
#+ * ID|Texture.saturation -> saturation:   float  "NO DESCRIPTION"
#+ * ID|Texture.type -> type:   enum  "NO DESCRIPTION"
#+ * ID|Texture.use_color_ramp -> use_color_ramp:   boolean  "Toggle color ramp operations"
#+ * ID|Texture.use_nodes -> use_nodes:   boolean  "Make this a node-based texture"
#+ * ID|Texture.use_preview_alpha -> use_preview_alpha:   boolean  "Show Alpha in Preview Render"
#+ * ID|Texture|BlendTexture.progression -> progression:   enum  "Sets the style of the color blending"
#ID|Texture|BlendTexture.use_flip_axis -> use_flip_axis:   enum  "Flips the textures X and Y axis"
#ID|Texture|CloudsTexture.cloud_type -> cloud_type:   enum  "NO DESCRIPTION"
#+ * ID|Texture|CloudsTexture.nabla -> nabla:   float  "Size of derivative offset used for calculating normal"
#+ * ID|Texture|CloudsTexture.noise_basis -> noise_basis:   enum  "Sets the noise basis used for turbulence"
#+ * ID|Texture|CloudsTexture.noise_depth -> noise_depth:   int  "Sets the depth of the cloud calculation"
#ID|Texture|CloudsTexture.noise_scale -> noise_scale:   float  "Sets scaling for noise input"
#+ * ID|Texture|CloudsTexture.noise_type -> noise_type:   enum  "NO DESCRIPTION"
#+ * ID|Texture|DistortedNoiseTexture.distortion -> distortion:   float  "NO DESCRIPTION"
#+ * ID|Texture|DistortedNoiseTexture.nabla -> nabla:   float  "Size of derivative offset used for calculating normal"
#+ * ID|Texture|DistortedNoiseTexture.noise_basis -> noise_basis:   enum  "Sets the noise basis used for turbulence"
#+ * ID|Texture|DistortedNoiseTexture.noise_distortion -> noise_distortion:   enum  "Sets the noise basis for the distortion"
#ID|Texture|DistortedNoiseTexture.noise_scale -> noise_scale:   float  "Sets scaling for noise input"
#+ * ID|Texture|EnvironmentMapTexture.environment_map -> environment_map:   pointer,  "(read-only)    Gets the environment map associated with this texture"
#+ * ID|Texture|EnvironmentMapTexture.filter_eccentricity -> filter_eccentricity:   int  "Maximum eccentricity. Higher gives less blur at distant/oblique angles, but is also slower"
#+ * ID|Texture|EnvironmentMapTexture.filter_probes -> filter_probes:   int  "Maximum number of samples. Higher gives less blur at distant/oblique angles, but is also slower"
#+ * ID|Texture|EnvironmentMapTexture.filter_size -> filter_size:   float  "Multiplies the filter size used by MIP Map and Interpolation"
#ID|Texture|EnvironmentMapTexture.filter_type -> filter_type:   enum  "Texture filter to use for sampling image"
#+ * ID|Texture|EnvironmentMapTexture.image -> image:   pointer  "Source image file to read the environment map from"
#+ * ID|Texture|EnvironmentMapTexture.image_user -> image_user:   pointer,  "(read-only)    Parameters defining which layer, pass and frame of the image is displayed"
#ID|Texture|EnvironmentMapTexture.use_filter_size_min -> use_filter_size_min:   boolean  "Use Filter Size as a minimal filter value in pixels"
#ID|Texture|EnvironmentMapTexture.use_mipmap -> use_mipmap:   boolean  "Uses auto-generated MIP maps for the image"
#ID|Texture|EnvironmentMapTexture.use_mipmap_gauss -> use_mipmap_gauss:   boolean  "Uses Gauss filter to sample down MIP maps"
#+ * ID|Texture|ImageTexture.checker_distance -> checker_distance:   float  "Sets distance between checker tiles"
#+ * ID|Texture|ImageTexture.crop_max_x -> crop_max_x:   float  "Sets maximum X value to crop the image"
#+ * ID|Texture|ImageTexture.crop_max_y -> crop_max_y:   float  "Sets maximum Y value to crop the image"
#+ * ID|Texture|ImageTexture.crop_min_x -> crop_min_x:   float  "Sets minimum X value to crop the image"
#+ * ID|Texture|ImageTexture.crop_min_y -> crop_min_y:   float  "Sets minimum Y value to crop the image"
#+ * ID|Texture|ImageTexture.extension -> extension:   enum  "Sets how the image is extrapolated past its original bounds"
#+ * ID|Texture|ImageTexture.filter_eccentricity -> filter_eccentricity:   int  "Maximum eccentricity. Higher gives less blur at distant/oblique angles, but is also slower"
#+ * ID|Texture|ImageTexture.filter_probes -> filter_probes:   int  "Maximum number of samples. Higher gives less blur at distant/oblique angles, but is also slower"
#+ * ID|Texture|ImageTexture.filter_size -> filter_size:   float  "Multiplies the filter size used by MIP Map and Interpolation"
#ID|Texture|ImageTexture.filter_type -> filter_type:   enum  "Texture filter to use for sampling image"
#+ * ID|Texture|ImageTexture.image -> image:   pointer  "NO DESCRIPTION"
#+ * ID|Texture|ImageTexture.image_user -> image_user:   pointer,  "(read-only)    Parameters defining which layer, pass and frame of the image is displayed"
#+ * ID|Texture|ImageTexture.invert_alpha -> invert_alpha:   boolean  "Inverts all the alpha values in the image"
#+ * ID|Texture|ImageTexture.normal_space -> normal_space:   enum  "Sets space of normal map image"
#+ * ID|Texture|ImageTexture.repeat_x -> repeat_x:   int  "Sets a repetition multiplier in the X direction"
#+ * ID|Texture|ImageTexture.repeat_y -> repeat_y:   int  "Sets a repetition multiplier in the Y direction"
#+ * ID|Texture|ImageTexture.use_alpha -> use_alpha:   boolean  "Uses the alpha channel information in the image"
#ID|Texture|ImageTexture.use_calculate_alpha -> use_calculate_alpha:   boolean  "Calculates an alpha channel based on RGB values in the image"
#ID|Texture|ImageTexture.use_checker_even -> use_checker_even:   boolean  "Sets even checker tiles"
#ID|Texture|ImageTexture.use_checker_odd -> use_checker_odd:   boolean  "Sets odd checker tiles"
#ID|Texture|ImageTexture.use_filter_size_min -> use_filter_size_min:   boolean  "Use Filter Size as a minimal filter value in pixels"
#ID|Texture|ImageTexture.use_flip_axis -> use_flip_axis:   boolean  "Flips the textures X and Y axis"
#ID|Texture|ImageTexture.use_interpolation -> use_interpolation:   boolean  "Interpolates pixels using Area filter"
#ID|Texture|ImageTexture.use_mipmap -> use_mipmap:   boolean  "Uses auto-generated MIP maps for the image"
#ID|Texture|ImageTexture.use_mipmap_gauss -> use_mipmap_gauss:   boolean  "Uses Gauss filter to sample down MIP maps"
#ID|Texture|ImageTexture.use_mirror_x -> use_mirror_x:   boolean  "Mirrors the image repetition on the X direction"
#ID|Texture|ImageTexture.use_mirror_y -> use_mirror_y:   boolean  "Mirrors the image repetition on the Y direction"
#ID|Texture|ImageTexture.use_normal_map -> use_normal_map:   boolean  "Uses image RGB values for normal mapping"
#+ * ID|Texture|MagicTexture.noise_depth -> noise_depth:   int  "Sets the depth of the cloud calculation"
#+ * ID|Texture|MagicTexture.turbulence -> turbulence:   float  "Sets the turbulence of the bandnoise and ringnoise types"
#ID|Texture|MarbleTexture.marble_type -> marble_type:   enum  "NO DESCRIPTION"
#+ * ID|Texture|MarbleTexture.nabla -> nabla:   float  "Size of derivative offset used for calculating normal"
#+ * ID|Texture|MarbleTexture.noise_basis -> noise_basis:   enum  "Sets the noise basis used for turbulence"
#+ * ID|Texture|MarbleTexture.noise_depth -> noise_depth:   int  "Sets the depth of the cloud calculation"
#ID|Texture|MarbleTexture.noise_scale -> noise_scale:   float  "Sets scaling for noise input"
#+ * ID|Texture|MarbleTexture.noise_type -> noise_type:   enum  "NO DESCRIPTION"
#ID|Texture|MarbleTexture.noisebasis_2 -> noisebasis_2:   enum  "NO DESCRIPTION"
#+ * ID|Texture|MarbleTexture.turbulence -> turbulence:   float  "Sets the turbulence of the bandnoise and ringnoise types"
#ID|Texture|MusgraveTexture.dimension_max -> dimension_max:   float  "Highest fractal dimension"
#+ * ID|Texture|MusgraveTexture.gain -> gain:   float  "The gain multiplier"
#+ * ID|Texture|MusgraveTexture.lacunarity -> lacunarity:   float  "Gap between successive frequencies"
#+ * ID|Texture|MusgraveTexture.musgrave_type -> musgrave_type:   enum  "NO DESCRIPTION"
#+ * ID|Texture|MusgraveTexture.nabla -> nabla:   float  "Size of derivative offset used for calculating normal"
#+ * ID|Texture|MusgraveTexture.noise_basis -> noise_basis:   enum  "Sets the noise basis used for turbulence"
#+ * ID|Texture|MusgraveTexture.noise_intensity -> noise_intensity:   float  "NO DESCRIPTION"
#ID|Texture|MusgraveTexture.noise_scale -> noise_scale:   float  "Sets scaling for noise input"
#+ * ID|Texture|MusgraveTexture.octaves -> octaves:   float  "Number of frequencies used"
#+ * ID|Texture|MusgraveTexture.offset -> offset:   float  "The fractal offset"
#ID|Texture|PointDensityTexture.point_density -> point_density:   pointer,  "(read-only)    The point density settings associated with this texture"
#+ * ID|Texture|StucciTexture.noise_basis -> noise_basis:   enum  "Sets the noise basis used for turbulence"
#ID|Texture|StucciTexture.noise_scale -> noise_scale:   float  "Sets scaling for noise input"
#+ * ID|Texture|StucciTexture.noise_type -> noise_type:   enum  "NO DESCRIPTION"
#ID|Texture|StucciTexture.stucci_type -> stucci_type:   enum  "NO DESCRIPTION"
#+ * ID|Texture|StucciTexture.turbulence -> turbulence:   float  "Sets the turbulence of the bandnoise and ringnoise types"
#ID|Texture|VoronoiTexture.color_mode -> color_mode:   enum  "NO DESCRIPTION"
#+ * ID|Texture|VoronoiTexture.distance_metric -> distance_metric:   enum  "NO DESCRIPTION"
#+ * ID|Texture|VoronoiTexture.minkovsky_exponent -> minkovsky_exponent:   float  "Minkovsky exponent"
#+ * ID|Texture|VoronoiTexture.nabla -> nabla:   float  "Size of derivative offset used for calculating normal"
#+ * ID|Texture|VoronoiTexture.noise_intensity -> noise_intensity:   float  "NO DESCRIPTION"
#ID|Texture|VoronoiTexture.noise_scale -> noise_scale:   float  "Sets scaling for noise input"
#+ * ID|Texture|VoronoiTexture.weight_1 -> weight_1:   float  "Voronoi feature weight 1"
#+ * ID|Texture|VoronoiTexture.weight_2 -> weight_2:   float  "Voronoi feature weight 2"
#+ * ID|Texture|VoronoiTexture.weight_3 -> weight_3:   float  "Voronoi feature weight 3"
#+ * ID|Texture|VoronoiTexture.weight_4 -> weight_4:   float  "Voronoi feature weight 4"
#+ * ID|Texture|VoxelDataTexture.image -> image:   pointer  "NO DESCRIPTION"
#+ * ID|Texture|VoxelDataTexture.image_user -> image_user:   pointer,  "(read-only)    Parameters defining which layer, pass and frame of the image is displayed"
#ID|Texture|VoxelDataTexture.voxel_data -> voxel_data:   pointer,  "(read-only)    The voxel data associated with this texture"
#+ * ID|Texture|WoodTexture.nabla -> nabla:   float  "Size of derivative offset used for calculating normal"
#+ * ID|Texture|WoodTexture.noise_basis -> noise_basis:   enum  "Sets the noise basis used for turbulence"
#ID|Texture|WoodTexture.noise_scale -> noise_scale:   float  "Sets scaling for noise input"
#+ * ID|Texture|WoodTexture.noise_type -> noise_type:   enum  "NO DESCRIPTION"
#ID|Texture|WoodTexture.noisebasis_2 -> noisebasis_2:   enum  "NO DESCRIPTION"
#+ * ID|Texture|WoodTexture.turbulence -> turbulence:   float  "Sets the turbulence of the bandnoise and ringnoise types"
#ID|Texture|WoodTexture.wood_type -> wood_type:   enum  "NO DESCRIPTION"
#+ * ID|VectorFont.filepath -> filepath:   string,  "(read-only)"
#+ * ID|VectorFont.packed_file -> packed_file:   pointer,  "(read-only)"
#+ * ID|WindowManager.keyconfigs -> keyconfigs:   collection,  "(read-only)    Registered key configurations"
#+ * ID|WindowManager.operators -> operators:   collection,  "(read-only)    Operator registry"
#+ * ID|WindowManager.windows -> windows:   collection,  "(read-only)    Open windows"
#+ * ID|World.active_texture -> active_texture:   pointer  "Active texture slot being displayed"
#+ * ID|World.active_texture_index -> active_texture_index:   int  "Index of active texture slot"
#+ * ID|World.ambient_color -> ambient_color:   float[3]  "NO DESCRIPTION"
#+ * ID|World.animation_data -> animation_data:   pointer,  "(read-only)    Animation data for this datablock"
#ID|World.color_range -> color_range:   float  "The color range that will be mapped to 0-1"
#+ * ID|World.exposure -> exposure:   float  "Amount of exponential color correction for light"
#+ * ID|World.horizon_color -> horizon_color:   float[3]  "Color at the horizon"
#ID|World.light_settings -> light_settings:   pointer,  "(read-only)    World lighting settings"
#ID|World.mist_settings -> mist_settings:   pointer,  "(read-only)    World mist settings"
#ID|World.star_settings -> star_settings:   pointer,  "(read-only)    World stars settings"
#+ * ID|World.texture_slots -> texture_slots:   collection,  "(read-only)    Texture slots defining the mapping and influence of textures"
#ID|World.use_sky_blend -> use_sky_blend:   boolean  "Render background with natural progression from horizon to zenith"
#ID|World.use_sky_paper -> use_sky_paper:   boolean  "Flatten blend or texture coordinates"
#ID|World.use_sky_real -> use_sky_real:   boolean  "Render background with a real horizon, relative to the camera angle"
#+ * ID|World.zenith_color -> zenith_color:   float[3]  "Color at the zenith"
#+ * IKParam.ik_solver -> ik_solver:   enum,  "(read-only)    IK solver for which these parameters are defined, 0 for Legacy, 1 for iTaSC"
#IKParam|Itasc.damping_epsilon -> damping_epsilon:   float  "Singular value under which damping is progressively applied. Higher values=more stability, less reactivity. Default=0.1"
#IKParam|Itasc.damping_max -> damping_max:   float  "Maximum damping coefficient when singular value is nearly 0. Higher values=more stability, less reactivity. Default=0.5"
#+ * IKParam|Itasc.feedback -> feedback:   float  "Feedback coefficient for error correction. Average response time=1/feedback. Default=20"
#IKParam|Itasc.iterations -> iterations:   int  "Maximum number of iterations for convergence in case of reiteration"
#+ * IKParam|Itasc.mode -> mode:   enum  "NO DESCRIPTION"
#+ * IKParam|Itasc.precision -> precision:   float  "Precision of convergence in case of reiteration"
#IKParam|Itasc.reiteration_method -> reiteration_method:   enum  "Defines if the solver is allowed to reiterate (converges until precision is met) on none, first or all frames"
#+ * IKParam|Itasc.solver -> solver:   enum  "Solving method selection: Automatic damping or manual damping"
#IKParam|Itasc.step_count -> step_count:   int  "Divides the frame interval into this many steps"
#IKParam|Itasc.step_max -> step_max:   float  "Higher bound for timestep in second in case of automatic substeps"
#IKParam|Itasc.step_min -> step_min:   float  "Lower bound for timestep in second in case of automatic substeps"
#IKParam|Itasc.use_auto_step -> use_auto_step:   boolean  "Automatically determine the optimal number of steps for best performance/accuracy trade off"
#IKParam|Itasc.velocity_max -> velocity_max:   float  "Maximum joint velocity in rad/s. Default=50"
#+ * ImageUser.fields_per_frame -> fields_per_frame:   int  "The number of fields per rendered frame (2 fields is 1 image)"
#ImageUser.frame_duration -> frame_duration:   int  "Sets the number of images of a movie to use"
#ImageUser.frame_offset -> frame_offset:   int  "Offsets the number of the frame to use in the animation"
#+ * ImageUser.frame_start -> frame_start:   int  "Sets the global starting frame of the movie"
#+ * ImageUser.multilayer_layer -> multilayer_layer:   int,  "(read-only)    Layer in multilayer image"
#+ * ImageUser.multilayer_pass -> multilayer_pass:   int,  "(read-only)    Pass in multilayer image"
#ImageUser.use_auto_refresh -> use_auto_refresh:   boolean  "Always refresh image on frame changes"
#ImageUser.use_cyclic -> use_cyclic:   boolean  "Cycle the images in the movie"
#KeyConfig.is_user_defined -> is_user_defined:   boolean,  "(read-only)    Indicates that a keyconfig was defined by the user"
#+ * KeyConfig.keymaps -> keymaps:   collection,  "(read-only)    Key maps configured as part of this configuration"
#+ * KeyConfig.name -> name:   string  "Name of the key configuration"
#KeyConfigurations.active -> active:   pointer  "Active wm KeyConfig"
#KeyConfigurations.default -> default:   pointer,  "(read-only)"
#KeyMap.is_modal -> is_modal:   boolean,  "(read-only)    Indicates that a keymap is used for translate modal events for an operator"
#KeyMap.is_user_defined -> is_user_defined:   boolean  "Keymap is defined by the user"
#+ * KeyMap.items -> items:   collection,  "(read-only)    Items in the keymap, linking an operator to an input event"
#+ * KeyMap.name -> name:   string,  "(read-only)    Name of the key map"
#+ * KeyMap.region_type -> region_type:   enum,  "(read-only)    Optional region type keymap is associated with"
#KeyMap.show_expanded_children -> show_expanded_children:   boolean  "Children expanded in the user interface"
#KeyMap.show_expanded_items -> show_expanded_items:   boolean  "Expanded in the user interface"
#+ * KeyMap.space_type -> space_type:   enum,  "(read-only)    Optional space type keymap is associated with"
#TODO MOVE TO COLLECTION * KeyMapItem.active -> active:   boolean  "Activate or deactivate item"
#+ * KeyMapItem.id -> id:   int,  "(read-only)    ID of the item"
#+ * KeyMapItem.idname -> idname:   string  "Identifier of operator to call on input event"
#+ * KeyMapItem.key_modifier -> key_modifier:   enum  "Regular key pressed as a modifier"
#+ * KeyMapItem.map_type -> map_type:   enum  "Type of event mapping"
#+ * KeyMapItem.name -> name:   string,  "(read-only)    Name of operator to call on input event"
 + * KeyMapItem.alt -> pressed_alt:   boolean  "Alt key pressed"
 + * KeyMapItem.any -> pressed_any:   boolean  "Any modifier keys pressed"
 + * KeyMapItem.ctrl -> pressed_ctrl:   boolean  "Control key pressed"
 + * KeyMapItem.oskey -> pressed_oskey:   boolean  "Operating system key pressed"
 + * KeyMapItem.shift -> pressed_shift:   boolean  "Shift key pressed"
#+ * KeyMapItem.properties -> properties:   pointer,  "(read-only)    Properties to set when the operator is called"
#TODO * KeyMapItem.propvalue -> propvalue:   enum  "The value this event translates to in a modal keymap"
#KeyMapItem.show_expanded -> show_expanded:   boolean  "Show key map event and property details in the user interface"
#+ * KeyMapItem.type -> type:   enum  "Type of event"
#+ * KeyMapItem.value -> value:   enum  "NO DESCRIPTION"
#+ * Keyframe.co -> co:   float[2]  "Coordinates of the control point"
#Keyframe.handle_left -> handle_left:   float[2]  "Coordinates of the first handle"
#Keyframe.handle_left_type -> handle_left_type:   enum  "Handle types"
#Keyframe.handle_right -> handle_right:   float[2]  "Coordinates of the second handle"
#Keyframe.handle_right_type -> handle_right_type:   enum  "Handle types"
#+ * Keyframe.interpolation -> interpolation:   enum  "Interpolation method to use for segment of the curve from this Keyframe until the next Keyframe"
#+ * Keyframe.select_control_point -> select_control_point:   boolean  "Control point selection status"
#+ * Keyframe.select_left_handle -> select_left_handle:   boolean  "Handle 1 selection status"
#+ * Keyframe.select_right_handle -> select_right_handle:   boolean  "Handle 2 selection status"
#+ * Keyframe.type -> type:   enum  "The type of keyframe"
#+ * KeyingSet.active_path_index -> active_path_index:   int  "Current Keying Set index"
#KeyingSet.is_path_absolute -> is_path_absolute:   boolean,  "(read-only)    Keying Set defines specific paths/settings to be keyframed (i.e. is not reliant on context info)"
#+ * KeyingSet.name -> name:   string  "NO DESCRIPTION"
#+ * KeyingSet.paths -> paths:   collection,  "(read-only)    Keying Set Paths to define settings that get keyframed together"
#+ * KeyingSet.type_info -> type_info:   pointer,  "(read-only)    Callback function defines for built-in Keying Sets"
#KeyingSet.use_insertkey_needed -> use_insertkey_needed:   boolean  "Only insert keyframes where theyre needed in the relevant F-Curves"
#KeyingSet.use_insertkey_visual -> use_insertkey_visual:   boolean  "Insert keyframes based on visual transforms"
#KeyingSet.use_insertkey_xyz_to_rgb -> use_insertkey_xyz_to_rgb:   boolean  "Color for newly added transformation F-Curves (Location, Rotation, Scale) and also Color is based on the transform axis"
#+ * KeyingSetInfo.bl_idname -> bl_idname:   string  "NO DESCRIPTION"
#+ * KeyingSetInfo.bl_label -> bl_label:   string  "NO DESCRIPTION"
#KeyingSetInfo.use_insertkey_needed -> use_insertkey_needed:   boolean  "Only insert keyframes where theyre needed in the relevant F-Curves"
#KeyingSetInfo.use_insertkey_visual -> use_insertkey_visual:   boolean  "Insert keyframes based on visual transforms"
#KeyingSetInfo.use_insertkey_xyz_to_rgb -> use_insertkey_xyz_to_rgb:   boolean  "Color for newly added transformation F-Curves (Location, Rotation, Scale) and also Color is based on the transform axis"
#+ * KeyingSetPath.array_index -> array_index:   int  "Index to the specific setting if applicable"
#+ * KeyingSetPath.data_path -> data_path:   string  "Path to property setting"
#+ * KeyingSetPath.group -> group:   string  "Name of Action Group to assign setting(s) for this path to"
#KeyingSetPath.group_method -> group_method:   enum  "Method used to define which Group-name to use"
#+ * KeyingSetPath.id -> id:   pointer  "ID-Block that keyframes for Keying Set should be added to (for Absolute Keying Sets only)"
#+ * KeyingSetPath.id_type -> id_type:   enum  "Type of ID-block that can be used"
#KeyingSetPath.use_entire_array -> use_entire_array:   boolean  "When an array/vector type is chosen (Location, Rotation, Color, etc.), entire array is to be used"
#KeyingSetPath.use_insertkey_needed -> use_insertkey_needed:   boolean  "Only insert keyframes where theyre needed in the relevant F-Curves"
#KeyingSetPath.use_insertkey_visual -> use_insertkey_visual:   boolean  "Insert keyframes based on visual transforms"
#KeyingSetPath.use_insertkey_xyz_to_rgb -> use_insertkey_xyz_to_rgb:   boolean  "Color for newly added transformation F-Curves (Location, Rotation, Scale) and also Color is based on the transform axis"
#KeyingSetPaths.active -> active:   pointer  "Active Keying Set used to insert/delete keyframes"
#KeyingSets.active -> active:   pointer  "Active Keying Set used to insert/delete keyframes"
#+ * LampSkySettings.atmosphere_distance_factor -> atmosphere_distance_factor:   float  "Multiplier to convert blender units to physical distance"
#+ * LampSkySettings.atmosphere_extinction -> atmosphere_extinction:   float  "Extinction scattering contribution factor"
#+ * LampSkySettings.atmosphere_inscattering -> atmosphere_inscattering:   float  "Scatter contribution factor"
#+ * LampSkySettings.atmosphere_turbidity -> atmosphere_turbidity:   float  "Sky turbidity"
#+ * LampSkySettings.backscattered_light -> backscattered_light:   float  "Backscattered light"
#+ * LampSkySettings.horizon_brightness -> horizon_brightness:   float  "Horizon brightness"
#+ * LampSkySettings.sky_blend -> sky_blend:   float  "Blend factor with sky"
#+ * LampSkySettings.sky_blend_type -> sky_blend_type:   enum  "Blend mode for combining sun sky with world sky"
#+ * LampSkySettings.sky_color_space -> sky_color_space:   enum  "Color space to use for internal XYZ->RGB color conversion"
#+ * LampSkySettings.sky_exposure -> sky_exposure:   float  "Strength of sky shading exponential exposure correction"
#+ * LampSkySettings.spread -> spread:   float  "Horizon Spread"
#+ * LampSkySettings.sun_brightness -> sun_brightness:   float  "Sun brightness"
#+ * LampSkySettings.sun_intensity -> sun_intensity:   float  "Sun intensity"
#+ * LampSkySettings.sun_size -> sun_size:   float  "Sun size"
#+ * LampSkySettings.use_atmosphere -> use_atmosphere:   boolean  "Apply sun effect on atmosphere"
#+ * LampSkySettings.use_sky -> use_sky:   boolean  "Apply sun effect on sky"
#+ * LatticePoint.co -> co:   float[3],  "(read-only)"
#LatticePoint.co_deform -> co_deform:   float[3]  "NO DESCRIPTION"
#+ * LatticePoint.groups -> groups:   collection,  "(read-only)    Weights for the vertex groups this point is member of"
#+ * Macro.bl_description -> bl_description:   string  "NO DESCRIPTION"
#+ * Macro.bl_idname -> bl_idname:   string  "NO DESCRIPTION"
#+ * Macro.bl_label -> bl_label:   string  "NO DESCRIPTION"
#+ * Macro.bl_options -> bl_options:   enum  "Options for this operator type"
#+ * Macro.name -> name:   string,  "(read-only)"
#+ * Macro.properties -> properties:   pointer,  "(read-only)"
#+ * Main.actions -> actions:   collection,  "(read-only)    Action datablocks."
#+ * Main.armatures -> armatures:   collection,  "(read-only)    Armature datablocks."
#+ * Main.brushes -> brushes:   collection,  "(read-only)    Brush datablocks."
#+ * Main.cameras -> cameras:   collection,  "(read-only)    Camera datablocks."
#+ * Main.curves -> curves:   collection,  "(read-only)    Curve datablocks."
#+ * Main.filepath -> filepath:   string,  "(read-only)    Path to the .blend file"
#+ * Main.fonts -> fonts:   collection,  "(read-only)    Vector font datablocks."
#Main.grease_pencil -> grease_pencil:   collection,  "(read-only)    Grease Pencil datablocks."
#+ * Main.groups -> groups:   collection,  "(read-only)    Group datablocks."
#+ * Main.images -> images:   collection,  "(read-only)    Image datablocks."
#Main.is_dirty -> is_dirty:   boolean,  "(read-only)    Has the current session been saved to disk as a .blend file"
#+ * Main.lamps -> lamps:   collection,  "(read-only)    Lamp datablocks."
#+ * Main.lattices -> lattices:   collection,  "(read-only)    Lattice datablocks."
#+ * Main.libraries -> libraries:   collection,  "(read-only)    Library datablocks."
#+ * Main.materials -> materials:   collection,  "(read-only)    Material datablocks."
#+ * Main.meshes -> meshes:   collection,  "(read-only)    Mesh datablocks."
#+ * Main.metaballs -> metaballs:   collection,  "(read-only)    Metaball datablocks."
#+ * Main.node_groups -> node_groups:   collection,  "(read-only)    Node group datablocks."
#+ * Main.objects -> objects:   collection,  "(read-only)    Object datablocks."
#+ * Main.particles -> particles:   collection,  "(read-only)    Particle datablocks."
#+ * Main.scenes -> scenes:   collection,  "(read-only)    Scene datablocks."
#+ * Main.screens -> screens:   collection,  "(read-only)    Screen datablocks."
#+ * Main.scripts -> scripts:   collection,  "(read-only)    Script datablocks (DEPRECATED)."
 + * Main.debug -> show_debug:   boolean  "Print debugging information in console"
#+ * Main.sounds -> sounds:   collection,  "(read-only)    Sound datablocks."
#+ * Main.texts -> texts:   collection,  "(read-only)    Text datablocks."
#+ * Main.textures -> textures:   collection,  "(read-only)    Texture datablocks."
#+ * Main.window_managers -> window_managers:   collection,  "(read-only)    Window manager datablocks."
#+ * Main.worlds -> worlds:   collection,  "(read-only)    World datablocks."
#+ * MaterialHalo.add -> add:   float  "Sets the strength of the add effect"
#+ * MaterialHalo.flare_boost -> flare_boost:   float  "Gives the flare extra strength"
#+ * MaterialHalo.flare_seed -> flare_seed:   int  "Specifies an offset in the flare seed table"
#+ * MaterialHalo.flare_size -> flare_size:   float  "Sets the factor by which the flare is larger than the halo"
#MaterialHalo.flare_subflare_count -> flare_subflare_count:   int  "Sets the number of subflares"
#MaterialHalo.flare_subflare_size -> flare_subflare_size:   float  "Sets the dimension of the subflares, dots and circles"
#+ * MaterialHalo.hardness -> hardness:   int  "Sets the hardness of the halo"
#MaterialHalo.line_count -> line_count:   int  "Sets the number of star shaped lines rendered over the halo"
#MaterialHalo.ring_count -> ring_count:   int  "Sets the number of rings rendered over the halo"
#+ * MaterialHalo.seed -> seed:   int  "Randomizes ring dimension and line location"
#+ * MaterialHalo.size -> size:   float  "Sets the dimension of the halo"
#MaterialHalo.star_tip_count -> star_tip_count:   int  "Sets the number of points on the star shaped halo"
#MaterialHalo.use_extreme_alpha -> use_extreme_alpha:   boolean  "Uses extreme alpha"
#MaterialHalo.use_flare_mode -> use_flare_mode:   boolean  "Renders halo as a lensflare"
#MaterialHalo.use_lines -> use_lines:   boolean  "Renders star shaped lines over halo"
#MaterialHalo.use_ring -> use_ring:   boolean  "Renders rings over halo"
#MaterialHalo.use_shaded -> use_shaded:   boolean  "Lets halo receive light and shadows from external objects"
#MaterialHalo.use_soft -> use_soft:   boolean  "Softens the edges of halos at intersections with other geometry"
#MaterialHalo.use_star -> use_star:   boolean  "Renders halo as a star"
#MaterialHalo.use_texture -> use_texture:   boolean  "Gives halo a texture"
#MaterialHalo.use_vertex_normal -> use_vertex_normal:   boolean  "Uses the vertex normal to specify the dimension of the halo"
#MaterialPhysics.damping -> damping:   float  "Damping of the spring force, when inside the physics distance area"
#+ * MaterialPhysics.distance -> distance:   float  "Distance of the physics area"
#+ * MaterialPhysics.elasticity -> elasticity:   float  "Elasticity of collisions"
#+ * MaterialPhysics.force -> force:   float  "Upward spring force, when inside the physics distance area"
#+ * MaterialPhysics.friction -> friction:   float  "Coulomb friction coefficient, when inside the physics distance area"
#MaterialPhysics.use_normal_align -> use_normal_align:   boolean  "Align dynamic game objects along the surface normal, when inside the physics distance area"
#+ * MaterialRaytraceMirror.depth -> depth:   int  "Maximum allowed number of light inter-reflections"
#+ * MaterialRaytraceMirror.distance -> distance:   float  "Maximum distance of reflected rays. Reflections further than this range fade to sky color or material color"
#+ * MaterialRaytraceMirror.fade_to -> fade_to:   enum  "The color that rays with no intersection within the Max Distance take. Material color can be best for indoor scenes, sky color for outdoor"
#+ * MaterialRaytraceMirror.fresnel -> fresnel:   float  "Power of Fresnel for mirror reflection"
#+ * MaterialRaytraceMirror.fresnel_factor -> fresnel_factor:   float  "Blending factor for Fresnel"
#+ * MaterialRaytraceMirror.gloss_anisotropic -> gloss_anisotropic:   float  "The shape of the reflection, from 0.0 (circular) to 1.0 (fully stretched along the tangent"
#+ * MaterialRaytraceMirror.gloss_factor -> gloss_factor:   float  "The shininess of the reflection. Values < 1.0 give diffuse, blurry reflections"
#+ * MaterialRaytraceMirror.gloss_samples -> gloss_samples:   int  "Number of cone samples averaged for blurry reflections"
#+ * MaterialRaytraceMirror.gloss_threshold -> gloss_threshold:   float  "Threshold for adaptive sampling. If a sample contributes less than this amount (as a percentage), sampling is stopped"
#+ * MaterialRaytraceMirror.reflect_factor -> reflect_factor:   float  "Sets the amount mirror reflection for raytrace"
#+ * MaterialRaytraceMirror.use -> use:   boolean  "Enable raytraced reflections"
#+ * MaterialRaytraceTransparency.depth -> depth:   int  "Maximum allowed number of light inter-refractions"
#MaterialRaytraceTransparency.depth_max -> depth_max:   float  "Maximum depth for light to travel through the transparent material before becoming fully filtered (0.0 is disabled)"
#+ * MaterialRaytraceTransparency.falloff -> falloff:   float  "Falloff power for transmissivity filter effect (1.0 is linear)"
#+ * MaterialRaytraceTransparency.filter -> filter:   float  "Amount to blend in the materials diffuse color in raytraced transparency (simulating absorption)"
#+ * MaterialRaytraceTransparency.fresnel -> fresnel:   float  "Power of Fresnel for transparency (Ray or ZTransp)"
#+ * MaterialRaytraceTransparency.fresnel_factor -> fresnel_factor:   float  "Blending factor for Fresnel"
#+ * MaterialRaytraceTransparency.gloss_factor -> gloss_factor:   float  "The clarity of the refraction. Values < 1.0 give diffuse, blurry refractions"
#+ * MaterialRaytraceTransparency.gloss_samples -> gloss_samples:   int  "Number of cone samples averaged for blurry refractions"
#+ * MaterialRaytraceTransparency.gloss_threshold -> gloss_threshold:   float  "Threshold for adaptive sampling. If a sample contributes less than this amount (as a percentage), sampling is stopped"
#+ * MaterialRaytraceTransparency.ior -> ior:   float  "Sets angular index of refraction for raytraced refraction"
#+ * MaterialSlot.link -> link:   enum  "Link material to object or the objects data"
#+ * MaterialSlot.material -> material:   pointer  "Material datablock used by this material slot"
#+ * MaterialSlot.name -> name:   string,  "(read-only)    Material slot name"
#+ * MaterialStrand.blend_distance -> blend_distance:   float  "Worldspace distance over which to blend in the surface normal"
#+ * MaterialStrand.root_size -> root_size:   float  "Start size of strands in pixels or Blender units"
#+ * MaterialStrand.shape -> shape:   float  "Positive values make strands rounder, negative makes strands spiky"
#MaterialStrand.size_min -> size_min:   float  "Minimum size of strands in pixels"
#+ * MaterialStrand.tip_size -> tip_size:   float  "End size of strands in pixels or Blender units"
#MaterialStrand.use_blender_units -> use_blender_units:   boolean  "Use Blender units for widths instead of pixels"
#MaterialStrand.use_surface_diffuse -> use_surface_diffuse:   boolean  "Make diffuse shading more similar to shading the surface"
#MaterialStrand.use_tangent_shading -> use_tangent_shading:   boolean  "Uses direction of strands as normal for tangent-shading"
#+ * MaterialStrand.uv_layer -> uv_layer:   string  "Name of UV layer to override"
#+ * MaterialStrand.width_fade -> width_fade:   float  "Transparency along the width of the strand"
#+ * MaterialSubsurfaceScattering.back -> back:   float  "Back scattering weight"
#+ * MaterialSubsurfaceScattering.color -> color:   float[3]  "Scattering color"
#+ * MaterialSubsurfaceScattering.color_factor -> color_factor:   float  "Blend factor for SSS colors"
#MaterialSubsurfaceScattering.error_threshold -> error_threshold:   float  "Error tolerance (low values are slower and higher quality)"
#+ * MaterialSubsurfaceScattering.front -> front:   float  "Front scattering weight"
#+ * MaterialSubsurfaceScattering.ior -> ior:   float  "Index of refraction (higher values are denser)"
#+ * MaterialSubsurfaceScattering.radius -> radius:   float[3]  "Mean red/green/blue scattering path length"
#+ * MaterialSubsurfaceScattering.scale -> scale:   float  "Object scale factor"
#+ * MaterialSubsurfaceScattering.texture_factor -> texture_factor:   float  "Texture scatting blend factor"
#+ * MaterialSubsurfaceScattering.use -> use:   boolean  "Enable diffuse subsurface scatting effects in a material"
#+ * MaterialVolume.asymmetry -> asymmetry:   float  "Back scattering (-1.0) to Forward scattering (1.0) and the range in between"
#+ * MaterialVolume.cache_resolution -> cache_resolution:   int  "Resolution of the voxel grid, low resolutions are faster, high resolutions use more memory"
#+ * MaterialVolume.density -> density:   float  "The base density of the volume"
#+ * MaterialVolume.density_scale -> density_scale:   float  "Multiplier for the materials density"
#MaterialVolume.depth_threshold -> depth_threshold:   float  "Stop ray marching early if transmission drops below this luminance - higher values give speedups in dense volumes at the expense of accuracy"
#+ * MaterialVolume.emission -> emission:   float  "Amount of light that gets emitted by the volume"
#+ * MaterialVolume.emission_color -> emission_color:   float[3]  "NO DESCRIPTION"
#MaterialVolume.light_method -> light_method:   enum  "Method of shading, attenuating, and scattering light through the volume"
#+ * MaterialVolume.ms_diffusion -> ms_diffusion:   float  "Diffusion factor, the strength of the blurring effect"
#+ * MaterialVolume.ms_intensity -> ms_intensity:   float  "Multiplier for multiple scattered light energy"
#+ * MaterialVolume.ms_spread -> ms_spread:   float  "Proportional distance over which the light is diffused"
#+ * MaterialVolume.reflection -> reflection:   float  "Multiplier to make out-scattered light brighter or darker (non-physically correct)"
#+ * MaterialVolume.reflection_color -> reflection_color:   float[3]  "Colour of light scattered out of the volume (does not affect transmission)"
#+ * MaterialVolume.scattering -> scattering:   float  "Amount of light that gets scattered out by the volume - the more out-scattering, the shallower the light will penetrate"
#MaterialVolume.step_method -> step_method:   enum  "Method of calculating the steps through the volume"
#+ * MaterialVolume.step_size -> step_size:   float  "Distance between subsequent volume depth samples"
#+ * MaterialVolume.transmission_color -> transmission_color:   float[3]  "Result color of the volume, after other light has been scattered/absorbed"
#MaterialVolume.use_external_shadows -> use_external_shadows:   boolean  "Receive shadows from sources outside the volume (temporary)"
#MaterialVolume.use_light_cache -> use_light_cache:   boolean  "Pre-calculate the shading information into a voxel grid, speeds up shading at slightly less accuracy"
#+ * Menu.bl_idname -> bl_idname:   string  "If this is set, the menu gets a custom ID, otherwise it takes the name of the class used to define the panel. For example, if the class name is OBJECT_MT_hello, and bl_idname is not set by the script, then bl_idname = OBJECT_MT_hello"
#+ * Menu.bl_label -> bl_label:   string  "The menu label"
#+ * Menu.layout -> layout:   pointer,  "(read-only)    Defines the structure of the menu in the UI."
#+ * MeshColor.color1 -> color1:   float[3]  "NO DESCRIPTION"
#+ * MeshColor.color2 -> color2:   float[3]  "NO DESCRIPTION"
#+ * MeshColor.color3 -> color3:   float[3]  "NO DESCRIPTION"
#+ * MeshColor.color4 -> color4:   float[3]  "NO DESCRIPTION"
#+ * MeshColorLayer.active -> active:   boolean  "Sets the layer as active for display and editing"
#+ * MeshColorLayer.active_render -> active_render:   boolean  "Sets the layer as active for rendering"
#+ * MeshColorLayer.data -> data:   collection,  "(read-only)"
#+ * MeshColorLayer.name -> name:   string  "NO DESCRIPTION"
#+ * MeshEdge.bevel_weight -> bevel_weight:   float  "Weight used by the Bevel modifier"
#+ * MeshEdge.crease -> crease:   float  "Weight used by the Subsurf modifier for creasing"
#+ * MeshEdge.hide -> hide:   boolean  "NO DESCRIPTION"
#+ * MeshEdge.index -> index:   int,  "(read-only)    Index number of the vertex"
#MeshEdge.is_fgon -> is_fgon:   boolean  "Fgon edge"
#MeshEdge.is_loose -> is_loose:   boolean  "Loose edge"
#+ * MeshEdge.select -> select:   boolean  "NO DESCRIPTION"
#MeshEdge.use_edge_sharp -> use_edge_sharp:   boolean  "Sharp edge for the EdgeSplit modifier"
#MeshEdge.use_seam -> use_seam:   boolean  "Seam edge for UV unwrapping"
#MeshEdge.vertices -> vertices:   int[2]  "Vertex indices"
#+ * MeshFace.area -> area:   float,  "(read-only)    read only area of the face"
#+ * MeshFace.hide -> hide:   boolean  "NO DESCRIPTION"
#+ * MeshFace.index -> index:   int,  "(read-only)    Index number of the vertex"
#+ * MeshFace.material_index -> material_index:   int  "NO DESCRIPTION"
#+ * MeshFace.normal -> normal:   float[3],  "(read-only)    local space unit length normal vector for this face"
#+ * MeshFace.select -> select:   boolean  "NO DESCRIPTION"
#MeshFace.use_smooth -> use_smooth:   boolean  "NO DESCRIPTION"
#MeshFace.vertices -> vertices:   int[4]  "Vertex indices"
#MeshFace.vertices_raw -> vertices_raw:   int[4]  "Fixed size vertex indices array"
#+ * MeshFaces.active -> active:   int  "The active face for this mesh"
#+ * MeshFaces.active_tface -> active_tface:   pointer,  "(read-only)    Active Texture Face"
#+ * MeshFloatProperty.value -> value:   float  "NO DESCRIPTION"
#+ * MeshFloatPropertyLayer.data -> data:   collection,  "(read-only)"
#+ * MeshFloatPropertyLayer.name -> name:   string  "NO DESCRIPTION"
#+ * MeshIntProperty.value -> value:   int  "NO DESCRIPTION"
#+ * MeshIntPropertyLayer.data -> data:   collection,  "(read-only)"
#+ * MeshIntPropertyLayer.name -> name:   string  "NO DESCRIPTION"
#+ * MeshSticky.co -> co:   float[2]  "Sticky texture coordinate location"
#+ * MeshStringProperty.value -> value:   string  "NO DESCRIPTION"
#+ * MeshStringPropertyLayer.data -> data:   collection,  "(read-only)"
#+ * MeshStringPropertyLayer.name -> name:   string  "NO DESCRIPTION"
#MeshTextureFace.blend_type -> blend_type:   enum  "Transparency blending mode"
#MeshTextureFace.hide -> hide:   boolean  "Make face invisible"
#+ * MeshTextureFace.image -> image:   pointer  "NO DESCRIPTION"
#MeshTextureFace.pin_uv -> pin_uv:   boolean[4]  "NO DESCRIPTION"
#+ * MeshTextureFace.select_uv -> select_uv:   boolean[4]  "NO DESCRIPTION"
#MeshTextureFace.use_alpha_sort -> use_alpha_sort:   boolean  "Enable sorting of faces for correct alpha drawing (slow, use Clip Alpha instead when possible)"
#MeshTextureFace.use_billboard -> use_billboard:   boolean  "Billboard with Z-axis constraint"
#MeshTextureFace.use_bitmap_text -> use_bitmap_text:   boolean  "Enable bitmap text on face"
#MeshTextureFace.use_blend_shared -> use_blend_shared:   boolean  "Blend vertex colors across face when vertices are shared"
#MeshTextureFace.use_collision -> use_collision:   boolean  "Use face for collision and ray-sensor detection"
#MeshTextureFace.use_halo -> use_halo:   boolean  "Screen aligned billboard"
#MeshTextureFace.use_image -> use_image:   boolean  "Render face with texture"
#MeshTextureFace.use_light -> use_light:   boolean  "Use light for face"
#MeshTextureFace.use_object_color -> use_object_color:   boolean  "Use ObColor instead of vertex colors"
#MeshTextureFace.use_shadow_cast -> use_shadow_cast:   boolean  "Face is used for shadow"
#MeshTextureFace.use_twoside -> use_twoside:   boolean  "Render face two-sided"
#+ * MeshTextureFace.uv -> uv:   float[8]  "NO DESCRIPTION"
#+ * MeshTextureFace.uv1 -> uv1:   float[2]  "NO DESCRIPTION"
#+ * MeshTextureFace.uv2 -> uv2:   float[2]  "NO DESCRIPTION"
#+ * MeshTextureFace.uv3 -> uv3:   float[2]  "NO DESCRIPTION"
#+ * MeshTextureFace.uv4 -> uv4:   float[2]  "NO DESCRIPTION"
#+ * MeshTextureFace.uv_raw -> uv_raw:   float[8]  "Fixed size UV coordinates array"
#+ * MeshTextureFaceLayer.active -> active:   boolean  "Sets the layer as active for display and editing"
#+ * MeshTextureFaceLayer.active_clone -> active_clone:   boolean  "Sets the layer as active for cloning"
#+ * MeshTextureFaceLayer.active_render -> active_render:   boolean  "Sets the layer as active for rendering"
#+ * MeshTextureFaceLayer.data -> data:   collection,  "(read-only)"
#+ * MeshTextureFaceLayer.name -> name:   string  "NO DESCRIPTION"
#+ * MeshVertex.bevel_weight -> bevel_weight:   float  "Weight used by the Bevel modifier Only Vertices option"
#+ * MeshVertex.co -> co:   float[3]  "NO DESCRIPTION"
#+ * MeshVertex.groups -> groups:   collection,  "(read-only)    Weights for the vertex groups this vertex is member of"
#+ * MeshVertex.hide -> hide:   boolean  "NO DESCRIPTION"
#+ * MeshVertex.index -> index:   int,  "(read-only)    Index number of the vertex"
#+ * MeshVertex.normal -> normal:   float[3]  "Vertex Normal"
#+ * MeshVertex.select -> select:   boolean  "NO DESCRIPTION"
#MetaBallElements.active -> active:   pointer,  "(read-only)    Last selected element"
#MetaElement.co -> co:   float[3]  "NO DESCRIPTION"
#+ * MetaElement.hide -> hide:   boolean  "Hide element"
#+ * MetaElement.radius -> radius:   float  "NO DESCRIPTION"
#+ * MetaElement.rotation -> rotation:   float[4]  "NO DESCRIPTION"
#+ * MetaElement.size_x -> size_x:   float  "Size of element, use of components depends on element type"
#+ * MetaElement.size_y -> size_y:   float  "Size of element, use of components depends on element type"
#+ * MetaElement.size_z -> size_z:   float  "Size of element, use of components depends on element type"
#+ * MetaElement.stiffness -> stiffness:   float  "Stiffness defines how much of the element to fill"
#+ * MetaElement.type -> type:   enum  "Metaball types"
#MetaElement.use_negative -> use_negative:   boolean  "Set metaball as negative one"
#+ * Modifier.name -> name:   string  "Modifier name"
#Modifier.show_expanded -> show_expanded:   boolean  "Set modifier expanded in the user interface"
#Modifier.show_in_editmode -> show_in_editmode:   boolean  "Use modifier while in the edit mode"
#Modifier.show_on_cage -> show_on_cage:   boolean  "Enable direct editing of modifier control cage"
#Modifier.show_render -> show_render:   boolean  "Use modifier during rendering"
#Modifier.show_viewport -> show_viewport:   boolean  "Realtime display of a modifier"
#+ * Modifier.type -> type:   enum,  "(read-only)"
#Modifier|ArmatureModifier.invert_vertex_group -> invert_vertex_group:   boolean  "Invert vertex group influence"
#+ * Modifier|ArmatureModifier.object -> object:   pointer  "Armature object to deform with"
#+ * Modifier|ArmatureModifier.use_bone_envelopes -> use_bone_envelopes:   boolean  "NO DESCRIPTION"
#Modifier|ArmatureModifier.use_deform_preserve_volume -> use_deform_preserve_volume:   boolean  "Deform rotation interpolation with quaternions"
#Modifier|ArmatureModifier.use_multi_modifier -> use_multi_modifier:   boolean  "Use same input as previous modifier, and mix results using overall vgroup"
#+ * Modifier|ArmatureModifier.use_vertex_groups -> use_vertex_groups:   boolean  "NO DESCRIPTION"
#+ * Modifier|ArmatureModifier.vertex_group -> vertex_group:   string  "Vertex group name"
#Modifier|ArrayModifier.constant_offset_displace -> constant_offset_displace:   float[3]  "NO DESCRIPTION"
#+ * Modifier|ArrayModifier.count -> count:   int  "Number of duplicates to make"
#+ * Modifier|ArrayModifier.curve -> curve:   pointer  "Curve object to fit array length to"
#+ * Modifier|ArrayModifier.end_cap -> end_cap:   pointer  "Mesh object to use as an end cap"
#Modifier|ArrayModifier.fit_length -> fit_length:   float  "Length to fit array within"
#+ * Modifier|ArrayModifier.fit_type -> fit_type:   enum  "Array length calculation method"
#Modifier|ArrayModifier.merge_threshold -> merge_threshold:   float  "Limit below which to merge vertices"
#+ * Modifier|ArrayModifier.offset_object -> offset_object:   pointer  "NO DESCRIPTION"
#Modifier|ArrayModifier.relative_offset_displace -> relative_offset_displace:   float[3]  "NO DESCRIPTION"
#+ * Modifier|ArrayModifier.start_cap -> start_cap:   pointer  "Mesh object to use as a start cap"
#Modifier|ArrayModifier.use_constant_offset -> use_constant_offset:   boolean  "Add a constant offset"
#Modifier|ArrayModifier.use_merge_vertices -> use_merge_vertices:   boolean  "Merge vertices in adjacent duplicates"
#Modifier|ArrayModifier.use_merge_vertices_cap -> use_merge_vertices_cap:   boolean  "Merge vertices in first and last duplicates"
#Modifier|ArrayModifier.use_object_offset -> use_object_offset:   boolean  "Add another objects transformation to the total offset"
#Modifier|ArrayModifier.use_relative_offset -> use_relative_offset:   boolean  "Add an offset relative to the objects bounding box"
#Modifier|BevelModifier.angle_limit -> angle_limit:   float  "Angle above which to bevel edges"
#+ * Modifier|BevelModifier.edge_weight_method -> edge_weight_method:   enum  "What edge weight to use for weighting a vertex"
#+ * Modifier|BevelModifier.limit_method -> limit_method:   enum  "NO DESCRIPTION"
#Modifier|BevelModifier.use_only_vertices -> use_only_vertices:   boolean  "Bevel verts/corners, not edges"
#+ * Modifier|BevelModifier.width -> width:   float  "Bevel value/amount"
#+ * Modifier|BooleanModifier.object -> object:   pointer  "Mesh object to use for Boolean operation"
#+ * Modifier|BooleanModifier.operation -> operation:   enum  "NO DESCRIPTION"
#Modifier|BuildModifier.frame_duration -> frame_duration:   float  "Specify the total time the build effect requires"
#+ * Modifier|BuildModifier.frame_start -> frame_start:   float  "Specify the start frame of the effect"
#+ * Modifier|BuildModifier.seed -> seed:   int  "Specify the seed for random if used"
#Modifier|BuildModifier.use_random_order -> use_random_order:   boolean  "Randomize the faces or edges during build"
#+ * Modifier|CastModifier.cast_type -> cast_type:   enum  "NO DESCRIPTION"
#+ * Modifier|CastModifier.factor -> factor:   float  "NO DESCRIPTION"
#+ * Modifier|CastModifier.object -> object:   pointer  "Control object: if available, its location determines the center of the effect"
#+ * Modifier|CastModifier.radius -> radius:   float  "Only deform vertices within this distance from the center of the effect (leave as 0 for infinite.)"
#+ * Modifier|CastModifier.size -> size:   float  "Size of projection shape (leave as 0 for auto.)"
#Modifier|CastModifier.use_radius_as_size -> use_radius_as_size:   boolean  "Use radius as size of projection shape (0 = auto)"
#+ * Modifier|CastModifier.use_transform -> use_transform:   boolean  "Use object transform to control projection shape"
#Modifier|CastModifier.use_x -> use_x:   boolean  "NO DESCRIPTION"
#Modifier|CastModifier.use_y -> use_y:   boolean  "NO DESCRIPTION"
#Modifier|CastModifier.use_z -> use_z:   boolean  "NO DESCRIPTION"
#+ * Modifier|CastModifier.vertex_group -> vertex_group:   string  "Vertex group name"
#+ * Modifier|ClothModifier.collision_settings -> collision_settings:   pointer,  "(read-only)"
#+ * Modifier|ClothModifier.point_cache -> point_cache:   pointer,  "(read-only)"
#+ * Modifier|ClothModifier.settings -> settings:   pointer,  "(read-only)"
#+ * Modifier|CollisionModifier.settings -> settings:   pointer,  "(read-only)"
#+ * Modifier|CurveModifier.deform_axis -> deform_axis:   enum  "The axis that the curve deforms along"
#+ * Modifier|CurveModifier.object -> object:   pointer  "Curve object to deform with"
#+ * Modifier|CurveModifier.vertex_group -> vertex_group:   string  "Vertex group name"
#+ * Modifier|DecimateModifier.face_count -> face_count:   int,  "(read-only)    The current number of faces in the decimated mesh"
#+ * Modifier|DecimateModifier.ratio -> ratio:   float  "Defines the ratio of triangles to reduce to"
#+ * Modifier|DisplaceModifier.direction -> direction:   enum  "NO DESCRIPTION"
#Modifier|DisplaceModifier.mid_level -> mid_level:   float  "Material value that gives no displacement"
#+ * Modifier|DisplaceModifier.strength -> strength:   float  "NO DESCRIPTION"
#+ * Modifier|DisplaceModifier.texture -> texture:   pointer  "NO DESCRIPTION"
#+ * Modifier|DisplaceModifier.texture_coordinate_object -> texture_coordinate_object:   pointer  "NO DESCRIPTION"
#Modifier|DisplaceModifier.texture_coords -> texture_coords:   enum  "NO DESCRIPTION"
#+ * Modifier|DisplaceModifier.uv_layer -> uv_layer:   string  "UV layer name"
#+ * Modifier|DisplaceModifier.vertex_group -> vertex_group:   string  "Vertex group name"
#+ * Modifier|EdgeSplitModifier.split_angle -> split_angle:   float  "Angle above which to split edges"
#+ * Modifier|EdgeSplitModifier.use_edge_angle -> use_edge_angle:   boolean  "Split edges with high angle between faces"
#Modifier|EdgeSplitModifier.use_edge_sharp -> use_edge_sharp:   boolean  "Split edges that are marked as sharp"
#+ * Modifier|ExplodeModifier.protect -> protect:   float  "Clean vertex group edges"
#Modifier|ExplodeModifier.show_alive -> show_alive:   boolean  "Show mesh when particles are alive"
#Modifier|ExplodeModifier.show_dead -> show_dead:   boolean  "Show mesh when particles are dead"
#Modifier|ExplodeModifier.show_unborn -> show_unborn:   boolean  "Show mesh when particles are unborn"
#Modifier|ExplodeModifier.use_edge_split -> use_edge_split:   boolean  "Split face edges for nicer shrapnel"
#Modifier|ExplodeModifier.use_size -> use_size:   boolean  "Use particle size for the shrapnel"
#+ * Modifier|ExplodeModifier.vertex_group -> vertex_group:   string  "NO DESCRIPTION"
#+ * Modifier|FluidSimulationModifier.settings -> settings:   pointer,  "(read-only)    Settings for how this object is used in the fluid simulation"
#+ * Modifier|HookModifier.falloff -> falloff:   float  "If not zero, the distance from the hook where influence ends"
#+ * Modifier|HookModifier.force -> force:   float  "Relative force of the hook"
#+ * Modifier|HookModifier.object -> object:   pointer  "Parent Object for hook, also recalculates and clears offset"
#+ * Modifier|HookModifier.subtarget -> subtarget:   string  "Name of Parent Bone for hook (if applicable), also recalculates and clears offset"
#+ * Modifier|HookModifier.vertex_group -> vertex_group:   string  "Vertex group name"
#+ * Modifier|LatticeModifier.object -> object:   pointer  "Lattice object to deform with"
#+ * Modifier|LatticeModifier.vertex_group -> vertex_group:   string  "Vertex group name"
#+ * Modifier|MaskModifier.armature -> armature:   pointer  "Armature to use as source of bones to mask"
#Modifier|MaskModifier.invert_vertex_group -> invert_vertex_group:   boolean  "Use vertices that are not part of region defined"
#+ * Modifier|MaskModifier.mode -> mode:   enum  "NO DESCRIPTION"
#+ * Modifier|MaskModifier.vertex_group -> vertex_group:   string  "Vertex group name"
#Modifier|MeshDeformModifier.invert_vertex_group -> invert_vertex_group:   boolean  "Invert vertex group influence"
#+ * Modifier|MeshDeformModifier.is_bound -> is_bound:   boolean,  "(read-only)    Whether geometry has been bound to control cage"
#+ * Modifier|MeshDeformModifier.object -> object:   pointer  "Mesh object to deform with"
#+ * Modifier|MeshDeformModifier.precision -> precision:   int  "The grid size for binding"
#Modifier|MeshDeformModifier.use_dynamic_bind -> use_dynamic_bind:   boolean  "Recompute binding dynamically on top of other deformers (slower and more memory consuming.)"
#+ * Modifier|MeshDeformModifier.vertex_group -> vertex_group:   string  "Vertex group name"
#Modifier|MirrorModifier.merge_threshold -> merge_threshold:   float  "Distance from axis within which mirrored vertices are merged"
#+ * Modifier|MirrorModifier.mirror_object -> mirror_object:   pointer  "Object to use as mirror"
#Modifier|MirrorModifier.use_clip -> use_clip:   boolean  "Prevents vertices from going through the mirror during transform"
#Modifier|MirrorModifier.use_mirror_u -> use_mirror_u:   boolean  "Mirror the U texture coordinate around the 0.5 point"
#Modifier|MirrorModifier.use_mirror_v -> use_mirror_v:   boolean  "Mirror the V texture coordinate around the 0.5 point"
#Modifier|MirrorModifier.use_mirror_vertex_groups -> use_mirror_vertex_groups:   boolean  "Mirror vertex groups (e.g. .R->.L)"
#Modifier|MirrorModifier.use_x -> use_x:   boolean  "Enable X axis mirror"
#Modifier|MirrorModifier.use_y -> use_y:   boolean  "Enable Y axis mirror"
#Modifier|MirrorModifier.use_z -> use_z:   boolean  "Enable Z axis mirror"
#+ * Modifier|MultiresModifier.filepath -> filepath:   string  "Path to external displacements file"
#Modifier|MultiresModifier.is_external -> is_external:   boolean,  "(read-only)    Store multires displacements outside the .blend file, to save memory"
#+ * Modifier|MultiresModifier.levels -> levels:   int  "Number of subdivisions to use in the viewport"
#+ * Modifier|MultiresModifier.render_levels -> render_levels:   int  "NO DESCRIPTION"
#+ * Modifier|MultiresModifier.sculpt_levels -> sculpt_levels:   int  "Number of subdivisions to use in sculpt mode"
#Modifier|MultiresModifier.show_only_control_edges -> show_only_control_edges:   boolean  "Skip drawing/rendering of interior subdivided edges"
#+ * Modifier|MultiresModifier.subdivision_type -> subdivision_type:   enum  "Selects type of subdivision algorithm"
#+ * Modifier|MultiresModifier.total_levels -> total_levels:   int,  "(read-only)    Number of subdivisions for which displacements are stored"
#+ * Modifier|ParticleInstanceModifier.axis -> axis:   enum  "Pole axis for rotation"
#+ * Modifier|ParticleInstanceModifier.object -> object:   pointer  "Object that has the particle system"
#Modifier|ParticleInstanceModifier.particle_system_index -> particle_system_index:   int  "NO DESCRIPTION"
#+ * Modifier|ParticleInstanceModifier.position -> position:   float  "Position along path"
#+ * Modifier|ParticleInstanceModifier.random_position -> random_position:   float  "Randomize position along path"
#Modifier|ParticleInstanceModifier.show_alive -> show_alive:   boolean  "Show instances when particles are alive"
#Modifier|ParticleInstanceModifier.show_dead -> show_dead:   boolean  "Show instances when particles are dead"
#Modifier|ParticleInstanceModifier.show_unborn -> show_unborn:   boolean  "Show instances when particles are unborn"
#Modifier|ParticleInstanceModifier.use_children -> use_children:   boolean  "Create instances from child particles"
#Modifier|ParticleInstanceModifier.use_normal -> use_normal:   boolean  "Create instances from normal particles"
#+ * Modifier|ParticleInstanceModifier.use_path -> use_path:   boolean  "Create instances along particle paths"
#Modifier|ParticleInstanceModifier.use_preserve_shape -> use_preserve_shape:   boolean  "Dont stretch the object"
#Modifier|ParticleInstanceModifier.use_size -> use_size:   boolean  "Use particle size to scale the instances"
#+ * Modifier|ParticleSystemModifier.particle_system -> particle_system:   pointer,  "(read-only)    Particle System that this modifier controls"
#+ * Modifier|ScrewModifier.angle -> angle:   float  "Angle of revolution"
#+ * Modifier|ScrewModifier.axis -> axis:   enum  "Screw axis"
#+ * Modifier|ScrewModifier.iterations -> iterations:   int  "Number of times to apply the screw operation"
#+ * Modifier|ScrewModifier.object -> object:   pointer  "Object to define the screw axis"
#+ * Modifier|ScrewModifier.render_steps -> render_steps:   int  "Number of steps in the revolution"
#+ * Modifier|ScrewModifier.screw_offset -> screw_offset:   float  "Offset the revolution along its axis"
#+ * Modifier|ScrewModifier.steps -> steps:   int  "Number of steps in the revolution"
#+ * Modifier|ScrewModifier.use_normal_calculate -> use_normal_calculate:   boolean  "Calculate the order of edges (needed for meshes, but not curves)"
#+ * Modifier|ScrewModifier.use_normal_flip -> use_normal_flip:   boolean  "Flip normals of lathed faces"
#+ * Modifier|ScrewModifier.use_object_screw_offset -> use_object_screw_offset:   boolean  "Use the distance between the objects to make a screw"
#+ * Modifier|ShrinkwrapModifier.auxiliary_target -> auxiliary_target:   pointer  "Additional mesh target to shrink to"
#+ * Modifier|ShrinkwrapModifier.offset -> offset:   float  "Distance to keep from the target"
#+ * Modifier|ShrinkwrapModifier.subsurf_levels -> subsurf_levels:   int  "Number of subdivisions that must be performed before extracting vertices positions and normals"
#+ * Modifier|ShrinkwrapModifier.target -> target:   pointer  "Mesh target to shrink to"
#Modifier|ShrinkwrapModifier.use_cull_back_faces -> use_cull_back_faces:   boolean  "Stop vertices from projecting to a back face on the target"
#Modifier|ShrinkwrapModifier.use_cull_front_faces -> use_cull_front_faces:   boolean  "Stop vertices from projecting to a front face on the target"
#Modifier|ShrinkwrapModifier.use_keep_above_surface -> use_keep_above_surface:   boolean  "NO DESCRIPTION"
#Modifier|ShrinkwrapModifier.use_negative_direction -> use_negative_direction:   boolean  "Allow vertices to move in the negative direction of axis"
#Modifier|ShrinkwrapModifier.use_positive_direction -> use_positive_direction:   boolean  "Allow vertices to move in the positive direction of axis"
#Modifier|ShrinkwrapModifier.use_project_x -> use_project_x:   boolean  "NO DESCRIPTION"
#Modifier|ShrinkwrapModifier.use_project_y -> use_project_y:   boolean  "NO DESCRIPTION"
#Modifier|ShrinkwrapModifier.use_project_z -> use_project_z:   boolean  "NO DESCRIPTION"
#+ * Modifier|ShrinkwrapModifier.vertex_group -> vertex_group:   string  "Vertex group name"
#Modifier|ShrinkwrapModifier.wrap_method -> wrap_method:   enum  "NO DESCRIPTION"
#Modifier|SimpleDeformModifier.deform_method -> deform_method:   enum  "NO DESCRIPTION"
#+ * Modifier|SimpleDeformModifier.factor -> factor:   float  "NO DESCRIPTION"
#+ * Modifier|SimpleDeformModifier.limits -> limits:   float[2]  "Lower/Upper limits for deform"
#Modifier|SimpleDeformModifier.lock_x -> lock_x:   boolean  "NO DESCRIPTION"
#Modifier|SimpleDeformModifier.lock_y -> lock_y:   boolean  "NO DESCRIPTION"
#+ * Modifier|SimpleDeformModifier.origin -> origin:   pointer  "Origin of modifier space coordinates"
#Modifier|SimpleDeformModifier.use_relative -> use_relative:   boolean  "Sets the origin of deform space to be relative to the object"
#+ * Modifier|SimpleDeformModifier.vertex_group -> vertex_group:   string  "Vertex group name"
#+ * Modifier|SmokeModifier.coll_settings -> coll_settings:   pointer,  "(read-only)"
#+ * Modifier|SmokeModifier.domain_settings -> domain_settings:   pointer,  "(read-only)"
#+ * Modifier|SmokeModifier.flow_settings -> flow_settings:   pointer,  "(read-only)"
#Modifier|SmokeModifier.smoke_type -> smoke_type:   enum  "NO DESCRIPTION"
#+ * Modifier|SmoothModifier.factor -> factor:   float  "NO DESCRIPTION"
#Modifier|SmoothModifier.iterations -> iterations:   int  "NO DESCRIPTION"
#Modifier|SmoothModifier.use_x -> use_x:   boolean  "NO DESCRIPTION"
#Modifier|SmoothModifier.use_y -> use_y:   boolean  "NO DESCRIPTION"
#Modifier|SmoothModifier.use_z -> use_z:   boolean  "NO DESCRIPTION"
#+ * Modifier|SmoothModifier.vertex_group -> vertex_group:   string  "Vertex group name"
#+ * Modifier|SoftBodyModifier.point_cache -> point_cache:   pointer,  "(read-only)"
#+ * Modifier|SoftBodyModifier.settings -> settings:   pointer,  "(read-only)"
#+ * Modifier|SolidifyModifier.edge_crease_inner -> edge_crease_inner:   float  "Assign a crease to inner edges"
#+ * Modifier|SolidifyModifier.edge_crease_outer -> edge_crease_outer:   float  "Assign a crease to outer edges"
#+ * Modifier|SolidifyModifier.edge_crease_rim -> edge_crease_rim:   float  "Assign a crease to the edges making up the rim"
#Modifier|SolidifyModifier.invert_vertex_group -> invert_vertex_group:   boolean  "Invert the vertex group influence"
#+ * Modifier|SolidifyModifier.offset -> offset:   float  "Offset the thickness from the center"
#+ * Modifier|SolidifyModifier.thickness -> thickness:   float  "Thickness of the shell"
#+ * Modifier|SolidifyModifier.use_even_offset -> use_even_offset:   boolean  "Maintain thickness by adjusting for sharp corners (slow, disable when not needed)"
#+ * Modifier|SolidifyModifier.use_quality_normals -> use_quality_normals:   boolean  "Calculate normals which result in more even thickness (slow, disable when not needed)"
#+ * Modifier|SolidifyModifier.use_rim -> use_rim:   boolean  "Create edge loops between the inner and outer surfaces on face edges (slow, disable when not needed)"
#+ * Modifier|SolidifyModifier.use_rim_material -> use_rim_material:   boolean  "Use in the next material for rim faces"
#+ * Modifier|SolidifyModifier.vertex_group -> vertex_group:   string  "Vertex group name"
#+ * Modifier|SubsurfModifier.levels -> levels:   int  "Number of subdivisions to perform"
#+ * Modifier|SubsurfModifier.render_levels -> render_levels:   int  "Number of subdivisions to perform when rendering"
#Modifier|SubsurfModifier.show_only_control_edges -> show_only_control_edges:   boolean  "Skip drawing/rendering of interior subdivided edges"
#+ * Modifier|SubsurfModifier.subdivision_type -> subdivision_type:   enum  "Selects type of subdivision algorithm"
#Modifier|SubsurfModifier.use_subsurf_uv -> use_subsurf_uv:   boolean  "Use subsurf to subdivide UVs"
#+ * Modifier|UVProjectModifier.aspect_x -> aspect_x:   float  "NO DESCRIPTION"
#+ * Modifier|UVProjectModifier.aspect_y -> aspect_y:   float  "NO DESCRIPTION"
#+ * Modifier|UVProjectModifier.image -> image:   pointer  "NO DESCRIPTION"
#Modifier|UVProjectModifier.projector_count -> projector_count:   int  "Number of projectors to use"
#+ * Modifier|UVProjectModifier.projectors -> projectors:   collection,  "(read-only)"
#+ * Modifier|UVProjectModifier.scale_x -> scale_x:   float  "NO DESCRIPTION"
#+ * Modifier|UVProjectModifier.scale_y -> scale_y:   float  "NO DESCRIPTION"
#Modifier|UVProjectModifier.use_image_override -> use_image_override:   boolean  "Override faces current images with the given image"
#+ * Modifier|UVProjectModifier.uv_layer -> uv_layer:   string  "UV layer name"
#+ * Modifier|WaveModifier.damping_time -> damping_time:   float  "NO DESCRIPTION"
#+ * Modifier|WaveModifier.falloff_radius -> falloff_radius:   float  "NO DESCRIPTION"
#+ * Modifier|WaveModifier.height -> height:   float  "NO DESCRIPTION"
#+ * Modifier|WaveModifier.lifetime -> lifetime:   float  "NO DESCRIPTION"
#+ * Modifier|WaveModifier.narrowness -> narrowness:   float  "NO DESCRIPTION"
#+ * Modifier|WaveModifier.speed -> speed:   float  "NO DESCRIPTION"
#+ * Modifier|WaveModifier.start_position_object -> start_position_object:   pointer  "NO DESCRIPTION"
#+ * Modifier|WaveModifier.start_position_x -> start_position_x:   float  "NO DESCRIPTION"
#+ * Modifier|WaveModifier.start_position_y -> start_position_y:   float  "NO DESCRIPTION"
#+ * Modifier|WaveModifier.texture -> texture:   pointer  "Texture for modulating the wave"
#Modifier|WaveModifier.texture_coords -> texture_coords:   enum  "Texture coordinates used for modulating input"
#Modifier|WaveModifier.texture_coords_object -> texture_coords_object:   pointer  "NO DESCRIPTION"
#+ * Modifier|WaveModifier.time_offset -> time_offset:   float  "Either the starting frame (for positive speed) or ending frame (for negative speed.)"
#Modifier|WaveModifier.use_cyclic -> use_cyclic:   boolean  "Cyclic wave effect"
#Modifier|WaveModifier.use_normal -> use_normal:   boolean  "Displace along normals"
#Modifier|WaveModifier.use_normal_x -> use_normal_x:   boolean  "Enable displacement along the X normal"
#Modifier|WaveModifier.use_normal_y -> use_normal_y:   boolean  "Enable displacement along the Y normal"
#Modifier|WaveModifier.use_normal_z -> use_normal_z:   boolean  "Enable displacement along the Z normal"
#Modifier|WaveModifier.use_x -> use_x:   boolean  "X axis motion"
#Modifier|WaveModifier.use_y -> use_y:   boolean  "Y axis motion"
#+ * Modifier|WaveModifier.uv_layer -> uv_layer:   string  "UV layer name"
#+ * Modifier|WaveModifier.vertex_group -> vertex_group:   string  "Vertex group name for modulating the wave"
#+ * Modifier|WaveModifier.width -> width:   float  "NO DESCRIPTION"
#+ * MotionPath.frame_end -> frame_end:   int,  "(read-only)    End frame of the stored range"
#+ * MotionPath.frame_start -> frame_start:   int,  "(read-only)    Starting frame of the stored range"
#MotionPath.is_modified -> is_modified:   boolean  "Path is being edited"
#+ * MotionPath.length -> length:   int,  "(read-only)    Number of frames cached"
#+ * MotionPath.points -> points:   collection,  "(read-only)    Cached positions per frame"
#+ * MotionPath.use_bone_head -> use_bone_head:   boolean,  "(read-only)    For PoseBone paths, use the bone head location when calculating this path"
#+ * MotionPathVert.co -> co:   float[3]  "NO DESCRIPTION"
#+ * MotionPathVert.select -> select:   boolean  "Path point is selected for editing"
#+ * NlaStrip.action -> action:   pointer  "Action referenced by this strip"
#NlaStrip.action_frame_end -> action_frame_end:   float  "NO DESCRIPTION"
#NlaStrip.action_frame_start -> action_frame_start:   float  "NO DESCRIPTION"
#+ * NlaStrip.active -> active:   boolean,  "(read-only)    NLA Strip is active"
#+ * NlaStrip.blend_in -> blend_in:   float  "Number of frames at start of strip to fade in influence"
#+ * NlaStrip.blend_out -> blend_out:   float  "NO DESCRIPTION"
#NlaStrip.blend_type -> blend_type:   enum  "Method used for combining strips result with accumulated result"
#+ * NlaStrip.extrapolation -> extrapolation:   enum  "Action to take for gaps past the strip extents"
#+ * NlaStrip.fcurves -> fcurves:   collection,  "(read-only)    F-Curves for controlling the strips influence and timing"
#+ * NlaStrip.frame_end -> frame_end:   float  "NO DESCRIPTION"
#+ * NlaStrip.frame_start -> frame_start:   float  "NO DESCRIPTION"
#+ * NlaStrip.influence -> influence:   float  "Amount the strip contributes to the current result"
#+ * NlaStrip.modifiers -> modifiers:   collection,  "(read-only)    Modifiers affecting all the F-Curves in the referenced Action"
#+ * NlaStrip.mute -> mute:   boolean  "NLA Strip is not evaluated"
#+ * NlaStrip.name -> name:   string  "NO DESCRIPTION"
#+ * NlaStrip.repeat -> repeat:   float  "Number of times to repeat the action range"
#+ * NlaStrip.scale -> scale:   float  "Scaling factor for action"
#+ * NlaStrip.select -> select:   boolean  "NLA Strip is selected"
#+ * NlaStrip.strip_time -> strip_time:   float  "Frame of referenced Action to evaluate"
#+ * NlaStrip.strips -> strips:   collection,  "(read-only)    NLA Strips that this strip acts as a container for (if it is of type Meta)"
#+ * NlaStrip.type -> type:   enum,  "(read-only)    Type of NLA Strip"
#NlaStrip.use_animated_influence -> use_animated_influence:   boolean  "Influence setting is controlled by an F-Curve rather than automatically determined"
#NlaStrip.use_animated_time -> use_animated_time:   boolean  "Strip time is controlled by an F-Curve rather than automatically determined"
#NlaStrip.use_animated_time_cyclic -> use_animated_time_cyclic:   boolean  "Cycle the animated time within the action start & end"
#NlaStrip.use_auto_blend -> use_auto_blend:   boolean  "Number of frames for Blending In/Out is automatically determined from overlapping strips"
#NlaStrip.use_reverse -> use_reverse:   boolean  "NLA Strip is played back in reverse order (only when timing is automatically determined)"
#+ * NlaTrack.active -> active:   boolean,  "(read-only)    NLA Track is active"
#NlaTrack.is_solo -> is_solo:   boolean,  "(read-only)    NLA Track is evaluated itself (i.e. active Action and all other NLA Tracks in the same AnimData block are disabled)"
#+ * NlaTrack.lock -> lock:   boolean  "NLA Track is locked"
#+ * NlaTrack.mute -> mute:   boolean  "NLA Track is not evaluated"
#+ * NlaTrack.name -> name:   string  "NO DESCRIPTION"
#+ * NlaTrack.select -> select:   boolean  "NLA Track is selected"
#+ * NlaTrack.strips -> strips:   collection,  "(read-only)    NLA Strips on this NLA-track"
#+ * Node.inputs -> inputs:   collection,  "(read-only)"
#+ * Node.location -> location:   float[2]  "NO DESCRIPTION"
#+ * Node.name -> name:   string  "Node name"
#+ * Node.outputs -> outputs:   collection,  "(read-only)"
#+ * Node|CompositorNode.type -> type:   enum,  "(read-only)"
#+ * Node|CompositorNode|CompositorNodeAlphaOver.premul -> premul:   float  "Mix Factor"
#Node|CompositorNode|CompositorNodeAlphaOver.use_premultiply -> use_premultiply:   boolean  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeBilateralblur.iterations -> iterations:   int  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeBilateralblur.sigma_color -> sigma_color:   float  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeBilateralblur.sigma_space -> sigma_space:   float  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeBlur.factor -> factor:   float  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeBlur.factor_x -> factor_x:   float  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeBlur.factor_y -> factor_y:   float  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeBlur.filter_type -> filter_type:   enum  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeBlur.size_x -> size_x:   int  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeBlur.size_y -> size_y:   int  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeBlur.use_bokeh -> use_bokeh:   boolean  "Uses circular filter (slower)"
#Node|CompositorNode|CompositorNodeBlur.use_gamma_correction -> use_gamma_correction:   boolean  "Applies filter on gamma corrected values"
#Node|CompositorNode|CompositorNodeBlur.use_relative -> use_relative:   boolean  "Use relative (percent) values to define blur radius"
#+ * Node|CompositorNode|CompositorNodeChannelMatte.color_space -> color_space:   enum  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeChannelMatte.limit_channel -> limit_channel:   enum  "Limit by this channels value"
#Node|CompositorNode|CompositorNodeChannelMatte.limit_max -> limit_max:   float  "Values higher than this setting are 100% opaque"
#Node|CompositorNode|CompositorNodeChannelMatte.limit_method -> limit_method:   enum  "Algorithm to use to limit channel"
#Node|CompositorNode|CompositorNodeChannelMatte.limit_min -> limit_min:   float  "Values lower than this setting are 100% keyed"
#Node|CompositorNode|CompositorNodeChannelMatte.matte_channel -> matte_channel:   enum  "Channel used to determine matte"
#+ * Node|CompositorNode|CompositorNodeChromaMatte.gain -> gain:   float  "Alpha gain"
#+ * Node|CompositorNode|CompositorNodeChromaMatte.lift -> lift:   float  "Alpha lift"
#+ * Node|CompositorNode|CompositorNodeChromaMatte.shadow_adjust -> shadow_adjust:   float  "Adjusts the brightness of any shadows captured"
#Node|CompositorNode|CompositorNodeChromaMatte.threshold -> threshold:   float  "Tolerance below which colors will be considered as exact matches"
#Node|CompositorNode|CompositorNodeChromaMatte.tolerance -> tolerance:   float  "Tolerance for a color to be considered a keying color"
#Node|CompositorNode|CompositorNodeColorBalance.correction_method -> correction_method:   enum  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeColorBalance.gain -> gain:   float[3]  "Correction for Highlights"
#+ * Node|CompositorNode|CompositorNodeColorBalance.gamma -> gamma:   float[3]  "Correction for Midtones"
#+ * Node|CompositorNode|CompositorNodeColorBalance.lift -> lift:   float[3]  "Correction for Shadows"
#+ * Node|CompositorNode|CompositorNodeColorBalance.offset -> offset:   float[3]  "Correction for Shadows"
#+ * Node|CompositorNode|CompositorNodeColorBalance.power -> power:   float[3]  "Correction for Midtones"
#+ * Node|CompositorNode|CompositorNodeColorBalance.slope -> slope:   float[3]  "Correction for Highlights"
#Node|CompositorNode|CompositorNodeColorMatte.color_hue -> color_hue:   float  "Hue tolerance for colors to be considered a keying color"
#Node|CompositorNode|CompositorNodeColorMatte.color_saturation -> color_saturation:   float  "Saturation Tolerance for the color"
#Node|CompositorNode|CompositorNodeColorMatte.color_value -> color_value:   float  "Value Tolerance for the color"
#+ * Node|CompositorNode|CompositorNodeColorSpill.channel -> channel:   enum  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeColorSpill.limit_channel -> limit_channel:   enum  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeColorSpill.limit_method -> limit_method:   enum  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeColorSpill.ratio -> ratio:   float  "Scale limit by value"
#+ * Node|CompositorNode|CompositorNodeColorSpill.unspill_blue -> unspill_blue:   float  "Blue spillmap scale"
#+ * Node|CompositorNode|CompositorNodeColorSpill.unspill_green -> unspill_green:   float  "Green spillmap scale"
#+ * Node|CompositorNode|CompositorNodeColorSpill.unspill_red -> unspill_red:   float  "Red spillmap scale"
#Node|CompositorNode|CompositorNodeColorSpill.use_unspill -> use_unspill:   boolean  "Compensate all channels (diffenrently) by hand"
#Node|CompositorNode|CompositorNodeCrop.max_x -> max_x:   int  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeCrop.max_y -> max_y:   int  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeCrop.min_x -> min_x:   int  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeCrop.min_y -> min_y:   int  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeCrop.use_crop_size -> use_crop_size:   boolean  "Whether to crop the size of the input image"
#+ * Node|CompositorNode|CompositorNodeCurveRGB.mapping -> mapping:   pointer,  "(read-only)"
#+ * Node|CompositorNode|CompositorNodeCurveVec.mapping -> mapping:   pointer,  "(read-only)"
#+ * Node|CompositorNode|CompositorNodeDBlur.angle -> angle:   float  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeDBlur.center_x -> center_x:   float  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeDBlur.center_y -> center_y:   float  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeDBlur.distance -> distance:   float  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeDBlur.iterations -> iterations:   int  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeDBlur.spin -> spin:   float  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeDBlur.use_wrap -> use_wrap:   boolean  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeDBlur.zoom -> zoom:   float  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeDefocus.angle -> angle:   int  "Bokeh shape rotation offset in degrees"
#Node|CompositorNode|CompositorNodeDefocus.blur_max -> blur_max:   float  "blur limit, maximum CoC radius, 0=no limit"
#+ * Node|CompositorNode|CompositorNodeDefocus.bokeh -> bokeh:   enum  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeDefocus.f_stop -> f_stop:   float  "Amount of focal blur, 128=infinity=perfect focus, half the value doubles the blur radius"
#+ * Node|CompositorNode|CompositorNodeDefocus.samples -> samples:   int  "Number of samples (16=grainy, higher=less noise)"
#+ * Node|CompositorNode|CompositorNodeDefocus.threshold -> threshold:   float  "CoC radius threshold, prevents background bleed on in-focus midground, 0=off"
#Node|CompositorNode|CompositorNodeDefocus.use_gamma_correction -> use_gamma_correction:   boolean  "Enable gamma correction before and after main process"
#Node|CompositorNode|CompositorNodeDefocus.use_preview -> use_preview:   boolean  "Enable sampling mode, useful for preview when using low samplecounts"
#+ * Node|CompositorNode|CompositorNodeDefocus.use_zbuffer -> use_zbuffer:   boolean  "Disable when using an image as input instead of actual zbuffer (auto enabled if node not image based, eg. time node)"
#+ * Node|CompositorNode|CompositorNodeDefocus.z_scale -> z_scale:   float  "Scales the Z input when not using a zbuffer, controls maximum blur designated by the color white or input value 1"
#+ * Node|CompositorNode|CompositorNodeDiffMatte.falloff -> falloff:   float  "Color distances below this additional threshold are partially keyed"
#+ * Node|CompositorNode|CompositorNodeDiffMatte.tolerance -> tolerance:   float  "Color distances below this threshold are keyed"
#+ * Node|CompositorNode|CompositorNodeDilateErode.distance -> distance:   int  "Distance to grow/shrink (number of iterations)"
#+ * Node|CompositorNode|CompositorNodeDistanceMatte.falloff -> falloff:   float  "Color distances below this additional threshold are partially keyed"
#+ * Node|CompositorNode|CompositorNodeDistanceMatte.tolerance -> tolerance:   float  "Color distances below this threshold are keyed"
#+ * Node|CompositorNode|CompositorNodeFilter.filter_type -> filter_type:   enum  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeFlip.axis -> axis:   enum  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeGlare.angle_offset -> angle_offset:   float  "Streak angle offset in degrees"
#+ * Node|CompositorNode|CompositorNodeGlare.color_modulation -> color_modulation:   float  "Amount of Color Modulation, modulates colors of streaks and ghosts for a spectral dispersion effect"
#+ * Node|CompositorNode|CompositorNodeGlare.fade -> fade:   float  "Streak fade-out factor"
#+ * Node|CompositorNode|CompositorNodeGlare.glare_type -> glare_type:   enum  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeGlare.iterations -> iterations:   int  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeGlare.mix -> mix:   float  "-1 is original image only, 0 is exact 50/50 mix, 1 is processed image only"
#+ * Node|CompositorNode|CompositorNodeGlare.quality -> quality:   enum  "If not set to high quality, the effect will be applied to a low-res copy of the source image"
#+ * Node|CompositorNode|CompositorNodeGlare.size -> size:   int  "Glow/glare size (not actual size; relative to initial size of bright area of pixels)"
#+ * Node|CompositorNode|CompositorNodeGlare.streaks -> streaks:   int  "Total number of streaks"
#+ * Node|CompositorNode|CompositorNodeGlare.threshold -> threshold:   float  "The glare filter will only be applied to pixels brighter than this value"
#Node|CompositorNode|CompositorNodeGlare.use_rotate_45 -> use_rotate_45:   boolean  "Simple star filter: add 45 degree rotation offset"
#+ * Node|CompositorNode|CompositorNodeHueCorrect.mapping -> mapping:   pointer,  "(read-only)"
#Node|CompositorNode|CompositorNodeHueSat.color_hue -> color_hue:   float  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeHueSat.color_saturation -> color_saturation:   float  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeHueSat.color_value -> color_value:   float  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeIDMask.index -> index:   int  "Pass index number to convert to alpha"
#Node|CompositorNode|CompositorNodeImage.frame_duration -> frame_duration:   int  "Number of images used in animation"
#Node|CompositorNode|CompositorNodeImage.frame_offset -> frame_offset:   int  "Offsets the number of the frame to use in the animation"
#Node|CompositorNode|CompositorNodeImage.frame_start -> frame_start:   int  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeImage.image -> image:   pointer  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeImage.layer -> layer:   enum  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeImage.use_auto_refresh -> use_auto_refresh:   boolean  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeImage.use_cyclic -> use_cyclic:   boolean  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeInvert.invert_alpha -> invert_alpha:   boolean  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeInvert.invert_rgb -> invert_rgb:   boolean  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeLensdist.use_fit -> use_fit:   boolean  "For positive distortion factor only: scale image such that black areas are not visible"
#Node|CompositorNode|CompositorNodeLensdist.use_jitter -> use_jitter:   boolean  "Enable/disable jittering; faster, but also noisier"
#Node|CompositorNode|CompositorNodeLensdist.use_projector -> use_projector:   boolean  "Enable/disable projector mode. Effect is applied in horizontal direction only"
#+ * Node|CompositorNode|CompositorNodeLevels.channel -> channel:   enum  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeLumaMatte.limit_max -> limit_max:   float  "Values higher than this setting are 100% opaque"
#Node|CompositorNode|CompositorNodeLumaMatte.limit_min -> limit_min:   float  "Values lower than this setting are 100% keyed"
#+ * Node|CompositorNode|CompositorNodeMapUV.alpha -> alpha:   int  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeMapValue.max -> max:   float[1]  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeMapValue.min -> min:   float[1]  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeMapValue.offset -> offset:   float[1]  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeMapValue.size -> size:   float[1]  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeMapValue.use_max -> use_max:   boolean  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeMapValue.use_min -> use_min:   boolean  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeMath.operation -> operation:   enum  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeMixRGB.blend_type -> blend_type:   enum  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeMixRGB.use_alpha -> use_alpha:   boolean  "Include alpha of second input in this operation"
#+ * Node|CompositorNode|CompositorNodeOutputFile.exr_codec -> exr_codec:   enum  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeOutputFile.filepath -> filepath:   string  "Output path for the image, same functionality as render output."
#+ * Node|CompositorNode|CompositorNodeOutputFile.frame_end -> frame_end:   int  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeOutputFile.frame_start -> frame_start:   int  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeOutputFile.image_type -> image_type:   enum  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeOutputFile.quality -> quality:   int  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeOutputFile.use_exr_half -> use_exr_half:   boolean  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodePremulKey.mapping -> mapping:   enum  "Conversion between premultiplied alpha and key alpha"
#+ * Node|CompositorNode|CompositorNodeRLayers.layer -> layer:   enum  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeRLayers.scene -> scene:   pointer  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeRotate.filter_type -> filter_type:   enum  "Method to use to filter rotation"
#+ * Node|CompositorNode|CompositorNodeScale.space -> space:   enum  "Coordinate space to scale relative to"
#+ * Node|CompositorNode|CompositorNodeSplitViewer.axis -> axis:   enum  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeSplitViewer.factor -> factor:   int  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeTexture.node_output -> node_output:   int  "For node-based textures, which output node to use"
#+ * Node|CompositorNode|CompositorNodeTexture.texture -> texture:   pointer  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeTime.curve -> curve:   pointer,  "(read-only)"
#Node|CompositorNode|CompositorNodeTime.frame_end -> frame_end:   int  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeTime.frame_start -> frame_start:   int  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeTonemap.adaptation -> adaptation:   float  "If 0, global; if 1, based on pixel intensity"
#+ * Node|CompositorNode|CompositorNodeTonemap.contrast -> contrast:   float  "Set to 0 to use estimate from input image"
#+ * Node|CompositorNode|CompositorNodeTonemap.correction -> correction:   float  "If 0, same for all channels; if 1, each independent"
#+ * Node|CompositorNode|CompositorNodeTonemap.gamma -> gamma:   float  "If not used, set to 1"
#+ * Node|CompositorNode|CompositorNodeTonemap.intensity -> intensity:   float  "If less than zero, darkens image; otherwise, makes it brighter"
#+ * Node|CompositorNode|CompositorNodeTonemap.key -> key:   float  "The value the average luminance is mapped to"
#+ * Node|CompositorNode|CompositorNodeTonemap.offset -> offset:   float  "Normally always 1, but can be used as an extra control to alter the brightness curve"
#+ * Node|CompositorNode|CompositorNodeTonemap.tonemap_type -> tonemap_type:   enum  "NO DESCRIPTION"
#+ * Node|CompositorNode|CompositorNodeValToRGB.color_ramp -> color_ramp:   pointer,  "(read-only)"
#+ * Node|CompositorNode|CompositorNodeVecBlur.factor -> factor:   float  "Scaling factor for motion vectors; actually shutter speed in frames"
#+ * Node|CompositorNode|CompositorNodeVecBlur.samples -> samples:   int  "NO DESCRIPTION"
#Node|CompositorNode|CompositorNodeVecBlur.speed_max -> speed_max:   int  "Maximum speed, or zero for none"
#Node|CompositorNode|CompositorNodeVecBlur.speed_min -> speed_min:   int  "Minimum speed for a pixel to be blurred; used to separate background from foreground"
#Node|CompositorNode|CompositorNodeVecBlur.use_curved -> use_curved:   boolean  "Interpolate between frames in a bezier curve, rather than linearly"
#+ * Node|NodeGroup.nodetree -> nodetree:   pointer  "NO DESCRIPTION"
#+ * Node|ShaderNode.type -> type:   enum,  "(read-only)"
#+ * Node|ShaderNode|ShaderNodeExtendedMaterial.invert_normal -> invert_normal:   boolean  "Material Node uses inverted normal"
#+ * Node|ShaderNode|ShaderNodeExtendedMaterial.material -> material:   pointer  "NO DESCRIPTION"
#Node|ShaderNode|ShaderNodeExtendedMaterial.use_diffuse -> use_diffuse:   boolean  "Material Node outputs Diffuse"
#Node|ShaderNode|ShaderNodeExtendedMaterial.use_specular -> use_specular:   boolean  "Material Node outputs Specular"
#+ * Node|ShaderNode|ShaderNodeGeometry.color_layer -> color_layer:   string  "NO DESCRIPTION"
#+ * Node|ShaderNode|ShaderNodeGeometry.uv_layer -> uv_layer:   string  "NO DESCRIPTION"
#+ * Node|ShaderNode|ShaderNodeMapping.location -> location:   float[3]  "Location offset for the input coordinate"
#Node|ShaderNode|ShaderNodeMapping.max -> max:   float[3]  "Maximum value to clamp coordinate to"
#Node|ShaderNode|ShaderNodeMapping.min -> min:   float[3]  "Minimum value to clamp coordinate to"
#+ * Node|ShaderNode|ShaderNodeMapping.rotation -> rotation:   float[3]  "Rotation offset for the input coordinate"
#+ * Node|ShaderNode|ShaderNodeMapping.scale -> scale:   float[3]  "Scale adjustment for the input coordinate"
#Node|ShaderNode|ShaderNodeMapping.use_max -> use_max:   boolean  "Clamp the output coordinate to a maximum value"
#Node|ShaderNode|ShaderNodeMapping.use_min -> use_min:   boolean  "Clamp the output coordinate to a minimum value"
#+ * Node|ShaderNode|ShaderNodeMaterial.invert_normal -> invert_normal:   boolean  "Material Node uses inverted normal"
#+ * Node|ShaderNode|ShaderNodeMaterial.material -> material:   pointer  "NO DESCRIPTION"
#Node|ShaderNode|ShaderNodeMaterial.use_diffuse -> use_diffuse:   boolean  "Material Node outputs Diffuse"
#Node|ShaderNode|ShaderNodeMaterial.use_specular -> use_specular:   boolean  "Material Node outputs Specular"
#+ * Node|ShaderNode|ShaderNodeMath.operation -> operation:   enum  "NO DESCRIPTION"
#+ * Node|ShaderNode|ShaderNodeMixRGB.blend_type -> blend_type:   enum  "NO DESCRIPTION"
#Node|ShaderNode|ShaderNodeMixRGB.use_alpha -> use_alpha:   boolean  "Include alpha of second input in this operation"
#+ * Node|ShaderNode|ShaderNodeRGBCurve.mapping -> mapping:   pointer,  "(read-only)"
#+ * Node|ShaderNode|ShaderNodeTexture.node_output -> node_output:   int  "For node-based textures, which output node to use"
#+ * Node|ShaderNode|ShaderNodeTexture.texture -> texture:   pointer  "NO DESCRIPTION"
#+ * Node|ShaderNode|ShaderNodeValToRGB.color_ramp -> color_ramp:   pointer,  "(read-only)"
#+ * Node|ShaderNode|ShaderNodeVectorCurve.mapping -> mapping:   pointer,  "(read-only)"
#+ * Node|ShaderNode|ShaderNodeVectorMath.operation -> operation:   enum  "NO DESCRIPTION"
#+ * Node|TextureNode.type -> type:   enum,  "(read-only)"
#+ * Node|TextureNode|TextureNodeBricks.offset -> offset:   float  "NO DESCRIPTION"
#+ * Node|TextureNode|TextureNodeBricks.offset_frequency -> offset_frequency:   int  "Offset every N rows"
#+ * Node|TextureNode|TextureNodeBricks.squash -> squash:   float  "NO DESCRIPTION"
#+ * Node|TextureNode|TextureNodeBricks.squash_frequency -> squash_frequency:   int  "Squash every N rows"
#+ * Node|TextureNode|TextureNodeCurveRGB.mapping -> mapping:   pointer,  "(read-only)"
#+ * Node|TextureNode|TextureNodeCurveTime.curve -> curve:   pointer,  "(read-only)"
#Node|TextureNode|TextureNodeCurveTime.frame_end -> frame_end:   int  "NO DESCRIPTION"
#Node|TextureNode|TextureNodeCurveTime.frame_start -> frame_start:   int  "NO DESCRIPTION"
#+ * Node|TextureNode|TextureNodeImage.image -> image:   pointer  "NO DESCRIPTION"
#+ * Node|TextureNode|TextureNodeMath.operation -> operation:   enum  "NO DESCRIPTION"
#+ * Node|TextureNode|TextureNodeMixRGB.blend_type -> blend_type:   enum  "NO DESCRIPTION"
#Node|TextureNode|TextureNodeMixRGB.use_alpha -> use_alpha:   boolean  "Include alpha of second input in this operation"
#Node|TextureNode|TextureNodeOutput.filepath -> filepath:   string  "NO DESCRIPTION"
#+ * Node|TextureNode|TextureNodeTexture.node_output -> node_output:   int  "For node-based textures, which output node to use"
#+ * Node|TextureNode|TextureNodeTexture.texture -> texture:   pointer  "NO DESCRIPTION"
#+ * Node|TextureNode|TextureNodeValToRGB.color_ramp -> color_ramp:   pointer,  "(read-only)"
#+ * ObjectBase.layers -> layers:   boolean[20]  "Layers the object base is on"
#+ * ObjectBase.object -> object:   pointer,  "(read-only)    Object this base links to"
#+ * ObjectBase.select -> select:   boolean  "Object base selection state"
#+ * ObjectConstraints.active -> active:   pointer  "Active Object constraint"
#+ * Operator.bl_description -> bl_description:   string  "NO DESCRIPTION"
#+ * Operator.bl_idname -> bl_idname:   string  "NO DESCRIPTION"
#+ * Operator.bl_label -> bl_label:   string  "NO DESCRIPTION"
#+ * Operator.bl_options -> bl_options:   enum  "Options for this operator type"
#+ * Operator.has_reports -> has_reports:   boolean,  "(read-only)    Operator has a set of reports (warnings and errors) from last execution"
#+ * Operator.layout -> layout:   pointer,  "(read-only)"
#+ * Operator.name -> name:   string,  "(read-only)"
#+ * Operator.properties -> properties:   pointer,  "(read-only)"
#+ * OperatorTypeMacro.properties -> properties:   pointer,  "(read-only)"
#+ * PackedFile.size -> size:   int,  "(read-only)    Size of packed file in bytes"
#+ * Paint.brush -> brush:   pointer  "Active Brush"
#+ * Paint.show_brush -> show_brush:   boolean  "NO DESCRIPTION"
#+ * Paint.show_brush_on_surface -> show_brush_on_surface:   boolean  "NO DESCRIPTION"
#Paint.show_low_resolution -> show_low_resolution:   boolean  "For multires, show low resolution while navigating the view"
#+ * Paint|ImagePaint.invert_stencil -> invert_stencil:   boolean  "Invert the stencil layer"
#+ * Paint|ImagePaint.normal_angle -> normal_angle:   int  "Paint most on faces pointing towards the view according to this angle"
#+ * Paint|ImagePaint.screen_grab_size -> screen_grab_size:   int[2]  "Size to capture the image for re-projecting"
#+ * Paint|ImagePaint.seam_bleed -> seam_bleed:   int  "Extend paint beyond the faces UVs to reduce seams (in pixels, slower)"
#+ * Paint|ImagePaint.show_brush -> show_brush:   boolean  "Enables brush shape while not drawing"
#+ * Paint|ImagePaint.show_brush_draw -> show_brush_draw:   boolean  "Enables brush shape while drawing"
#Paint|ImagePaint.use_backface_culling -> use_backface_culling:   boolean  "Ignore faces pointing away from the view (faster)"
#+ * Paint|ImagePaint.use_clone_layer -> use_clone_layer:   boolean  "Use another UV layer as clone source, otherwise use 3D the cursor as the source"
#+ * Paint|ImagePaint.use_normal_falloff -> use_normal_falloff:   boolean  "Paint most on faces pointing towards the view"
#+ * Paint|ImagePaint.use_occlude -> use_occlude:   boolean  "Only paint onto the faces directly under the brush (slower)"
#+ * Paint|ImagePaint.use_projection -> use_projection:   boolean  "Use projection painting for improved consistency in the brush strokes"
#+ * Paint|ImagePaint.use_stencil_layer -> use_stencil_layer:   boolean  "Set the mask layer from the UV layer buttons"
#+ * Paint|Sculpt.lock_x -> lock_x:   boolean  "Disallow changes to the X axis of vertices"
#+ * Paint|Sculpt.lock_y -> lock_y:   boolean  "Disallow changes to the Y axis of vertices"
#+ * Paint|Sculpt.lock_z -> lock_z:   boolean  "Disallow changes to the Z axis of vertices"
#Paint|Sculpt.radial_symmetry -> radial_symmetry:   int[3]  "Number of times to copy strokes across the surface"
#+ * Paint|Sculpt.use_symmetry_feather -> use_symmetry_feather:   boolean  "Reduce the strength of the brush where it overlaps symmetrical daubs"
#Paint|Sculpt.use_symmetry_x -> use_symmetry_x:   boolean  "Mirror brush across the X axis"
#Paint|Sculpt.use_symmetry_y -> use_symmetry_y:   boolean  "Mirror brush across the Y axis"
#Paint|Sculpt.use_symmetry_z -> use_symmetry_z:   boolean  "Mirror brush across the Z axis"
#Paint|Sculpt.use_threaded -> use_threaded:   boolean  "Take advantage of multiple CPU cores to improve sculpting performance"
#Paint|VertexPaint.use_all_faces -> use_all_faces:   boolean  "Paint on all faces inside brush"
#Paint|VertexPaint.use_normal -> use_normal:   boolean  "Applies the vertex normal before painting"
#Paint|VertexPaint.use_spray -> use_spray:   boolean  "Keep applying paint effect while holding mouse"
#+ * Panel.bl_context -> bl_context:   string  "The context in which the panel belongs to. (TODO: explain the possible combinations bl_context/bl_region_type/bl_space_type)"
#+ * Panel.bl_idname -> bl_idname:   string  "If this is set, the panel gets a custom ID, otherwise it takes the name of the class used to define the panel. For example, if the class name is OBJECT_PT_hello, and bl_idname is not set by the script, then bl_idname = OBJECT_PT_hello"
#+ * Panel.bl_label -> bl_label:   string  "The panel label, shows up in the panel header at the right of the triangle used to collapse the panel."
#+ * Panel.bl_region_type -> bl_region_type:   enum  "The region where the panel is going to be used in."
#+ * Panel.bl_show_header -> bl_show_header:   boolean  "If set to True, the panel shows a header, which contains a clickable arrow to collapse the panel and the label (see bl_label)."
#+ * Panel.bl_space_type -> bl_space_type:   enum  "The space where the panel is going to be used in."
 + * Panel.bl_default_closed -> bl_use_closed:   boolean  "Defines if the panel has to be open or collapsed at the time of its creation. Note that once the panel has been created with bl_default_closed = True, at reload (F8) it stays open."
#+ * Panel.layout -> layout:   pointer,  "(read-only)    Defines the structure of the panel in the UI."
#TODO SHOULD THIS BE HERE * Panel.text -> text:   string  "XXX todo"
#+ * Particle.alive_state -> alive_state:   enum  "NO DESCRIPTION"
#+ * Particle.angular_velocity -> angular_velocity:   float[3]  "NO DESCRIPTION"
#Particle.birth_time -> birth_time:   float  "NO DESCRIPTION"
#+ * Particle.die_time -> die_time:   float  "NO DESCRIPTION"
#Particle.is_exist -> is_exist:   boolean,  "(read-only)"
#Particle.is_hair -> is_hair:   collection,  "(read-only)"
#+ * Particle.is_visible -> is_visible:   boolean,  "(read-only)"
#+ * Particle.keys -> keys:   collection,  "(read-only)"
#+ * Particle.lifetime -> lifetime:   float  "NO DESCRIPTION"
#+ * Particle.location -> location:   float[3]  "NO DESCRIPTION"
#+ * Particle.prev_angular_velocity -> prev_angular_velocity:   float[3]  "NO DESCRIPTION"
#+ * Particle.prev_location -> prev_location:   float[3]  "NO DESCRIPTION"
#+ * Particle.prev_rotation -> prev_rotation:   float[4]  "NO DESCRIPTION"
#+ * Particle.prev_velocity -> prev_velocity:   float[3]  "NO DESCRIPTION"
#+ * Particle.rotation -> rotation:   float[4]  "NO DESCRIPTION"
#+ * Particle.size -> size:   float  "NO DESCRIPTION"
#+ * Particle.velocity -> velocity:   float[3]  "NO DESCRIPTION"
#+ * ParticleBrush.count -> count:   int  "Particle count"
#+ * ParticleBrush.curve -> curve:   pointer,  "(read-only)"
#+ * ParticleBrush.length_mode -> length_mode:   enum  "NO DESCRIPTION"
#+ * ParticleBrush.puff_mode -> puff_mode:   enum  "NO DESCRIPTION"
#+ * ParticleBrush.size -> size:   int  "Brush size"
#+ * ParticleBrush.steps -> steps:   int  "Brush steps"
#+ * ParticleBrush.strength -> strength:   float  "Brush strength"
#+ * ParticleBrush.use_puff_volume -> use_puff_volume:   boolean  "Apply puff to unselected end-points, (helps maintain hair volume when puffing root)"
#+ * ParticleDupliWeight.count -> count:   int  "The number of times this object is repeated with respect to other objects"
#+ * ParticleDupliWeight.name -> name:   string,  "(read-only)    Particle dupliobject name"
#+ * ParticleEdit.brush -> brush:   pointer,  "(read-only)"
#ParticleEdit.default_key_count -> default_key_count:   int  "How many keys to make new particles with"
#+ * ParticleEdit.draw_step -> draw_step:   int  "How many steps to draw the path with"
#+ * ParticleEdit.emitter_distance -> emitter_distance:   float  "Distance to keep particles away from the emitter"
#+ * ParticleEdit.fade_frames -> fade_frames:   int  "How many frames to fade"
#ParticleEdit.is_editable -> is_editable:   boolean,  "(read-only)    A valid edit mode exists"
#ParticleEdit.is_hair -> is_hair:   boolean,  "(read-only)    Editing hair"
#+ * ParticleEdit.object -> object:   pointer,  "(read-only)    The edited object"
#ParticleEdit.select_mode -> select_mode:   enum  "Particle select and display mode"
#ParticleEdit.show_particles -> show_particles:   boolean  "Draw actual particles"
#+ * ParticleEdit.tool -> tool:   enum  "NO DESCRIPTION"
#+ * ParticleEdit.type -> type:   enum  "NO DESCRIPTION"
#ParticleEdit.use_auto_velocity -> use_auto_velocity:   boolean  "Calculate point velocities automatically"
#ParticleEdit.use_default_interpolate -> use_default_interpolate:   boolean  "Interpolate new particles from the existing ones"
#ParticleEdit.use_emitter_deflect -> use_emitter_deflect:   boolean  "Keep paths from intersecting the emitter"
#ParticleEdit.use_fade_time -> use_fade_time:   boolean  "Fade paths and keys further away from current frame"
#ParticleEdit.use_preserve_length -> use_preserve_length:   boolean  "Keep path lengths constant"
#ParticleEdit.use_preserve_root -> use_preserve_root:   boolean  "Keep root keys unmodified"
#ParticleHairKey.co -> co:   float[3]  "Location of the hair key in object space"
#ParticleHairKey.co_hair_space -> co_hair_space:   float[3]  "Location of the hair key in its internal coordinate system, relative to the emitting face"
#+ * ParticleHairKey.time -> time:   float  "Relative time of key over hair length"
#+ * ParticleHairKey.weight -> weight:   float  "Weight for cloth simulation"
#+ * ParticleKey.angular_velocity -> angular_velocity:   float[3]  "Key angular velocity"
#+ * ParticleKey.location -> location:   float[3]  "Key location"
#+ * ParticleKey.rotation -> rotation:   float[4]  "Key rotation quaterion"
#+ * ParticleKey.time -> time:   float  "Time of key over the simulation"
#+ * ParticleKey.velocity -> velocity:   float[3]  "Key velocity"
#+ * ParticleSystem.active_particle_target -> active_particle_target:   pointer,  "(read-only)"
#+ * ParticleSystem.active_particle_target_index -> active_particle_target_index:   int  "NO DESCRIPTION"
#+ * ParticleSystem.billboard_normal_uv -> billboard_normal_uv:   string  "UV Layer to control billboard normals"
#+ * ParticleSystem.billboard_split_uv -> billboard_split_uv:   string  "UV Layer to control billboard splitting"
#+ * ParticleSystem.billboard_time_index_uv -> billboard_time_index_uv:   string  "UV Layer to control billboard time index (X-Y)"
#+ * ParticleSystem.child_particles -> child_particles:   collection,  "(read-only)    Child particles generated by the particle system"
#+ * ParticleSystem.cloth -> cloth:   pointer,  "(read-only)    Cloth dynamics for hair"
#ParticleSystem.has_multiple_caches -> has_multiple_caches:   boolean,  "(read-only)    Particle system has multiple point caches"
#ParticleSystem.invert_vertex_group_clump -> invert_vertex_group_clump:   boolean  "Negate the effect of the clump vertex group"
#ParticleSystem.invert_vertex_group_density -> invert_vertex_group_density:   boolean  "Negate the effect of the density vertex group"
#ParticleSystem.invert_vertex_group_field -> invert_vertex_group_field:   boolean  "Negate the effect of the field vertex group"
#ParticleSystem.invert_vertex_group_kink -> invert_vertex_group_kink:   boolean  "Negate the effect of the kink vertex group"
#ParticleSystem.invert_vertex_group_length -> invert_vertex_group_length:   boolean  "Negate the effect of the length vertex group"
#ParticleSystem.invert_vertex_group_rotation -> invert_vertex_group_rotation:   boolean  "Negate the effect of the rotation vertex group"
#ParticleSystem.invert_vertex_group_roughness_1 -> invert_vertex_group_roughness_1:   boolean  "Negate the effect of the roughness 1 vertex group"
#ParticleSystem.invert_vertex_group_roughness_2 -> invert_vertex_group_roughness_2:   boolean  "Negate the effect of the roughness 2 vertex group"
#ParticleSystem.invert_vertex_group_roughness_end -> invert_vertex_group_roughness_end:   boolean  "Negate the effect of the roughness end vertex group"
#ParticleSystem.invert_vertex_group_size -> invert_vertex_group_size:   boolean  "Negate the effect of the size vertex group"
#ParticleSystem.invert_vertex_group_tangent -> invert_vertex_group_tangent:   boolean  "Negate the effect of the tangent vertex group"
#ParticleSystem.invert_vertex_group_velocity -> invert_vertex_group_velocity:   boolean  "Negate the effect of the velocity vertex group"
#ParticleSystem.is_editable -> is_editable:   boolean,  "(read-only)    Particle system can be edited in particle mode"
#ParticleSystem.is_edited -> is_edited:   boolean,  "(read-only)    Particle system has been edited in particle mode"
#ParticleSystem.is_global_hair -> is_global_hair:   boolean,  "(read-only)    Hair keys are in global coordinate space"
#+ * ParticleSystem.name -> name:   string  "Particle system name"
#+ * ParticleSystem.parent -> parent:   pointer  "Use this objects coordinate system instead of global coordinate system"
#+ * ParticleSystem.particles -> particles:   collection,  "(read-only)    Particles generated by the particle system"
#+ * ParticleSystem.point_cache -> point_cache:   pointer,  "(read-only)"
#+ * ParticleSystem.reactor_target_object -> reactor_target_object:   pointer  "For reactor systems, the object that has the target particle system (empty if same object)"
#+ * ParticleSystem.reactor_target_particle_system -> reactor_target_particle_system:   int  "For reactor systems, index of particle system on the target object"
#+ * ParticleSystem.seed -> seed:   int  "Offset in the random number table, to get a different randomized result"
#+ * ParticleSystem.settings -> settings:   pointer  "Particle system settings"
#+ * ParticleSystem.targets -> targets:   collection,  "(read-only)    Target particle systems"
#ParticleSystem.use_hair_dynamics -> use_hair_dynamics:   boolean  "Enable hair dynamics using cloth simulation"
#ParticleSystem.use_keyed_timing -> use_keyed_timing:   boolean  "Use key times"
#+ * ParticleSystem.vertex_group_clump -> vertex_group_clump:   string  "Vertex group to control clump"
#+ * ParticleSystem.vertex_group_density -> vertex_group_density:   string  "Vertex group to control density"
#+ * ParticleSystem.vertex_group_field -> vertex_group_field:   string  "Vertex group to control field"
#+ * ParticleSystem.vertex_group_kink -> vertex_group_kink:   string  "Vertex group to control kink"
#+ * ParticleSystem.vertex_group_length -> vertex_group_length:   string  "Vertex group to control length"
#+ * ParticleSystem.vertex_group_rotation -> vertex_group_rotation:   string  "Vertex group to control rotation"
#ParticleSystem.vertex_group_roughness_1 -> vertex_group_roughness_1:   string  "Vertex group to control roughness 1"
#ParticleSystem.vertex_group_roughness_2 -> vertex_group_roughness_2:   string  "Vertex group to control roughness 2"
#+ * ParticleSystem.vertex_group_roughness_end -> vertex_group_roughness_end:   string  "Vertex group to control roughness end"
#+ * ParticleSystem.vertex_group_size -> vertex_group_size:   string  "Vertex group to control size"
#+ * ParticleSystem.vertex_group_tangent -> vertex_group_tangent:   string  "Vertex group to control tangent"
#+ * ParticleSystem.vertex_group_velocity -> vertex_group_velocity:   string  "Vertex group to control velocity"
#ParticleTarget.alliance -> alliance:   enum  "NO DESCRIPTION"
#+ * ParticleTarget.duration -> duration:   float  "NO DESCRIPTION"
#ParticleTarget.is_valid -> is_valid:   boolean  "Keyed particles target is valid"
#+ * ParticleTarget.name -> name:   string,  "(read-only)    Particle target name"
#+ * ParticleTarget.object -> object:   pointer  "The object that has the target particle system (empty if same object)"
#+ * ParticleTarget.system -> system:   int  "The index of particle system on the target object"
#+ * ParticleTarget.time -> time:   float  "NO DESCRIPTION"
#+ * PointCache.active_point_cache_index -> active_point_cache_index:   int  "NO DESCRIPTION"
#+ * PointCache.filepath -> filepath:   string  "Cache file path"
#+ * PointCache.frame_end -> frame_end:   int  "Frame on which the simulation stops"
#+ * PointCache.frame_start -> frame_start:   int  "Frame on which the simulation starts"
#PointCache.frame_step -> frame_step:   int  "Number of frames between cached frames"
#+ * PointCache.frames_skipped -> frames_skipped:   boolean,  "(read-only)"
#+ * PointCache.index -> index:   int  "Index number of cache files"
#+ * PointCache.info -> info:   string,  "(read-only)    Info on current cache status"
#PointCache.is_baked -> is_baked:   boolean,  "(read-only)"
#PointCache.is_baking -> is_baking:   boolean,  "(read-only)"
#PointCache.is_outdated -> is_outdated:   boolean,  "(read-only)"
#+ * PointCache.name -> name:   string  "Cache name"
#PointCache.point_caches -> point_caches:   collection,  "(read-only)    Point cache list"
#PointCache.use_disk_cache -> use_disk_cache:   boolean  "Save cache files to disk (.blend file must be saved first)"
#PointCache.use_external -> use_external:   boolean  "Read cache from an external location"
#+ * PointCache.use_library_path -> use_library_path:   boolean  "Use this files path when library linked into another file."
#PointCache.use_quick_cache -> use_quick_cache:   boolean  "Update simulation with cache steps"
#+ * PointDensity.color_ramp -> color_ramp:   pointer,  "(read-only)"
#+ * PointDensity.color_source -> color_source:   enum  "Data to derive color results from"
#+ * PointDensity.falloff -> falloff:   enum  "Method of attenuating density by distance from the point"
#PointDensity.falloff_soft -> falloff_soft:   float  "Softness of the soft falloff option"
#+ * PointDensity.noise_basis -> noise_basis:   enum  "Noise formula used for turbulence"
#+ * PointDensity.object -> object:   pointer  "Object to take point data from"
#PointDensity.particle_cache_space -> particle_cache_space:   enum  "Co-ordinate system to cache particles in"
#+ * PointDensity.particle_system -> particle_system:   pointer  "Particle System to render as points"
#+ * PointDensity.point_source -> point_source:   enum  "Point data to use as renderable point density"
#+ * PointDensity.radius -> radius:   float  "Radius from the shaded sample to look for points within"
#+ * PointDensity.speed_scale -> speed_scale:   float  "Multiplier to bring particle speed within an acceptable range"
#+ * PointDensity.turbulence_depth -> turbulence_depth:   int  "Level of detail in the added turbulent noise"
#+ * PointDensity.turbulence_influence -> turbulence_influence:   enum  "Method for driving added turbulent noise"
#PointDensity.turbulence_scale -> turbulence_scale:   float  "Scale of the added turbulent noise"
#+ * PointDensity.turbulence_strength -> turbulence_strength:   float  "NO DESCRIPTION"
#PointDensity.use_turbulence -> use_turbulence:   boolean  "Add directed noise to the density at render-time"
#PointDensity.vertex_cache_space -> vertex_cache_space:   enum  "Co-ordinate system to cache vertices in"
#+ * Pose.active_bone_group_index -> active_bone_group_index:   int  "Active index in bone groups array"
#+ * Pose.animation_visualisation -> animation_visualisation:   pointer,  "(read-only)    Animation data for this datablock"
#+ * Pose.bone_groups -> bone_groups:   collection,  "(read-only)    Groups of the bones"
#+ * Pose.bones -> bones:   collection,  "(read-only)    Individual pose bones for the armature"
#+ * Pose.ik_param -> ik_param:   pointer,  "(read-only)    Parameters for IK solver"
#+ * Pose.ik_solver -> ik_solver:   enum  "Selection of IK solver for IK chain, current choice is 0 for Legacy, 1 for iTaSC"
#+ * PoseBone.bone -> bone:   pointer,  "(read-only)    Bone associated with this PoseBone"
#+ * PoseBone.bone_group -> bone_group:   pointer  "Bone Group this pose channel belongs to"
#+ * PoseBone.bone_group_index -> bone_group_index:   int  "Bone Group this pose channel belongs to (0=no group)"
#+ * PoseBone.child -> child:   pointer,  "(read-only)    Child of this pose bone"
#+ * PoseBone.constraints -> constraints:   collection,  "(read-only)    Constraints that act on this PoseChannel"
#+ * PoseBone.custom_shape -> custom_shape:   pointer  "Object that defines custom draw type for this bone"
#+ * PoseBone.custom_shape_transform -> custom_shape_transform:   pointer  "Bone that defines the display transform of this custom shape"
#+ * PoseBone.head -> head:   float[3],  "(read-only)    Location of head of the channels bone"
#PoseBone.ik_linear_weight -> ik_linear_weight:   float  "Weight of scale constraint for IK"
#+ * PoseBone.ik_max_x -> ik_max_x:   float  "Maximum angles for IK Limit"
#+ * PoseBone.ik_max_y -> ik_max_y:   float  "Maximum angles for IK Limit"
#+ * PoseBone.ik_max_z -> ik_max_z:   float  "Maximum angles for IK Limit"
#+ * PoseBone.ik_min_x -> ik_min_x:   float  "Minimum angles for IK Limit"
#+ * PoseBone.ik_min_y -> ik_min_y:   float  "Minimum angles for IK Limit"
#+ * PoseBone.ik_min_z -> ik_min_z:   float  "Minimum angles for IK Limit"
#PoseBone.ik_rotation_weight -> ik_rotation_weight:   float  "Weight of rotation constraint for IK"
#+ * PoseBone.ik_stiffness_x -> ik_stiffness_x:   float  "IK stiffness around the X axis"
#+ * PoseBone.ik_stiffness_y -> ik_stiffness_y:   float  "IK stiffness around the Y axis"
#+ * PoseBone.ik_stiffness_z -> ik_stiffness_z:   float  "IK stiffness around the Z axis"
#+ * PoseBone.ik_stretch -> ik_stretch:   float  "Allow scaling of the bone for IK"
#PoseBone.is_in_ik_chain -> is_in_ik_chain:   boolean,  "(read-only)    Is part of an IK chain"
#+ * PoseBone.location -> location:   float[3]  "NO DESCRIPTION"
#PoseBone.lock_ik_x -> lock_ik_x:   boolean  "Disallow movement around the X axis"
#PoseBone.lock_ik_y -> lock_ik_y:   boolean  "Disallow movement around the Y axis"
#PoseBone.lock_ik_z -> lock_ik_z:   boolean  "Disallow movement around the Z axis"
#+ * PoseBone.lock_location -> lock_location:   boolean[3]  "Lock editing of location in the interface"
#+ * PoseBone.lock_rotation -> lock_rotation:   boolean[3]  "Lock editing of rotation in the interface"
#+ * PoseBone.lock_rotation_w -> lock_rotation_w:   boolean  "Lock editing of angle component of four-component rotations in the interface"
#+ * PoseBone.lock_rotations_4d -> lock_rotations_4d:   boolean  "Lock editing of four component rotations by components (instead of as Eulers)"
#+ * PoseBone.lock_scale -> lock_scale:   boolean[3]  "Lock editing of scale in the interface"
#+ * PoseBone.matrix -> matrix:   float[16],  "(read-only)    Final 4x4 matrix for this channel"
#+ * PoseBone.matrix_channel -> matrix_channel:   float[16],  "(read-only)    4x4 matrix, before constraints"
#+ * PoseBone.matrix_local -> matrix_local:   float[16]  "Matrix representing the parent relative location, scale and rotation. Provides an alternative access to these properties."
#+ * PoseBone.motion_path -> motion_path:   pointer,  "(read-only)    Motion Path for this element"
#+ * PoseBone.name -> name:   string  "NO DESCRIPTION"
#+ * PoseBone.parent -> parent:   pointer,  "(read-only)    Parent of this pose bone"
#+ * PoseBone.rotation_axis_angle -> rotation_axis_angle:   float[4]  "Angle of Rotation for Axis-Angle rotation representation"
#+ * PoseBone.rotation_euler -> rotation_euler:   float[3]  "Rotation in Eulers"
#+ * PoseBone.rotation_mode -> rotation_mode:   enum  "NO DESCRIPTION"
#+ * PoseBone.rotation_quaternion -> rotation_quaternion:   float[4]  "Rotation in Quaternions"
#+ * PoseBone.scale -> scale:   float[3]  "NO DESCRIPTION"
#+ * PoseBone.select -> select:   boolean  "NO DESCRIPTION"
#+ * PoseBone.tail -> tail:   float[3],  "(read-only)    Location of tail of the channels bone"
#PoseBone.use_ik_limit_x -> use_ik_limit_x:   boolean  "Limit movement around the X axis"
#PoseBone.use_ik_limit_y -> use_ik_limit_y:   boolean  "Limit movement around the Y axis"
#PoseBone.use_ik_limit_z -> use_ik_limit_z:   boolean  "Limit movement around the Z axis"
#PoseBone.use_ik_linear_control -> use_ik_linear_control:   boolean  "Apply channel size as IK constraint if stretching is enabled"
#PoseBone.use_ik_rotation_control -> use_ik_rotation_control:   boolean  "Apply channel rotation as IK constraint"
#+ * PoseBoneConstraints.active -> active:   pointer  "Active PoseChannel constraint"
#+ * Property.description -> description:   string,  "(read-only)    Description of the property for tooltips"
#+ * Property.identifier -> identifier:   string,  "(read-only)    Unique name used in the code and scripting"
#+ * Property.is_never_none -> is_never_none:   boolean,  "(read-only)    True when this value cant be set to None"
#Property.is_output -> is_output:   boolean,  "(read-only)    True when this property is an output value from an RNA function"
#+ * Property.is_readonly -> is_readonly:   boolean,  "(read-only)    Property is editable through RNA"
#Property.is_registered -> is_registered:   boolean,  "(read-only)    Property is registered as part of type registration"
#Property.is_registered_optional -> is_registered_optional:   boolean,  "(read-only)    Property is optionally registered as part of type registration"
#+ * Property.is_required -> is_required:   boolean,  "(read-only)    False when this property is an optional argument in an RNA function"
#+ * Property.name -> name:   string,  "(read-only)    Human readable name"
#+ * Property.srna -> srna:   pointer,  "(read-only)    Struct definition used for properties assigned to this item"
#+ * Property.subtype -> subtype:   enum,  "(read-only)    Semantic interpretation of the property"
#+ * Property.type -> type:   enum,  "(read-only)    Data type of the property"
#+ * Property.unit -> unit:   enum,  "(read-only)    Type of units for this property"
#+ * Property|BooleanProperty.array_length -> array_length:   int,  "(read-only)    Maximum length of the array, 0 means unlimited"
#+ * Property|BooleanProperty.default -> default:   boolean,  "(read-only)    Default value for this number"
#+ * Property|BooleanProperty.default_array -> default_array:   boolean[3],  "(read-only)    Default value for this array"
#+ * Property|CollectionProperty.fixed_type -> fixed_type:   pointer,  "(read-only)    Fixed pointer type, empty if variable type"
#+ * Property|EnumProperty.default -> default:   enum,  "(read-only)    Default value for this enum"
#+ * Property|EnumProperty.items -> items:   collection,  "(read-only)    Possible values for the property"
#+ * Property|FloatProperty.array_length -> array_length:   int,  "(read-only)    Maximum length of the array, 0 means unlimited"
#+ * Property|FloatProperty.default -> default:   float,  "(read-only)    Default value for this number"
#+ * Property|FloatProperty.default_array -> default_array:   float[3],  "(read-only)    Default value for this array"
#+ * Property|FloatProperty.hard_max -> hard_max:   float,  "(read-only)    Maximum value used by buttons"
#+ * Property|FloatProperty.hard_min -> hard_min:   float,  "(read-only)    Minimum value used by buttons"
#+ * Property|FloatProperty.precision -> precision:   int,  "(read-only)    Number of digits after the dot used by buttons"
#+ * Property|FloatProperty.soft_max -> soft_max:   float,  "(read-only)    Maximum value used by buttons"
#+ * Property|FloatProperty.soft_min -> soft_min:   float,  "(read-only)    Minimum value used by buttons"
#+ * Property|FloatProperty.step -> step:   float,  "(read-only)    Step size used by number buttons, for floats 1/100th of the step size"
#+ * Property|IntProperty.array_length -> array_length:   int,  "(read-only)    Maximum length of the array, 0 means unlimited"
#+ * Property|IntProperty.default -> default:   int,  "(read-only)    Default value for this number"
#+ * Property|IntProperty.default_array -> default_array:   int[3],  "(read-only)    Default value for this array"
#+ * Property|IntProperty.hard_max -> hard_max:   int,  "(read-only)    Maximum value used by buttons"
#+ * Property|IntProperty.hard_min -> hard_min:   int,  "(read-only)    Minimum value used by buttons"
#+ * Property|IntProperty.soft_max -> soft_max:   int,  "(read-only)    Maximum value used by buttons"
#+ * Property|IntProperty.soft_min -> soft_min:   int,  "(read-only)    Minimum value used by buttons"
#+ * Property|IntProperty.step -> step:   int,  "(read-only)    Step size used by number buttons, for floats 1/100th of the step size"
#+ * Property|PointerProperty.fixed_type -> fixed_type:   pointer,  "(read-only)    Fixed pointer type, empty if variable type"
#+ * Property|StringProperty.default -> default:   string,  "(read-only)    string default value"
#Property|StringProperty.length_max -> length_max:   int,  "(read-only)    Maximum length of the string, 0 means unlimited"
#+ * RGBANodeSocket.default_value -> default_value:   float[4]  "Default value of the socket when no link is attached"
#+ * RGBANodeSocket.name -> name:   string,  "(read-only)    Socket name"
#+ * Region.height -> height:   int,  "(read-only)    Region height"
#+ * Region.id -> id:   int,  "(read-only)    Unique ID for this region"
#+ * Region.type -> type:   enum,  "(read-only)    Type of this region"
#+ * Region.width -> width:   int,  "(read-only)    Region width"
#+ * RegionView3D.lock_rotation -> lock_rotation:   boolean  "Lock view rotation in side views"
#+ * RegionView3D.perspective_matrix -> perspective_matrix:   float[16],  "(read-only)    Current perspective matrix of the 3D region"
#RegionView3D.show_sync_view -> show_sync_view:   boolean  "Sync view position between side views"
#RegionView3D.use_box_clip -> use_box_clip:   boolean  "Clip objects based on whats visible in other side views"
#+ * RegionView3D.view_distance -> view_distance:   float  "Distance to the view location"
#+ * RegionView3D.view_location -> view_location:   float[3]  "View pivot location"
#+ * RegionView3D.view_matrix -> view_matrix:   float[16],  "(read-only)    Current view matrix of the 3D region"
#+ * RegionView3D.view_perspective -> view_perspective:   enum  "View Perspective"
#RegionView3D.view_rotate_method -> view_rotate_method:   float[4]  "Rotation in quaternions (keep normalized)"
#+ * RenderEngine.bl_idname -> bl_idname:   string  "NO DESCRIPTION"
#+ * RenderEngine.bl_label -> bl_label:   string  "NO DESCRIPTION"
#RenderEngine.bl_use_postprocess -> bl_use_postprocess:   boolean  "NO DESCRIPTION"
#RenderEngine.bl_use_preview -> bl_use_preview:   boolean  "NO DESCRIPTION"
#RenderLayer.exclude_ambient_occlusion -> exclude_ambient_occlusion:   boolean,  "(read-only)    Exclude AO pass from combined"
#RenderLayer.exclude_emit -> exclude_emit:   boolean,  "(read-only)    Exclude emission pass from combined"
#RenderLayer.exclude_environment -> exclude_environment:   boolean,  "(read-only)    Exclude environment pass from combined"
#RenderLayer.exclude_indirect -> exclude_indirect:   boolean,  "(read-only)    Exclude indirect pass from combined"
#RenderLayer.exclude_reflection -> exclude_reflection:   boolean,  "(read-only)    Exclude raytraced reflection pass from combined"
#RenderLayer.exclude_refraction -> exclude_refraction:   boolean,  "(read-only)    Exclude raytraced refraction pass from combined"
#RenderLayer.exclude_shadow -> exclude_shadow:   boolean,  "(read-only)    Exclude shadow pass from combined"
#RenderLayer.exclude_specular -> exclude_specular:   boolean,  "(read-only)    Exclude specular pass from combined"
#RenderLayer.invert_zmask -> invert_zmask:   boolean,  "(read-only)    For Zmask, only render what is behind solid z values instead of in front"
#RenderLayer.layers -> layers:   boolean[20],  "(read-only)    Scene layers included in this render layer"
#RenderLayer.layers_zmask -> layers_zmask:   boolean[20],  "(read-only)    Zmask scene layers"
#+ * RenderLayer.light_override -> light_override:   pointer,  "(read-only)    Group to override all other lights in this render layer"
#+ * RenderLayer.material_override -> material_override:   pointer,  "(read-only)    Material to override all other materials in this render layer"
#+ * RenderLayer.name -> name:   string,  "(read-only)    Render layer name"
#+ * RenderLayer.passes -> passes:   collection,  "(read-only)"
#+ * RenderLayer.rect -> rect:   float  "NO DESCRIPTION"
#+ * RenderLayer.use -> use:   boolean,  "(read-only)    Disable or enable the render layer"
#RenderLayer.use_all_z -> use_all_z:   boolean,  "(read-only)    Fill in Z values for solid faces in invisible layers, for masking"
#RenderLayer.use_edge_enhance -> use_edge_enhance:   boolean,  "(read-only)    Render Edge-enhance in this Layer (only works for Solid faces)"
#RenderLayer.use_halo -> use_halo:   boolean,  "(read-only)    Render Halos in this Layer (on top of Solid)"
#RenderLayer.use_pass_ambient_occlusion -> use_pass_ambient_occlusion:   boolean,  "(read-only)    Deliver AO pass"
#RenderLayer.use_pass_color -> use_pass_color:   boolean,  "(read-only)    Deliver shade-less color pass"
#RenderLayer.use_pass_combined -> use_pass_combined:   boolean,  "(read-only)    Deliver full combined RGBA buffer"
#RenderLayer.use_pass_diffuse -> use_pass_diffuse:   boolean,  "(read-only)    Deliver diffuse pass"
#RenderLayer.use_pass_emit -> use_pass_emit:   boolean,  "(read-only)    Deliver emission pass"
#RenderLayer.use_pass_environment -> use_pass_environment:   boolean,  "(read-only)    Deliver environment lighting pass"
#RenderLayer.use_pass_indirect -> use_pass_indirect:   boolean,  "(read-only)    Deliver indirect lighting pass"
#RenderLayer.use_pass_mist -> use_pass_mist:   boolean,  "(read-only)    Deliver mist factor pass (0.0-1.0)"
#RenderLayer.use_pass_normal -> use_pass_normal:   boolean,  "(read-only)    Deliver normal pass"
#RenderLayer.use_pass_object_index -> use_pass_object_index:   boolean,  "(read-only)    Deliver object index pass"
#RenderLayer.use_pass_reflection -> use_pass_reflection:   boolean,  "(read-only)    Deliver raytraced reflection pass"
#RenderLayer.use_pass_refraction -> use_pass_refraction:   boolean,  "(read-only)    Deliver raytraced refraction pass"
#RenderLayer.use_pass_shadow -> use_pass_shadow:   boolean,  "(read-only)    Deliver shadow pass"
#RenderLayer.use_pass_specular -> use_pass_specular:   boolean,  "(read-only)    Deliver specular pass"
#RenderLayer.use_pass_uv -> use_pass_uv:   boolean,  "(read-only)    Deliver texture UV pass"
#RenderLayer.use_pass_vector -> use_pass_vector:   boolean,  "(read-only)    Deliver speed vector pass"
#RenderLayer.use_pass_z -> use_pass_z:   boolean,  "(read-only)    Deliver Z values pass"
#RenderLayer.use_sky -> use_sky:   boolean,  "(read-only)    Render Sky in this Layer"
#RenderLayer.use_solid -> use_solid:   boolean,  "(read-only)    Render Solid faces in this Layer"
#RenderLayer.use_strand -> use_strand:   boolean,  "(read-only)    Render Strands in this Layer"
#RenderLayer.use_zmask -> use_zmask:   boolean,  "(read-only)    Only render whats in front of the solid z values"
#RenderLayer.use_ztransp -> use_ztransp:   boolean,  "(read-only)    Render Z-Transparent faces in this Layer (On top of Solid and Halos)"
#+ * RenderPass.channel_id -> channel_id:   string,  "(read-only)"
#+ * RenderPass.channels -> channels:   int,  "(read-only)"
#+ * RenderPass.name -> name:   string,  "(read-only)"
#+ * RenderPass.rect -> rect:   float  "NO DESCRIPTION"
#+ * RenderPass.type -> type:   enum,  "(read-only)"
#+ * RenderResult.layers -> layers:   collection,  "(read-only)"
#+ * RenderResult.resolution_x -> resolution_x:   int,  "(read-only)"
#+ * RenderResult.resolution_y -> resolution_y:   int,  "(read-only)"
#+ * RenderSettings.active_layer_index -> active_layer_index:   int  "Active index in render layer array"
#+ * RenderSettings.alpha_mode -> alpha_mode:   enum  "Representation of alpha information in the RGBA pixels"
#+ * RenderSettings.antialiasing_samples -> antialiasing_samples:   enum  "Amount of anti-aliasing samples per pixel"
#+ * RenderSettings.bake_aa_mode -> bake_aa_mode:   enum  "NO DESCRIPTION"
#+ * RenderSettings.bake_bias -> bake_bias:   float  "Bias towards faces further away from the object (in blender units)"
#+ * RenderSettings.bake_distance -> bake_distance:   float  "Maximum distance from active object to other object (in blender units"
#+ * RenderSettings.bake_margin -> bake_margin:   int  "Amount of pixels to extend the baked result with, as post process filter"
#+ * RenderSettings.bake_normal_space -> bake_normal_space:   enum  "Choose normal space for baking"
#+ * RenderSettings.bake_quad_split -> bake_quad_split:   enum  "Choose the method used to split a quad into 2 triangles for baking"
#+ * RenderSettings.bake_type -> bake_type:   enum  "Choose shading information to bake into the image"
#+ * RenderSettings.border_max_x -> border_max_x:   float  "Sets maximum X value for the render border"
#+ * RenderSettings.border_max_y -> border_max_y:   float  "Sets maximum Y value for the render border"
#+ * RenderSettings.border_min_x -> border_min_x:   float  "Sets minimum X value to for the render border"
#+ * RenderSettings.border_min_y -> border_min_y:   float  "Sets minimum Y value for the render border"
#+ * RenderSettings.cineon_black -> cineon_black:   int  "Log conversion reference blackpoint"
#+ * RenderSettings.cineon_gamma -> cineon_gamma:   float  "Log conversion gamma"
#+ * RenderSettings.cineon_white -> cineon_white:   int  "Log conversion reference whitepoint"
#+ * RenderSettings.color_mode -> color_mode:   enum  "Choose BW for saving greyscale images, RGB for saving red, green and blue channels, AND RGBA for saving red, green, blue + alpha channels"
#+ * RenderSettings.display_mode -> display_mode:   enum  "Select where rendered images will be displayed"
#+ * RenderSettings.dither_intensity -> dither_intensity:   float  "Amount of dithering noise added to the rendered image to break up banding"
#+ * RenderSettings.edge_color -> edge_color:   float[3]  "NO DESCRIPTION"
#+ * RenderSettings.edge_threshold -> edge_threshold:   int  "Threshold for drawing outlines on geometry edges"
#+ * RenderSettings.engine -> engine:   enum  "Engine to use for rendering"
#+ * RenderSettings.field_order -> field_order:   enum  "Order of video fields. Select which lines get rendered first, to create smooth motion for TV output"
#+ * RenderSettings.file_extension -> file_extension:   string,  "(read-only)    The file extension used for saving renders"
#+ * RenderSettings.file_format -> file_format:   enum  "File format to save the rendered images as"
#+ * RenderSettings.file_quality -> file_quality:   int  "Quality of JPEG images, AVI Jpeg and SGI movies, Compression for PNGs"
#RenderSettings.filepath -> filepath:   string  "Directory/name to save animations, # characters defines the position and length of frame numbers"
#+ * RenderSettings.filter_size -> filter_size:   float  "Pixel width over which the reconstruction filter combines samples"
#+ * RenderSettings.fps -> fps:   int  "Framerate, expressed in frames per second"
#+ * RenderSettings.fps_base -> fps_base:   float  "Framerate base"
#RenderSettings.has_multiple_engines -> has_multiple_engines:   boolean,  "(read-only)    More than one rendering engine is available"
#+ * RenderSettings.is_movie_format -> is_movie_format:   boolean,  "(read-only)    When true the format is a movie"
#+ * RenderSettings.layers -> layers:   collection,  "(read-only)"
#+ * RenderSettings.motion_blur_samples -> motion_blur_samples:   int  "Number of scene samples to take with motion blur"
#+ * RenderSettings.motion_blur_shutter -> motion_blur_shutter:   float  "Time taken in frames between shutter open and close"
#+ * RenderSettings.octree_resolution -> octree_resolution:   enum  "Resolution of raytrace accelerator. Use higher resolutions for larger scenes"
#+ * RenderSettings.parts_x -> parts_x:   int  "Number of horizontal tiles to use while rendering"
#+ * RenderSettings.parts_y -> parts_y:   int  "Number of vertical tiles to use while rendering"
#+ * RenderSettings.pixel_aspect_x -> pixel_aspect_x:   float  "Horizontal aspect ratio - for anamorphic or non-square pixel output"
#+ * RenderSettings.pixel_aspect_y -> pixel_aspect_y:   float  "Vertical aspect ratio - for anamorphic or non-square pixel output"
#RenderSettings.pixel_filter_type -> pixel_filter_type:   enum  "Reconstruction filter used for combining anti-aliasing samples"
#RenderSettings.raytrace_method -> raytrace_method:   enum  "Type of raytrace accelerator structure"
#+ * RenderSettings.resolution_percentage -> resolution_percentage:   int  "Percentage scale for render resolution"
#+ * RenderSettings.resolution_x -> resolution_x:   int  "Number of horizontal pixels in the rendered image"
#+ * RenderSettings.resolution_y -> resolution_y:   int  "Number of vertical pixels in the rendered image"
#+ * RenderSettings.sequencer_gl_preview -> sequencer_gl_preview:   enum  "Method to draw in the sequencer view"
#+ * RenderSettings.sequencer_gl_render -> sequencer_gl_render:   enum  "Method to draw in the sequencer view"
#+ * RenderSettings.simplify_ao_sss -> simplify_ao_sss:   float  "Global approximate AA and SSS quality factor"
#+ * RenderSettings.simplify_child_particles -> simplify_child_particles:   float  "Global child particles percentage"
#+ * RenderSettings.simplify_shadow_samples -> simplify_shadow_samples:   int  "Global maximum shadow samples"
#+ * RenderSettings.simplify_subdivision -> simplify_subdivision:   int  "Global maximum subdivision level"
#+ * RenderSettings.stamp_background -> stamp_background:   float[4]  "Color to use behind stamp text"
#+ * RenderSettings.stamp_font_size -> stamp_font_size:   int  "Size of the font used when rendering stamp text"
#+ * RenderSettings.stamp_foreground -> stamp_foreground:   float[4]  "Color to use for stamp text"
#+ * RenderSettings.stamp_note_text -> stamp_note_text:   string  "Custom text to appear in the stamp note"
#+ * RenderSettings.threads -> threads:   int  "Number of CPU threads to use simultaneously while rendering (for multi-core/CPU systems)"
#+ * RenderSettings.threads_mode -> threads_mode:   enum  "Determine the amount of render threads used"
#RenderSettings.use_antialiasing -> use_antialiasing:   boolean  "Render and combine multiple samples per pixel to prevent jagged edges"
#RenderSettings.use_backbuf -> use_backbuf:   boolean  "Render backbuffer image"
#RenderSettings.use_bake_antialiasing -> use_bake_antialiasing:   boolean  "Enables Anti-aliasing"
#RenderSettings.use_bake_clear -> use_bake_clear:   boolean  "Clear Images before baking"
#RenderSettings.use_bake_normalize -> use_bake_normalize:   boolean  "With displacement normalize to the distance, with ambient occlusion normalize without using material settings"
#RenderSettings.use_bake_selected_to_active -> use_bake_selected_to_active:   boolean  "Bake shading on the surface of selected objects to the active object"
#+ * RenderSettings.use_border -> use_border:   boolean  "Render a user-defined border region, within the frame size. Note, this disables save_buffers and full_sample"
#RenderSettings.use_cineon_log -> use_cineon_log:   boolean  "Convert to logarithmic color space"
#RenderSettings.use_color_management -> use_color_management:   boolean  "Use linear workflow - gamma corrected imaging pipeline"
#+ * RenderSettings.use_compositing -> use_compositing:   boolean  "Process the render result through the compositing pipeline, if compositing nodes are enabled"
#RenderSettings.use_crop_to_border -> use_crop_to_border:   boolean  "Crop the rendered frame to the defined border size"
#RenderSettings.use_edge_enhance -> use_edge_enhance:   boolean  "Create a toon outline around the edges of geometry"
#+ * RenderSettings.use_envmaps -> use_envmaps:   boolean  "Calculate environment maps while rendering"
#RenderSettings.use_fields -> use_fields:   boolean  "Render image to two fields per frame, for interlaced TV output"
#RenderSettings.use_fields_still -> use_fields_still:   boolean  "Disable the time difference between fields"
#+ * RenderSettings.use_file_extension -> use_file_extension:   boolean  "Add the file format extensions to the rendered file name (eg: filename + .jpg)"
#RenderSettings.use_free_image_textures -> use_free_image_textures:   boolean  "Free all image texture from memory after render, to save memory before compositing"
#RenderSettings.use_free_unused_nodes -> use_free_unused_nodes:   boolean  "Free Nodes that are not used while compositing, to save memory"
#RenderSettings.use_full_sample -> use_full_sample:   boolean  "Save for every anti-aliasing sample the entire RenderLayer results. This solves anti-aliasing issues with compositing"
#+ * RenderSettings.use_game_engine -> use_game_engine:   boolean,  "(read-only)    Current rendering engine is a game engine"
#+ * RenderSettings.use_instances -> use_instances:   boolean  "Instance support leads to effective memory reduction when using duplicates"
#+ * RenderSettings.use_local_coords -> use_local_coords:   boolean  "Vertex coordinates are stored localy on each primitive. Increases memory usage, but may have impact on speed"
#RenderSettings.use_motion_blur -> use_motion_blur:   boolean  "Use multi-sampled 3D scene motion blur"
#+ * RenderSettings.use_overwrite -> use_overwrite:   boolean  "Overwrite existing files while rendering"
#+ * RenderSettings.use_placeholder -> use_placeholder:   boolean  "Create empty placeholder files while rendering frames (similar to Unix touch)"
#+ * RenderSettings.use_radiosity -> use_radiosity:   boolean  "Calculate radiosity in a pre-process before rendering"
#RenderSettings.use_raytrace -> use_raytrace:   boolean  "Pre-calculate the raytrace accelerator and render raytracing effects"
#RenderSettings.use_save_buffers -> use_save_buffers:   boolean  "Save tiles for all RenderLayers and SceneNodes to files in the temp directory (saves memory, required for Full Sample)"
#+ * RenderSettings.use_sequencer -> use_sequencer:   boolean  "Process the render (and composited) result through the video sequence editor pipeline, if sequencer strips exist"
#+ * RenderSettings.use_sequencer_gl_preview -> use_sequencer_gl_preview:   boolean  "NO DESCRIPTION"
#+ * RenderSettings.use_sequencer_gl_render -> use_sequencer_gl_render:   boolean  "NO DESCRIPTION"
#+ * RenderSettings.use_shadows -> use_shadows:   boolean  "Calculate shadows while rendering"
#+ * RenderSettings.use_simplify -> use_simplify:   boolean  "Enable simplification of scene for quicker preview renders"
#RenderSettings.use_simplify_triangulate -> use_simplify_triangulate:   boolean  "Disables non-planer quads being triangulated"
#RenderSettings.use_single_layer -> use_single_layer:   boolean  "Only render the active layer"
#+ * RenderSettings.use_sss -> use_sss:   boolean  "Calculate sub-surface scattering in materials rendering"
#RenderSettings.use_stamp -> use_stamp:   boolean  "Render the stamp info text in the rendered image"
#RenderSettings.use_stamp_camera -> use_stamp_camera:   boolean  "Include the name of the active camera in image metadata"
#RenderSettings.use_stamp_date -> use_stamp_date:   boolean  "Include the current date in image metadata"
#RenderSettings.use_stamp_filename -> use_stamp_filename:   boolean  "Include the filename of the .blend file in image metadata"
#RenderSettings.use_stamp_frame -> use_stamp_frame:   boolean  "Include the frame number in image metadata"
#RenderSettings.use_stamp_marker -> use_stamp_marker:   boolean  "Include the name of the last marker in image metadata"
#RenderSettings.use_stamp_note -> use_stamp_note:   boolean  "Include a custom note in image metadata"
#RenderSettings.use_stamp_render_time -> use_stamp_render_time:   boolean  "Include the render time in the stamp image"
#RenderSettings.use_stamp_scene -> use_stamp_scene:   boolean  "Include the name of the active scene in image metadata"
#RenderSettings.use_stamp_sequencer_strip -> use_stamp_sequencer_strip:   boolean  "Include the name of the foreground sequence strip in image metadata"
#RenderSettings.use_stamp_time -> use_stamp_time:   boolean  "Include the render frame as HH:MM:SS.FF in image metadata"
#+ * RenderSettings.use_textures -> use_textures:   boolean  "Use textures to affect material properties"
#RenderSettings.use_tiff_16bit -> use_tiff_16bit:   boolean  "Save TIFF with 16 bits per channel"
#+ * SPHFluidSettings.buoyancy -> buoyancy:   float  "NO DESCRIPTION"
#+ * SPHFluidSettings.fluid_radius -> fluid_radius:   float  "Fluid interaction Radius"
#+ * SPHFluidSettings.rest_density -> rest_density:   float  "Density"
#+ * SPHFluidSettings.rest_length -> rest_length:   float  "The Spring Rest Length (factor of interaction radius)"
#SPHFluidSettings.spring_force -> spring_force:   float  "Spring force constant"
#SPHFluidSettings.stiffness -> stiffness:   float  "Constant K - Stiffness"
#SPHFluidSettings.stiffness_near -> stiffness_near:   float  "Repulsion factor: stiffness_knear"
#+ * SPHFluidSettings.viscosity_beta -> viscosity_beta:   float  "Square viscosity factor"
#+ * SPHFluidSettings.viscosity_omega -> viscosity_omega:   float  "Linear viscosity"
#+ * SceneBases.active -> active:   pointer  "Active object base in the scene"
#+ * SceneGameData.activity_culling_box_radius -> activity_culling_box_radius:   float  "Radius of the activity bubble, in Manhattan length. Objects outside the box are activity-culled"
#+ * SceneGameData.depth -> depth:   int  "Displays bit depth of full screen display"
#+ * SceneGameData.dome_angle -> dome_angle:   int  "Field of View of the Dome - it only works in mode Fisheye and Truncated"
#+ * SceneGameData.dome_buffer_resolution -> dome_buffer_resolution:   float  "Buffer Resolution - decrease it to increase speed"
#+ * SceneGameData.dome_mode -> dome_mode:   enum  "Dome physical configurations"
#+ * SceneGameData.dome_tesselation -> dome_tesselation:   int  "Tessellation level - check the generated mesh in wireframe mode"
#+ * SceneGameData.dome_text -> dome_text:   pointer  "Custom Warp Mesh data file"
#+ * SceneGameData.dome_tilt -> dome_tilt:   int  "Camera rotation in horizontal axis"
#+ * SceneGameData.fps -> fps:   int  "The nominal number of game frames per second. Physics fixed timestep = 1/fps, independently of actual frame rate"
#SceneGameData.frame_color -> frame_color:   float[3]  "Set colour of the bars"
#SceneGameData.frame_type -> frame_type:   enum  "Select the type of Framing you want"
#+ * SceneGameData.frequency -> frequency:   int  "Displays clock frequency of fullscreen display"
#+ * SceneGameData.logic_step_max -> logic_step_max:   int  "Sets the maximum number of logic frame per game frame if graphics slows down the game, higher value allows better synchronization with physics"
#+ * SceneGameData.material_mode -> material_mode:   enum  "Material mode to use for rendering"
#+ * SceneGameData.occlusion_culling_resolution -> occlusion_culling_resolution:   float  "The size of the occlusion buffer in pixel, use higher value for better precision (slower)"
#+ * SceneGameData.physics_engine -> physics_engine:   enum  "Physics engine used for physics simulation in the game engine"
#+ * SceneGameData.physics_gravity -> physics_gravity:   float  "Gravitational constant used for physics simulation in the game engine"
#+ * SceneGameData.physics_step_max -> physics_step_max:   int  "Sets the maximum number of physics step per game frame if graphics slows down the game, higher value allows physics to keep up with realtime"
#+ * SceneGameData.physics_step_sub -> physics_step_sub:   int  "Sets the number of simulation substep per physic timestep, higher value give better physics precision"
#+ * SceneGameData.resolution_x -> resolution_x:   int  "Number of horizontal pixels in the screen"
#+ * SceneGameData.resolution_y -> resolution_y:   int  "Number of vertical pixels in the screen"
#+ * SceneGameData.show_debug_properties -> show_debug_properties:   boolean  "Show properties marked for debugging while the game runs"
#+ * SceneGameData.show_framerate_profile -> show_framerate_profile:   boolean  "Show framerate and profiling information while the game runs"
#SceneGameData.show_fullscreen -> show_fullscreen:   boolean  "Starts player in a new fullscreen display"
#+ * SceneGameData.show_physics_visualization -> show_physics_visualization:   boolean  "Show a visualization of physics bounds and interactions"
#+ * SceneGameData.stereo -> stereo:   enum  "NO DESCRIPTION"
#SceneGameData.stereo_eye_separation -> stereo_eye_separation:   float  "Set the distance between the eyes - the camera focal length/30 should be fine"
#+ * SceneGameData.stereo_mode -> stereo_mode:   enum  "Stereographic techniques"
#SceneGameData.use_activity_culling -> use_activity_culling:   boolean  "Activity culling is enabled"
#+ * SceneGameData.use_animation_record -> use_animation_record:   boolean  "Record animation to fcurves"
#SceneGameData.use_auto_start -> use_auto_start:   boolean  "Automatically start game at load time"
#+ * SceneGameData.use_deprecation_warnings -> use_deprecation_warnings:   boolean  "Print warnings when using deprecated features in the python API"
#+ * SceneGameData.use_display_lists -> use_display_lists:   boolean  "Use display lists to speed up rendering by keeping geometry on the GPU"
#+ * SceneGameData.use_frame_rate -> use_frame_rate:   boolean  "Respect the frame rate rather than rendering as many frames as possible"
#SceneGameData.use_glsl_extra_textures -> use_glsl_extra_textures:   boolean  "Use extra textures like normal or specular maps for GLSL rendering"
#SceneGameData.use_glsl_lights -> use_glsl_lights:   boolean  "Use lights for GLSL rendering"
#SceneGameData.use_glsl_nodes -> use_glsl_nodes:   boolean  "Use nodes for GLSL rendering"
#SceneGameData.use_glsl_ramps -> use_glsl_ramps:   boolean  "Use ramps for GLSL rendering"
#SceneGameData.use_glsl_shaders -> use_glsl_shaders:   boolean  "Use shaders for GLSL rendering"
#SceneGameData.use_glsl_shadows -> use_glsl_shadows:   boolean  "Use shadows for GLSL rendering"
#+ * SceneGameData.use_occlusion_culling -> use_occlusion_culling:   boolean  "Use optimized Bullet DBVT tree for view frustum and occlusion culling"
#+ * SceneObjects.active -> active:   pointer  "Active object for this scene"
#SceneRenderLayer.exclude_ambient_occlusion -> exclude_ambient_occlusion:   boolean  "Exclude AO pass from combined"
#SceneRenderLayer.exclude_emit -> exclude_emit:   boolean  "Exclude emission pass from combined"
#SceneRenderLayer.exclude_environment -> exclude_environment:   boolean  "Exclude environment pass from combined"
#SceneRenderLayer.exclude_indirect -> exclude_indirect:   boolean  "Exclude indirect pass from combined"
#SceneRenderLayer.exclude_reflection -> exclude_reflection:   boolean  "Exclude raytraced reflection pass from combined"
#SceneRenderLayer.exclude_refraction -> exclude_refraction:   boolean  "Exclude raytraced refraction pass from combined"
#SceneRenderLayer.exclude_shadow -> exclude_shadow:   boolean  "Exclude shadow pass from combined"
#SceneRenderLayer.exclude_specular -> exclude_specular:   boolean  "Exclude specular pass from combined"
#SceneRenderLayer.invert_zmask -> invert_zmask:   boolean  "For Zmask, only render what is behind solid z values instead of in front"
#SceneRenderLayer.layers -> layers:   boolean[20]  "Scene layers included in this render layer"
#SceneRenderLayer.layers_zmask -> layers_zmask:   boolean[20]  "Zmask scene layers"
#+ * SceneRenderLayer.light_override -> light_override:   pointer  "Group to override all other lights in this render layer"
#+ * SceneRenderLayer.material_override -> material_override:   pointer  "Material to override all other materials in this render layer"
#+ * SceneRenderLayer.name -> name:   string  "Render layer name"
#+ * SceneRenderLayer.use -> use:   boolean  "Disable or enable the render layer"
#SceneRenderLayer.use_all_z -> use_all_z:   boolean  "Fill in Z values for solid faces in invisible layers, for masking"
#SceneRenderLayer.use_edge_enhance -> use_edge_enhance:   boolean  "Render Edge-enhance in this Layer (only works for Solid faces)"
#SceneRenderLayer.use_halo -> use_halo:   boolean  "Render Halos in this Layer (on top of Solid)"
#SceneRenderLayer.use_pass_ambient_occlusion -> use_pass_ambient_occlusion:   boolean  "Deliver AO pass"
#SceneRenderLayer.use_pass_color -> use_pass_color:   boolean  "Deliver shade-less color pass"
#SceneRenderLayer.use_pass_combined -> use_pass_combined:   boolean  "Deliver full combined RGBA buffer"
#SceneRenderLayer.use_pass_diffuse -> use_pass_diffuse:   boolean  "Deliver diffuse pass"
#SceneRenderLayer.use_pass_emit -> use_pass_emit:   boolean  "Deliver emission pass"
#SceneRenderLayer.use_pass_environment -> use_pass_environment:   boolean  "Deliver environment lighting pass"
#SceneRenderLayer.use_pass_indirect -> use_pass_indirect:   boolean  "Deliver indirect lighting pass"
#SceneRenderLayer.use_pass_mist -> use_pass_mist:   boolean  "Deliver mist factor pass (0.0-1.0)"
#SceneRenderLayer.use_pass_normal -> use_pass_normal:   boolean  "Deliver normal pass"
#SceneRenderLayer.use_pass_object_index -> use_pass_object_index:   boolean  "Deliver object index pass"
#SceneRenderLayer.use_pass_reflection -> use_pass_reflection:   boolean  "Deliver raytraced reflection pass"
#SceneRenderLayer.use_pass_refraction -> use_pass_refraction:   boolean  "Deliver raytraced refraction pass"
#SceneRenderLayer.use_pass_shadow -> use_pass_shadow:   boolean  "Deliver shadow pass"
#SceneRenderLayer.use_pass_specular -> use_pass_specular:   boolean  "Deliver specular pass"
#SceneRenderLayer.use_pass_uv -> use_pass_uv:   boolean  "Deliver texture UV pass"
#SceneRenderLayer.use_pass_vector -> use_pass_vector:   boolean  "Deliver speed vector pass"
#SceneRenderLayer.use_pass_z -> use_pass_z:   boolean  "Deliver Z values pass"
#SceneRenderLayer.use_sky -> use_sky:   boolean  "Render Sky in this Layer"
#SceneRenderLayer.use_solid -> use_solid:   boolean  "Render Solid faces in this Layer"
#SceneRenderLayer.use_strand -> use_strand:   boolean  "Render Strands in this Layer"
#SceneRenderLayer.use_zmask -> use_zmask:   boolean  "Only render whats in front of the solid z values"
#SceneRenderLayer.use_ztransp -> use_ztransp:   boolean  "Render Z-Transparent faces in this Layer (On top of Solid and Halos)"
#+ * Scopes.accuracy -> accuracy:   float  "Proportion of original image source pixel lines to sample"
#+ * Scopes.histogram -> histogram:   pointer,  "(read-only)    Histogram for viewing image statistics"
#+ * Scopes.use_full_resolution -> use_full_resolution:   boolean  "Sample every pixel of the image"
#+ * Scopes.vectorscope_alpha -> vectorscope_alpha:   float  "Opacity of the points"
#+ * Scopes.waveform_alpha -> waveform_alpha:   float  "Opacity of the points"
#+ * Scopes.waveform_mode -> waveform_mode:   enum  "NO DESCRIPTION"
#+ * Sensor.frequency -> frequency:   int  "Delay between repeated pulses(in logic tics, 0=no delay)"
#+ * Sensor.invert -> invert:   boolean  "Invert the level(output) of this sensor"
#+ * Sensor.name -> name:   string  "Sensor name"
#Sensor.pin -> pin:   boolean  "Display when not linked to a visible states controller"
#Sensor.show_expanded -> show_expanded:   boolean  "Set sensor expanded in the user interface"
#+ * Sensor.type -> type:   enum  "NO DESCRIPTION"
#Sensor.use_level -> use_level:   boolean  "Level detector, trigger controllers of new states(only applicable upon logic state transition)"
#Sensor.use_pulse_false_level -> use_pulse_false_level:   boolean  "Activate FALSE level triggering (pulse mode)"
#Sensor.use_pulse_true_level -> use_pulse_true_level:   boolean  "Activate TRUE level triggering (pulse mode)"
#Sensor.use_tap -> use_tap:   boolean  "Trigger controllers only for an instant, even while the sensor remains true"
#+ * Sensor|ActuatorSensor.actuator -> actuator:   string  "Actuator name, actuator active state modifications will be detected"
#+ * Sensor|ArmatureSensor.bone -> bone:   string  "Identify the bone to check value from"
#+ * Sensor|ArmatureSensor.constraint -> constraint:   string  "Identify the bone constraint to check value from"
#+ * Sensor|ArmatureSensor.test_type -> test_type:   enum  "Type of value and test"
#+ * Sensor|ArmatureSensor.value -> value:   float  "Specify value to be used in comparison"
#+ * Sensor|CollisionSensor.material -> material:   string  "Only look for Objects with this material"
#+ * Sensor|CollisionSensor.property -> property:   string  "Only look for Objects with this property"
#Sensor|CollisionSensor.use_material -> use_material:   boolean  "Toggle collision on material or property"
#Sensor|CollisionSensor.use_pulse -> use_pulse:   boolean  "Changes to the set of colliding objects generates pulse"
#+ * Sensor|DelaySensor.delay -> delay:   int  "Delay in number of logic tics before the positive trigger (default 60 per second)"
#+ * Sensor|DelaySensor.duration -> duration:   int  "If >0, delay in number of logic tics before the negative trigger following the positive trigger"
#Sensor|DelaySensor.use_repeat -> use_repeat:   boolean  "Toggle repeat option. If selected, the sensor restarts after Delay+Dur logic tics"
#+ * Sensor|JoystickSensor.axis_direction -> axis_direction:   enum  "The direction of the axis"
#+ * Sensor|JoystickSensor.axis_number -> axis_number:   int  "Specify which axis pair to use, 1 is usually the main direction input"
#+ * Sensor|JoystickSensor.axis_threshold -> axis_threshold:   int  "Specify the precision of the axis"
#+ * Sensor|JoystickSensor.button_number -> button_number:   int  "Specify which button to use"
#+ * Sensor|JoystickSensor.event_type -> event_type:   enum  "The type of event this joystick sensor is triggered on"
#+ * Sensor|JoystickSensor.hat_direction -> hat_direction:   enum  "Specify hat direction"
#+ * Sensor|JoystickSensor.hat_number -> hat_number:   int  "Specify which hat to use"
#+ * Sensor|JoystickSensor.joystick_index -> joystick_index:   int  "Specify which joystick to use"
#+ * Sensor|JoystickSensor.single_axis_number -> single_axis_number:   int  "Specify a single axis (verticle/horizontal/other) to detect"
#Sensor|JoystickSensor.use_all_events -> use_all_events:   boolean  "Triggered by all events on this joysticks current type (axis/button/hat)"
#+ * Sensor|KeyboardSensor.key -> key:   enum  "NO DESCRIPTION"
#+ * Sensor|KeyboardSensor.log -> log:   string  "Property that receive the keystrokes in case a string is logged"
#Sensor|KeyboardSensor.modifier_key_1 -> modifier_key_1:   enum  "Modifier key code"
#Sensor|KeyboardSensor.modifier_key_2 -> modifier_key_2:   enum  "Modifier key code"
#+ * Sensor|KeyboardSensor.target -> target:   string  "Property that indicates whether to log keystrokes as a string"
#Sensor|KeyboardSensor.use_all_keys -> use_all_keys:   boolean  "Trigger this sensor on any keystroke"
#+ * Sensor|MessageSensor.subject -> subject:   string  "Optional subject filter: only accept messages with this subject, or empty for all"
#+ * Sensor|MouseSensor.mouse_event -> mouse_event:   enum  "Specify the type of event this mouse sensor should trigger on"
#+ * Sensor|NearSensor.distance -> distance:   float  "Trigger distance"
#+ * Sensor|NearSensor.property -> property:   string  "Only look for objects with this property"
#+ * Sensor|NearSensor.reset_distance -> reset_distance:   float  "NO DESCRIPTION"
#+ * Sensor|PropertySensor.evaluation_type -> evaluation_type:   enum  "Type of property evaluation"
#+ * Sensor|PropertySensor.property -> property:   string  "NO DESCRIPTION"
#+ * Sensor|PropertySensor.value -> value:   string  "Check for this value in types in Equal or Not Equal types"
#Sensor|PropertySensor.value_max -> value_max:   string  "Specify maximum value in Interval type"
#Sensor|PropertySensor.value_min -> value_min:   string  "Specify minimum value in Interval type"
#+ * Sensor|RadarSensor.angle -> angle:   float  "Opening angle of the radar cone"
#+ * Sensor|RadarSensor.axis -> axis:   enum  "Specify along which axis the radar cone is cast"
#+ * Sensor|RadarSensor.distance -> distance:   float  "Depth of the radar cone"
#+ * Sensor|RadarSensor.property -> property:   string  "Only look for Objects with this property"
#+ * Sensor|RandomSensor.seed -> seed:   int  "Initial seed of the generator. (Choose 0 for not random)"
#+ * Sensor|RaySensor.axis -> axis:   enum  "Specify along which axis the ray is cast"
#+ * Sensor|RaySensor.material -> material:   string  "Only look for Objects with this material"
#+ * Sensor|RaySensor.property -> property:   string  "Only look for Objects with this property"
#+ * Sensor|RaySensor.range -> range:   float  "Sense objects no farther than this distance"
#+ * Sensor|RaySensor.ray_type -> ray_type:   enum  "Toggle collision on material or property"
#Sensor|RaySensor.use_x_ray -> use_x_ray:   boolean  "Toggle X-Ray option (see through objects that dont have the property)"
#+ * Sensor|TouchSensor.material -> material:   pointer  "Only look for objects with this material"
#Sequence.blend_alpha -> blend_alpha:   float  "NO DESCRIPTION"
#Sequence.blend_type -> blend_type:   enum  "NO DESCRIPTION"
#+ * Sequence.channel -> channel:   int  "Y position of the sequence strip"
#+ * Sequence.effect_fader -> effect_fader:   float  "NO DESCRIPTION"
#Sequence.frame_duration -> frame_duration:   int,  "(read-only)    The length of the contents of this strip before the handles are applied"
#Sequence.frame_final_duration -> frame_final_duration:   int  "The length of the contents of this strip before the handles are applied"
#+ * Sequence.frame_final_end -> frame_final_end:   int  "End frame displayed in the sequence editor after offsets are applied"
#+ * Sequence.frame_final_start -> frame_final_start:   int  "Start frame displayed in the sequence editor after offsets are applied, setting this is equivalent to moving the handle, not the actual start frame"
#+ * Sequence.frame_offset_end -> frame_offset_end:   int,  "(read-only)"
#+ * Sequence.frame_offset_start -> frame_offset_start:   int,  "(read-only)"
#+ * Sequence.frame_start -> frame_start:   int  "NO DESCRIPTION"
#+ * Sequence.frame_still_end -> frame_still_end:   int,  "(read-only)"
#+ * Sequence.frame_still_start -> frame_still_start:   int,  "(read-only)"
#+ * Sequence.lock -> lock:   boolean  "Lock strip so that it cant be transformed"
#+ * Sequence.mute -> mute:   boolean  "NO DESCRIPTION"
#+ * Sequence.name -> name:   string  "NO DESCRIPTION"
#+ * Sequence.select -> select:   boolean  "NO DESCRIPTION"
#+ * Sequence.select_left_handle -> select_left_handle:   boolean  "NO DESCRIPTION"
#+ * Sequence.select_right_handle -> select_right_handle:   boolean  "NO DESCRIPTION"
#+ * Sequence.speed_fader -> speed_fader:   float  "NO DESCRIPTION"
#+ * Sequence.type -> type:   enum,  "(read-only)"
#Sequence.use_default_fade -> use_default_fade:   boolean  "Fade effect using the built-in default (usually make transition as long as effect strip)"
#+ * SequenceColorBalance.gain -> gain:   float[3]  "Color balance gain (highlights)"
#+ * SequenceColorBalance.gamma -> gamma:   float[3]  "Color balance gamma (midtones)"
#SequenceColorBalance.invert_gain -> invert_gain:   boolean  "NO DESCRIPTION"
#SequenceColorBalance.invert_gamma -> invert_gamma:   boolean  "NO DESCRIPTION"
#SequenceColorBalance.invert_lift -> invert_lift:   boolean  "NO DESCRIPTION"
#+ * SequenceColorBalance.lift -> lift:   float[3]  "Color balance lift (shadows)"
#SequenceCrop.max_x -> max_x:   int  "NO DESCRIPTION"
#SequenceCrop.max_y -> max_y:   int  "NO DESCRIPTION"
#SequenceCrop.min_x -> min_x:   int  "NO DESCRIPTION"
#SequenceCrop.min_y -> min_y:   int  "NO DESCRIPTION"
#+ * SequenceEditor.active_strip -> active_strip:   pointer  "NO DESCRIPTION"
#+ * SequenceEditor.meta_stack -> meta_stack:   collection,  "(read-only)    Meta strip stack, last is currently edited meta strip"
#+ * SequenceEditor.overlay_frame -> overlay_frame:   int  "Sequencers active strip"
#+ * SequenceEditor.overlay_lock -> overlay_lock:   boolean  "NO DESCRIPTION"
#+ * SequenceEditor.sequences -> sequences:   collection,  "(read-only)"
#+ * SequenceEditor.sequences_all -> sequences_all:   collection,  "(read-only)"
#+ * SequenceEditor.show_overlay -> show_overlay:   boolean  "Partial overlay ontop of the sequencer"
#+ * SequenceElement.filename -> filename:   string  "NO DESCRIPTION"
#+ * SequenceProxy.directory -> directory:   string  "Location to store the proxy files"
#+ * SequenceProxy.filepath -> filepath:   string  "Location of custom proxy file"
#+ * SequenceTransform.offset_x -> offset_x:   int  "NO DESCRIPTION"
#+ * SequenceTransform.offset_y -> offset_y:   int  "NO DESCRIPTION"
#+ * Sequence|EffectSequence.color_balance -> color_balance:   pointer,  "(read-only)"
#Sequence|EffectSequence.color_multiply -> color_multiply:   float  "NO DESCRIPTION"
#+ * Sequence|EffectSequence.color_saturation -> color_saturation:   float  "NO DESCRIPTION"
#+ * Sequence|EffectSequence.crop -> crop:   pointer,  "(read-only)"
#+ * Sequence|EffectSequence.proxy -> proxy:   pointer,  "(read-only)"
#+ * Sequence|EffectSequence.strobe -> strobe:   float  "Only display every nth frame"
#+ * Sequence|EffectSequence.transform -> transform:   pointer,  "(read-only)"
#+ * Sequence|EffectSequence.use_color_balance -> use_color_balance:   boolean  "(3-Way color correction) on input"
#+ * Sequence|EffectSequence.use_crop -> use_crop:   boolean  "Crop image before processing"
#Sequence|EffectSequence.use_deinterlace -> use_deinterlace:   boolean  "For video movies to remove fields"
#Sequence|EffectSequence.use_flip_x -> use_flip_x:   boolean  "Flip on the X axis"
#Sequence|EffectSequence.use_flip_y -> use_flip_y:   boolean  "Flip on the Y axis"
#Sequence|EffectSequence.use_float -> use_float:   boolean  "Convert input to float data"
#Sequence|EffectSequence.use_premultiply -> use_premultiply:   boolean  "Convert RGB from key alpha to premultiplied alpha"
#+ * Sequence|EffectSequence.use_proxy -> use_proxy:   boolean  "Use a preview proxy for this strip"
#Sequence|EffectSequence.use_proxy_custom_directory -> use_proxy_custom_directory:   boolean  "Use a custom directory to store data"
#Sequence|EffectSequence.use_proxy_custom_file -> use_proxy_custom_file:   boolean  "Use a custom file to read proxy data from"
#Sequence|EffectSequence.use_reverse_frames -> use_reverse_frames:   boolean  "Reverse frame order"
#+ * Sequence|EffectSequence.use_translation -> use_translation:   boolean  "Translate image before processing"
#+ * Sequence|EffectSequence|ColorSequence.color -> color:   float[3]  "NO DESCRIPTION"
#Sequence|EffectSequence|GlowSequence.blur_radius -> blur_radius:   float  "Radius of glow effect"
#+ * Sequence|EffectSequence|GlowSequence.boost_factor -> boost_factor:   float  "Brightness multiplier"
#+ * Sequence|EffectSequence|GlowSequence.clamp -> clamp:   float  "rightness limit of intensity"
#+ * Sequence|EffectSequence|GlowSequence.quality -> quality:   int  "Accuracy of the blur effect"
#+ * Sequence|EffectSequence|GlowSequence.threshold -> threshold:   float  "Minimum intensity to trigger a glow"
#Sequence|EffectSequence|GlowSequence.use_only_boost -> use_only_boost:   boolean  "Show the glow buffer only"
#+ * Sequence|EffectSequence|PluginSequence.filename -> filename:   string,  "(read-only)"
#+ * Sequence|EffectSequence|SpeedControlSequence.global_speed -> global_speed:   float  "NO DESCRIPTION"
#Sequence|EffectSequence|SpeedControlSequence.use_curve_compress_y -> use_curve_compress_y:   boolean  "Scale F-Curve value to get the target frame number, F-Curve value runs from 0.0 to 1.0"
#Sequence|EffectSequence|SpeedControlSequence.use_curve_velocity -> use_curve_velocity:   boolean  "Interpret the F-Curve value as a velocity instead of a frame number"
#Sequence|EffectSequence|SpeedControlSequence.use_frame_blend -> use_frame_blend:   boolean  "Blend two frames into the target for a smoother result"
#+ * Sequence|EffectSequence|TransformSequence.interpolation -> interpolation:   enum  "NO DESCRIPTION"
#+ * Sequence|EffectSequence|TransformSequence.rotation_start -> rotation_start:   float  "NO DESCRIPTION"
#+ * Sequence|EffectSequence|TransformSequence.scale_start_x -> scale_start_x:   float  "NO DESCRIPTION"
#+ * Sequence|EffectSequence|TransformSequence.scale_start_y -> scale_start_y:   float  "NO DESCRIPTION"
#+ * Sequence|EffectSequence|TransformSequence.translate_start_x -> translate_start_x:   float  "NO DESCRIPTION"
#+ * Sequence|EffectSequence|TransformSequence.translate_start_y -> translate_start_y:   float  "NO DESCRIPTION"
#+ * Sequence|EffectSequence|TransformSequence.translation_unit -> translation_unit:   enum  "NO DESCRIPTION"
#Sequence|EffectSequence|TransformSequence.use_uniform_scale -> use_uniform_scale:   boolean  "Scale uniformly, preserving aspect ratio"
#+ * Sequence|EffectSequence|WipeSequence.angle -> angle:   float  "Edge angle"
#+ * Sequence|EffectSequence|WipeSequence.blur_width -> blur_width:   float  "Width of the blur edge, in percentage relative to the image size"
#+ * Sequence|EffectSequence|WipeSequence.direction -> direction:   enum  "Wipe direction"
#+ * Sequence|EffectSequence|WipeSequence.transition_type -> transition_type:   enum  "NO DESCRIPTION"
#Sequence|ImageSequence.animation_offset_end -> animation_offset_end:   int  "Animation end offset (trim end)"
#Sequence|ImageSequence.animation_offset_start -> animation_offset_start:   int  "Animation start offset (trim start)"
#+ * Sequence|ImageSequence.color_balance -> color_balance:   pointer,  "(read-only)"
#Sequence|ImageSequence.color_multiply -> color_multiply:   float  "NO DESCRIPTION"
#+ * Sequence|ImageSequence.color_saturation -> color_saturation:   float  "NO DESCRIPTION"
#+ * Sequence|ImageSequence.crop -> crop:   pointer,  "(read-only)"
#+ * Sequence|ImageSequence.directory -> directory:   string  "NO DESCRIPTION"
#+ * Sequence|ImageSequence.elements -> elements:   collection,  "(read-only)"
#+ * Sequence|ImageSequence.proxy -> proxy:   pointer,  "(read-only)"
#+ * Sequence|ImageSequence.strobe -> strobe:   float  "Only display every nth frame"
#+ * Sequence|ImageSequence.transform -> transform:   pointer,  "(read-only)"
#+ * Sequence|ImageSequence.use_color_balance -> use_color_balance:   boolean  "(3-Way color correction) on input"
#+ * Sequence|ImageSequence.use_crop -> use_crop:   boolean  "Crop image before processing"
#Sequence|ImageSequence.use_deinterlace -> use_deinterlace:   boolean  "For video movies to remove fields"
#Sequence|ImageSequence.use_flip_x -> use_flip_x:   boolean  "Flip on the X axis"
#Sequence|ImageSequence.use_flip_y -> use_flip_y:   boolean  "Flip on the Y axis"
#Sequence|ImageSequence.use_float -> use_float:   boolean  "Convert input to float data"
#Sequence|ImageSequence.use_premultiply -> use_premultiply:   boolean  "Convert RGB from key alpha to premultiplied alpha"
#+ * Sequence|ImageSequence.use_proxy -> use_proxy:   boolean  "Use a preview proxy for this strip"
#Sequence|ImageSequence.use_proxy_custom_directory -> use_proxy_custom_directory:   boolean  "Use a custom directory to store data"
#Sequence|ImageSequence.use_proxy_custom_file -> use_proxy_custom_file:   boolean  "Use a custom file to read proxy data from"
#Sequence|ImageSequence.use_reverse_frames -> use_reverse_frames:   boolean  "Reverse frame order"
#+ * Sequence|ImageSequence.use_translation -> use_translation:   boolean  "Translate image before processing"
#Sequence|MetaSequence.animation_offset_end -> animation_offset_end:   int  "Animation end offset (trim end)"
#Sequence|MetaSequence.animation_offset_start -> animation_offset_start:   int  "Animation start offset (trim start)"
#+ * Sequence|MetaSequence.color_balance -> color_balance:   pointer,  "(read-only)"
#Sequence|MetaSequence.color_multiply -> color_multiply:   float  "NO DESCRIPTION"
#+ * Sequence|MetaSequence.color_saturation -> color_saturation:   float  "NO DESCRIPTION"
#+ * Sequence|MetaSequence.crop -> crop:   pointer,  "(read-only)"
#+ * Sequence|MetaSequence.proxy -> proxy:   pointer,  "(read-only)"
#+ * Sequence|MetaSequence.sequences -> sequences:   collection,  "(read-only)"
#+ * Sequence|MetaSequence.strobe -> strobe:   float  "Only display every nth frame"
#+ * Sequence|MetaSequence.transform -> transform:   pointer,  "(read-only)"
#+ * Sequence|MetaSequence.use_color_balance -> use_color_balance:   boolean  "(3-Way color correction) on input"
#+ * Sequence|MetaSequence.use_crop -> use_crop:   boolean  "Crop image before processing"
#Sequence|MetaSequence.use_deinterlace -> use_deinterlace:   boolean  "For video movies to remove fields"
#Sequence|MetaSequence.use_flip_x -> use_flip_x:   boolean  "Flip on the X axis"
#Sequence|MetaSequence.use_flip_y -> use_flip_y:   boolean  "Flip on the Y axis"
#Sequence|MetaSequence.use_float -> use_float:   boolean  "Convert input to float data"
#Sequence|MetaSequence.use_premultiply -> use_premultiply:   boolean  "Convert RGB from key alpha to premultiplied alpha"
#+ * Sequence|MetaSequence.use_proxy -> use_proxy:   boolean  "Use a preview proxy for this strip"
#Sequence|MetaSequence.use_proxy_custom_directory -> use_proxy_custom_directory:   boolean  "Use a custom directory to store data"
#Sequence|MetaSequence.use_proxy_custom_file -> use_proxy_custom_file:   boolean  "Use a custom file to read proxy data from"
#Sequence|MetaSequence.use_reverse_frames -> use_reverse_frames:   boolean  "Reverse frame order"
#+ * Sequence|MetaSequence.use_translation -> use_translation:   boolean  "Translate image before processing"
#Sequence|MovieSequence.animation_offset_end -> animation_offset_end:   int  "Animation end offset (trim end)"
#Sequence|MovieSequence.animation_offset_start -> animation_offset_start:   int  "Animation start offset (trim start)"
#+ * Sequence|MovieSequence.color_balance -> color_balance:   pointer,  "(read-only)"
#Sequence|MovieSequence.color_multiply -> color_multiply:   float  "NO DESCRIPTION"
#+ * Sequence|MovieSequence.color_saturation -> color_saturation:   float  "NO DESCRIPTION"
#+ * Sequence|MovieSequence.crop -> crop:   pointer,  "(read-only)"
#+ * Sequence|MovieSequence.filepath -> filepath:   string  "NO DESCRIPTION"
#+ * Sequence|MovieSequence.mpeg_preseek -> mpeg_preseek:   int  "For MPEG movies, preseek this many frames"
#+ * Sequence|MovieSequence.proxy -> proxy:   pointer,  "(read-only)"
#+ * Sequence|MovieSequence.strobe -> strobe:   float  "Only display every nth frame"
#+ * Sequence|MovieSequence.transform -> transform:   pointer,  "(read-only)"
#+ * Sequence|MovieSequence.use_color_balance -> use_color_balance:   boolean  "(3-Way color correction) on input"
#+ * Sequence|MovieSequence.use_crop -> use_crop:   boolean  "Crop image before processing"
#Sequence|MovieSequence.use_deinterlace -> use_deinterlace:   boolean  "For video movies to remove fields"
#Sequence|MovieSequence.use_flip_x -> use_flip_x:   boolean  "Flip on the X axis"
#Sequence|MovieSequence.use_flip_y -> use_flip_y:   boolean  "Flip on the Y axis"
#Sequence|MovieSequence.use_float -> use_float:   boolean  "Convert input to float data"
#Sequence|MovieSequence.use_premultiply -> use_premultiply:   boolean  "Convert RGB from key alpha to premultiplied alpha"
#+ * Sequence|MovieSequence.use_proxy -> use_proxy:   boolean  "Use a preview proxy for this strip"
#Sequence|MovieSequence.use_proxy_custom_directory -> use_proxy_custom_directory:   boolean  "Use a custom directory to store data"
#Sequence|MovieSequence.use_proxy_custom_file -> use_proxy_custom_file:   boolean  "Use a custom file to read proxy data from"
#Sequence|MovieSequence.use_reverse_frames -> use_reverse_frames:   boolean  "Reverse frame order"
#+ * Sequence|MovieSequence.use_translation -> use_translation:   boolean  "Translate image before processing"
#Sequence|MulticamSequence.animation_offset_end -> animation_offset_end:   int  "Animation end offset (trim end)"
#Sequence|MulticamSequence.animation_offset_start -> animation_offset_start:   int  "Animation start offset (trim start)"
#+ * Sequence|MulticamSequence.color_balance -> color_balance:   pointer,  "(read-only)"
#Sequence|MulticamSequence.color_multiply -> color_multiply:   float  "NO DESCRIPTION"
#+ * Sequence|MulticamSequence.color_saturation -> color_saturation:   float  "NO DESCRIPTION"
#+ * Sequence|MulticamSequence.crop -> crop:   pointer,  "(read-only)"
#+ * Sequence|MulticamSequence.multicam_source -> multicam_source:   int  "NO DESCRIPTION"
#+ * Sequence|MulticamSequence.proxy -> proxy:   pointer,  "(read-only)"
#+ * Sequence|MulticamSequence.strobe -> strobe:   float  "Only display every nth frame"
#+ * Sequence|MulticamSequence.transform -> transform:   pointer,  "(read-only)"
#+ * Sequence|MulticamSequence.use_color_balance -> use_color_balance:   boolean  "(3-Way color correction) on input"
#+ * Sequence|MulticamSequence.use_crop -> use_crop:   boolean  "Crop image before processing"
#Sequence|MulticamSequence.use_deinterlace -> use_deinterlace:   boolean  "For video movies to remove fields"
#Sequence|MulticamSequence.use_flip_x -> use_flip_x:   boolean  "Flip on the X axis"
#Sequence|MulticamSequence.use_flip_y -> use_flip_y:   boolean  "Flip on the Y axis"
#Sequence|MulticamSequence.use_float -> use_float:   boolean  "Convert input to float data"
#Sequence|MulticamSequence.use_premultiply -> use_premultiply:   boolean  "Convert RGB from key alpha to premultiplied alpha"
#+ * Sequence|MulticamSequence.use_proxy -> use_proxy:   boolean  "Use a preview proxy for this strip"
#Sequence|MulticamSequence.use_proxy_custom_directory -> use_proxy_custom_directory:   boolean  "Use a custom directory to store data"
#Sequence|MulticamSequence.use_proxy_custom_file -> use_proxy_custom_file:   boolean  "Use a custom file to read proxy data from"
#Sequence|MulticamSequence.use_reverse_frames -> use_reverse_frames:   boolean  "Reverse frame order"
#+ * Sequence|MulticamSequence.use_translation -> use_translation:   boolean  "Translate image before processing"
#Sequence|SceneSequence.animation_offset_end -> animation_offset_end:   int  "Animation end offset (trim end)"
#Sequence|SceneSequence.animation_offset_start -> animation_offset_start:   int  "Animation start offset (trim start)"
#+ * Sequence|SceneSequence.color_balance -> color_balance:   pointer,  "(read-only)"
#Sequence|SceneSequence.color_multiply -> color_multiply:   float  "NO DESCRIPTION"
#+ * Sequence|SceneSequence.color_saturation -> color_saturation:   float  "NO DESCRIPTION"
#+ * Sequence|SceneSequence.crop -> crop:   pointer,  "(read-only)"
#+ * Sequence|SceneSequence.proxy -> proxy:   pointer,  "(read-only)"
#+ * Sequence|SceneSequence.scene -> scene:   pointer  "Scene that this sequence uses"
#+ * Sequence|SceneSequence.scene_camera -> scene_camera:   pointer  "Override the scenes active camera"
#+ * Sequence|SceneSequence.strobe -> strobe:   float  "Only display every nth frame"
#+ * Sequence|SceneSequence.transform -> transform:   pointer,  "(read-only)"
#+ * Sequence|SceneSequence.use_color_balance -> use_color_balance:   boolean  "(3-Way color correction) on input"
#+ * Sequence|SceneSequence.use_crop -> use_crop:   boolean  "Crop image before processing"
#Sequence|SceneSequence.use_deinterlace -> use_deinterlace:   boolean  "For video movies to remove fields"
#Sequence|SceneSequence.use_flip_x -> use_flip_x:   boolean  "Flip on the X axis"
#Sequence|SceneSequence.use_flip_y -> use_flip_y:   boolean  "Flip on the Y axis"
#Sequence|SceneSequence.use_float -> use_float:   boolean  "Convert input to float data"
#Sequence|SceneSequence.use_premultiply -> use_premultiply:   boolean  "Convert RGB from key alpha to premultiplied alpha"
#+ * Sequence|SceneSequence.use_proxy -> use_proxy:   boolean  "Use a preview proxy for this strip"
#Sequence|SceneSequence.use_proxy_custom_directory -> use_proxy_custom_directory:   boolean  "Use a custom directory to store data"
#Sequence|SceneSequence.use_proxy_custom_file -> use_proxy_custom_file:   boolean  "Use a custom file to read proxy data from"
#Sequence|SceneSequence.use_reverse_frames -> use_reverse_frames:   boolean  "Reverse frame order"
#+ * Sequence|SceneSequence.use_translation -> use_translation:   boolean  "Translate image before processing"
#Sequence|SoundSequence.animation_offset_end -> animation_offset_end:   int  "Animation end offset (trim end)"
#Sequence|SoundSequence.animation_offset_start -> animation_offset_start:   int  "Animation start offset (trim start)"
#+ * Sequence|SoundSequence.attenuation -> attenuation:   float  "Attenuation in dezibel"
#+ * Sequence|SoundSequence.filepath -> filepath:   string  "NO DESCRIPTION"
#+ * Sequence|SoundSequence.sound -> sound:   pointer,  "(read-only)    Sound datablock used by this sequence"
#+ * Sequence|SoundSequence.volume -> volume:   float  "Playback volume of the sound"
#+ * ShapeKey.data -> data:   collection,  "(read-only)"
#+ * ShapeKey.frame -> frame:   float,  "(read-only)    Frame for absolute keys"
#+ * ShapeKey.interpolation -> interpolation:   enum  "Interpolation type"
#+ * ShapeKey.mute -> mute:   boolean  "Mute this shape key"
#+ * ShapeKey.name -> name:   string  "NO DESCRIPTION"
#+ * ShapeKey.relative_key -> relative_key:   pointer  "Shape used as a relative key"
#+ * ShapeKey.slider_max -> slider_max:   float  "Maximum for slider"
#+ * ShapeKey.slider_min -> slider_min:   float  "Minimum for slider"
#+ * ShapeKey.value -> value:   float  "Value of shape key at the current frame"
#+ * ShapeKey.vertex_group -> vertex_group:   string  "Vertex weight group, to blend with basis shape"
#+ * ShapeKeyBezierPoint.co -> co:   float[3]  "NO DESCRIPTION"
#ShapeKeyBezierPoint.handle_left -> handle_left:   float[3]  "NO DESCRIPTION"
#ShapeKeyBezierPoint.handle_right -> handle_right:   float[3]  "NO DESCRIPTION"
#+ * ShapeKeyCurvePoint.co -> co:   float[3]  "NO DESCRIPTION"
#+ * ShapeKeyCurvePoint.tilt -> tilt:   float  "NO DESCRIPTION"
#+ * ShapeKeyPoint.co -> co:   float[3]  "NO DESCRIPTION"
#TODO BETTER NAME * SmokeDomainSettings.alpha -> alpha:   float  "Higher value results in sinking smoke"
#+ * SmokeDomainSettings.amplify -> amplify:   int  "Enhance the resolution of smoke by this factor using noise"
#TODO BETTER NAME * SmokeDomainSettings.beta -> beta:   float  "Higher value results in faster rising smoke"
#SmokeDomainSettings.collision_extents -> collision_extents:   enum  "Selects which domain border will be treated as collision object."
#SmokeDomainSettings.collision_group -> collision_group:   pointer  "Limit collisions to this group"
#+ * SmokeDomainSettings.dissolve_speed -> dissolve_speed:   int  "Dissolve Speed"
#SmokeDomainSettings.effector_group -> effector_group:   pointer  "Limit effectors to this group"
#+ * SmokeDomainSettings.effector_weights -> effector_weights:   pointer,  "(read-only)"
#+ * SmokeDomainSettings.fluid_group -> fluid_group:   pointer  "Limit fluid objects to this group"
#+ * SmokeDomainSettings.noise_type -> noise_type:   enum  "Noise method which is used for creating the high resolution"
#SmokeDomainSettings.point_cache_compress_high_type -> point_cache_compress_high_type:   enum  "Compression method to be used"
#SmokeDomainSettings.point_cache_compress_type -> point_cache_compress_type:   enum  "Compression method to be used"
#+ * SmokeDomainSettings.point_cache_high -> point_cache_high:   pointer,  "(read-only)"
#+ * SmokeDomainSettings.point_cache_low -> point_cache_low:   pointer,  "(read-only)"
#SmokeDomainSettings.resolution_max -> resolution_max:   int  "Maximal resolution used in the fluid domain"
#SmokeDomainSettings.show_high_resolution -> show_high_resolution:   boolean  "Show high resolution (using amplification)"
#SmokeDomainSettings.smooth_emitter -> smooth_emitter:   boolean  "Smoothens emitted smoke to avoid blockiness."
#+ * SmokeDomainSettings.strength -> strength:   float  "Strength of wavelet noise"
#+ * SmokeDomainSettings.time_scale -> time_scale:   float  "Adjust simulation speed."
#SmokeDomainSettings.use_dissolve_smoke -> use_dissolve_smoke:   boolean  "Enable smoke to disappear over time"
#SmokeDomainSettings.use_dissolve_smoke_log -> use_dissolve_smoke_log:   boolean  "Using 1/x"
#SmokeDomainSettings.use_high_resolution -> use_high_resolution:   boolean  "Enable high resolution (using amplification)"
#+ * SmokeDomainSettings.vorticity -> vorticity:   float  "Amount of turbulence/rotation in fluid."
#+ * SmokeFlowSettings.density -> density:   float  "NO DESCRIPTION"
#+ * SmokeFlowSettings.initial_velocity -> initial_velocity:   boolean  "Smoke inherits its velocity from the emitter particle"
#SmokeFlowSettings.particle_system -> particle_system:   pointer  "Particle systems emitted from the object"
#+ * SmokeFlowSettings.temperature -> temperature:   float  "Temperature difference to ambient temperature"
#SmokeFlowSettings.use_absolute -> use_absolute:   boolean  "Only allows given density value in emitter area."
#SmokeFlowSettings.use_outflow -> use_outflow:   boolean  "Deletes smoke from simulation"
#SmokeFlowSettings.velocity_factor -> velocity_factor:   float  "Multiplier to adjust velocity passed to smoke"
#+ * SoftBodySettings.aero -> aero:   float  "Make edges sail"
#+ * SoftBodySettings.aerodynamics_type -> aerodynamics_type:   enum  "Method of calculating aerodynamic interaction"
#+ * SoftBodySettings.ball_damp -> ball_damp:   float  "Blending to inelastic collision"
#+ * SoftBodySettings.ball_size -> ball_size:   float  "Absolute ball size or factor if not manual adjusted"
#+ * SoftBodySettings.ball_stiff -> ball_stiff:   float  "Ball inflating pressure"
#SoftBodySettings.bend -> bend:   float  "Bending Stiffness"
#+ * SoftBodySettings.choke -> choke:   int  "Viscosity inside collision target"
#+ * SoftBodySettings.collision_type -> collision_type:   enum  "Choose Collision Type"
#SoftBodySettings.damping -> damping:   float  "Edge spring friction"
#+ * SoftBodySettings.effector_weights -> effector_weights:   pointer,  "(read-only)"
#SoftBodySettings.error_threshold -> error_threshold:   float  "The Runge-Kutta ODE solver error limit, low value gives more precision, high values speed"
#+ * SoftBodySettings.friction -> friction:   float  "General media friction for point movements"
#+ * SoftBodySettings.fuzzy -> fuzzy:   int  "Fuzziness while on collision, high values make collsion handling faster but less stable"
#+ * SoftBodySettings.goal_default -> goal_default:   float  "Default Goal (vertex target position) value, when no Vertex Group used"
#+ * SoftBodySettings.goal_friction -> goal_friction:   float  "Goal (vertex target position) friction"
#+ * SoftBodySettings.goal_max -> goal_max:   float  "Goal maximum, vertex weights are scaled to match this range"
#+ * SoftBodySettings.goal_min -> goal_min:   float  "Goal minimum, vertex weights are scaled to match this range"
#+ * SoftBodySettings.goal_spring -> goal_spring:   float  "Goal (vertex target position) spring stiffness"
#+ * SoftBodySettings.goal_vertex_group -> goal_vertex_group:   string  "Control point weight values"
#+ * SoftBodySettings.gravity -> gravity:   float  "Apply gravitation to point movement"
#SoftBodySettings.location_mass_center -> location_mass_center:   float[3]  "Location of Center of mass"
#+ * SoftBodySettings.mass -> mass:   float  "General Mass value"
#+ * SoftBodySettings.mass_vertex_group -> mass_vertex_group:   string  "Control point mass values"
#+ * SoftBodySettings.plastic -> plastic:   float  "Permanent deform"
#+ * SoftBodySettings.pull -> pull:   float  "Edge spring stiffness when longer than rest length"
#+ * SoftBodySettings.push -> push:   float  "Edge spring stiffness when shorter than rest length"
#SoftBodySettings.rotation_estimate -> rotation_estimate:   float[9]  "Estimated rotation matrix"
#SoftBodySettings.scale_estimate -> scale_estimate:   float[9]  "Estimated scale matrix"
#+ * SoftBodySettings.shear -> shear:   float  "Shear Stiffness"
#+ * SoftBodySettings.speed -> speed:   float  "Tweak timing for physics to control frequency and speed"
#+ * SoftBodySettings.spring_length -> spring_length:   float  "Alter spring length to shrink/blow up (unit %) 0 to disable"
#+ * SoftBodySettings.spring_vertex_group -> spring_vertex_group:   string  "Control point spring strength values"
#SoftBodySettings.step_max -> step_max:   int  "Maximal # solver steps/frame"
#SoftBodySettings.step_min -> step_min:   int  "Minimal # solver steps/frame"
#SoftBodySettings.use_auto_step -> use_auto_step:   boolean  "Use velocities for automagic step sizes"
#SoftBodySettings.use_diagnose -> use_diagnose:   boolean  "Turn on SB diagnose console prints"
#SoftBodySettings.use_edge_collision -> use_edge_collision:   boolean  "Edges collide too"
#+ * SoftBodySettings.use_edges -> use_edges:   boolean  "Use Edges as springs"
#SoftBodySettings.use_estimate_matrix -> use_estimate_matrix:   boolean  "estimate matrix .. split to COM , ROT ,SCALE"
#SoftBodySettings.use_face_collision -> use_face_collision:   boolean  "Faces collide too, can be very slow"
#+ * SoftBodySettings.use_goal -> use_goal:   boolean  "Define forces for vertices to stick to animated position"
#SoftBodySettings.use_self_collision -> use_self_collision:   boolean  "Enable naive vertex ball self collision"
#SoftBodySettings.use_stiff_quads -> use_stiff_quads:   boolean  "Adds diagonal springs on 4-gons"
#+ * Space.type -> type:   enum,  "(read-only)    Space data type"
#+ * SpaceUVEditor.cursor_location -> cursor_location:   float[2]  "2D cursor location for this view"
#+ * SpaceUVEditor.draw_stretch_type -> draw_stretch_type:   enum  "Type of stretch to draw"
#+ * SpaceUVEditor.edge_draw_type -> edge_draw_type:   enum  "Draw type for drawing UV edges"
#SpaceUVEditor.lock_bounds -> lock_bounds:   boolean  "Constraint to stay within the image bounds while editing"
#SpaceUVEditor.pivot_point -> pivot_point:   enum  "Rotation/Scaling Pivot"
#SpaceUVEditor.show_modified_edges -> show_modified_edges:   boolean  "Draw edges after modifiers are applied"
#SpaceUVEditor.show_normalized_coords -> show_normalized_coords:   boolean  "Display UV coordinates from 0.0 to 1.0 rather than in pixels"
#SpaceUVEditor.show_other_objects -> show_other_objects:   boolean  "Draw other selected objects that share the same image"
#SpaceUVEditor.show_smooth_edges -> show_smooth_edges:   boolean  "Draw UV edges anti-aliased"
#SpaceUVEditor.show_stretch -> show_stretch:   boolean  "Draw faces colored according to the difference in shape between UVs and their 3D coordinates (blue for low distortion, red for high distortion)"
#SpaceUVEditor.sticky_select_mode -> sticky_select_mode:   enum  "Automatically select also UVs sharing the same vertex as the ones being selected"
#SpaceUVEditor.use_live_unwrap -> use_live_unwrap:   boolean  "Continuously unwrap the selected UV island while transforming pinned vertices"
#SpaceUVEditor.use_snap_to_pixels -> use_snap_to_pixels:   boolean  "Snap UVs to pixel locations while editing"
#+ * Space|SpaceConsole.console_type -> console_type:   enum  "Console type"
#+ * Space|SpaceConsole.font_size -> font_size:   int  "Font size to use for displaying the text"
#+ * Space|SpaceConsole.history -> history:   collection,  "(read-only)    Command history"
#+ * Space|SpaceConsole.language -> language:   string  "Command line prompt language"
#+ * Space|SpaceConsole.prompt -> prompt:   string  "Command line prompt"
#+ * Space|SpaceConsole.scrollback -> scrollback:   collection,  "(read-only)    Command output"
#Space|SpaceConsole.select_end -> select_end:   int  "NO DESCRIPTION"
#Space|SpaceConsole.select_start -> select_start:   int  "NO DESCRIPTION"
#+ * Space|SpaceConsole.show_report_debug -> show_report_debug:   boolean  "Display debug reporting info"
#+ * Space|SpaceConsole.show_report_error -> show_report_error:   boolean  "Display error text"
#+ * Space|SpaceConsole.show_report_info -> show_report_info:   boolean  "Display general information"
#+ * Space|SpaceConsole.show_report_operator -> show_report_operator:   boolean  "Display the operator log"
#Space|SpaceConsole.show_report_warning -> show_report_warning:   boolean  "Display warnings"
#+ * Space|SpaceDopeSheetEditor.action -> action:   pointer  "Action displayed and edited in this space"
#Space|SpaceDopeSheetEditor.auto_snap -> auto_snap:   enum  "Automatic time snapping settings for transformations"
#+ * Space|SpaceDopeSheetEditor.dopesheet -> dopesheet:   pointer,  "(read-only)    Settings for filtering animation data"
#+ * Space|SpaceDopeSheetEditor.mode -> mode:   enum  "Editing context being displayed"
#Space|SpaceDopeSheetEditor.show_frame_indicator -> show_frame_indicator:   boolean  "Show frame number beside the current frame indicator line"
#+ * Space|SpaceDopeSheetEditor.show_seconds -> show_seconds:   boolean,  "(read-only)    Show timing in seconds not frames"
#+ * Space|SpaceDopeSheetEditor.show_sliders -> show_sliders:   boolean  "Show sliders beside F-Curve channels"
#Space|SpaceDopeSheetEditor.use_auto_merge_keyframes -> use_auto_merge_keyframes:   boolean  "Automatically merge nearby keyframes"
#+ * Space|SpaceDopeSheetEditor.use_marker_sync -> use_marker_sync:   boolean  "Sync Markers with keyframe edits"
#Space|SpaceDopeSheetEditor.use_realtime_update -> use_realtime_update:   boolean  "When transforming keyframes, changes to the animation data are flushed to other views"
#+ * Space|SpaceFileBrowser.params -> params:   pointer,  "(read-only)    Parameters and Settings for the Filebrowser"
#Space|SpaceGraphEditor.auto_snap -> auto_snap:   enum  "Automatic time snapping settings for transformations"
#Space|SpaceGraphEditor.cursor_position_y -> cursor_position_y:   float  "Graph Editor 2D-Value cursor - Y-Value component"
#+ * Space|SpaceGraphEditor.dopesheet -> dopesheet:   pointer,  "(read-only)    Settings for filtering animation data"
#+ * Space|SpaceGraphEditor.has_ghost_curves -> has_ghost_curves:   boolean  "Graph Editor instance has some ghost curves stored"
#+ * Space|SpaceGraphEditor.mode -> mode:   enum  "Editing context being displayed"
#+ * Space|SpaceGraphEditor.pivot_point -> pivot_point:   enum  "Pivot center for rotation/scaling"
#+ * Space|SpaceGraphEditor.show_cursor -> show_cursor:   boolean  "Show 2D cursor"
#Space|SpaceGraphEditor.show_frame_indicator -> show_frame_indicator:   boolean  "Show frame number beside the current frame indicator line"
#+ * Space|SpaceGraphEditor.show_handles -> show_handles:   boolean  "Show handles of Bezier control points"
#+ * Space|SpaceGraphEditor.show_seconds -> show_seconds:   boolean,  "(read-only)    Show timing in seconds not frames"
#+ * Space|SpaceGraphEditor.show_sliders -> show_sliders:   boolean  "Show sliders beside F-Curve channels"
#Space|SpaceGraphEditor.use_auto_merge_keyframes -> use_auto_merge_keyframes:   boolean  "Automatically merge nearby keyframes"
#Space|SpaceGraphEditor.use_only_selected_curves_handles -> use_only_selected_curves_handles:   boolean  "Only keyframes of selected F-Curves are visible and editable"
#Space|SpaceGraphEditor.use_only_selected_keyframe_handles -> use_only_selected_keyframe_handles:   boolean  "Only show and edit handles of selected keyframes"
#Space|SpaceGraphEditor.use_realtime_update -> use_realtime_update:   boolean  "When transforming keyframes, changes to the animation data are flushed to other views"
#+ * Space|SpaceImageEditor.curves -> curves:   pointer,  "(read-only)    Color curve mapping to use for displaying the image"
#+ * Space|SpaceImageEditor.draw_channels -> draw_channels:   enum  "Channels of the image to draw"
#+ * Space|SpaceImageEditor.grease_pencil -> grease_pencil:   pointer  "Grease pencil data for this space"
#+ * Space|SpaceImageEditor.image -> image:   pointer  "Image displayed and edited in this space"
#+ * Space|SpaceImageEditor.image_user -> image_user:   pointer,  "(read-only)    Parameters defining which layer, pass and frame of the image is displayed"
#+ * Space|SpaceImageEditor.sample_histogram -> sample_histogram:   pointer,  "(read-only)    Sampled colors along line"
#+ * Space|SpaceImageEditor.scopes -> scopes:   pointer,  "(read-only)    Scopes to visualize image statistics."
#+ * Space|SpaceImageEditor.show_paint -> show_paint:   boolean,  "(read-only)    Show paint related properties"
#+ * Space|SpaceImageEditor.show_render -> show_render:   boolean,  "(read-only)    Show render related properties"
#Space|SpaceImageEditor.show_repeat -> show_repeat:   boolean  "Draw the image repeated outside of the main view"
#+ * Space|SpaceImageEditor.show_uvedit -> show_uvedit:   boolean,  "(read-only)    Show UV editing related properties"
#+ * Space|SpaceImageEditor.use_grease_pencil -> use_grease_pencil:   boolean  "Display and edit the grease pencil freehand annotations overlay"
#Space|SpaceImageEditor.use_image_paint -> use_image_paint:   boolean  "Enable image painting mode"
#Space|SpaceImageEditor.use_image_pin -> use_image_pin:   boolean  "Display current image regardless of object selection"
#Space|SpaceImageEditor.use_realtime_update -> use_realtime_update:   boolean  "Update other affected window spaces automatically to reflect changes during interactive operations such as transform"
#+ * Space|SpaceImageEditor.uv_editor -> uv_editor:   pointer,  "(read-only)    UV editor settings"
#Space|SpaceLogicEditor.show_actuators_active_object -> show_actuators_active_object:   boolean  "Show actuators of active object"
#Space|SpaceLogicEditor.show_actuators_active_states -> show_actuators_active_states:   boolean  "Show only actuators connected to active states"
#Space|SpaceLogicEditor.show_actuators_linked_controller -> show_actuators_linked_controller:   boolean  "Show linked objects to the actuator"
#Space|SpaceLogicEditor.show_actuators_selected_objects -> show_actuators_selected_objects:   boolean  "Show actuators of all selected objects"
#Space|SpaceLogicEditor.show_controllers_active_object -> show_controllers_active_object:   boolean  "Show controllers of active object"
#Space|SpaceLogicEditor.show_controllers_linked_controller -> show_controllers_linked_controller:   boolean  "Show linked objects to sensor/actuator"
#Space|SpaceLogicEditor.show_controllers_selected_objects -> show_controllers_selected_objects:   boolean  "Show controllers of all selected objects"
#Space|SpaceLogicEditor.show_sensors_active_object -> show_sensors_active_object:   boolean  "Show sensors of active object"
#Space|SpaceLogicEditor.show_sensors_active_states -> show_sensors_active_states:   boolean  "Show only sensors connected to active states"
#Space|SpaceLogicEditor.show_sensors_linked_controller -> show_sensors_linked_controller:   boolean  "Show linked objects to the controller"
#Space|SpaceLogicEditor.show_sensors_selected_objects -> show_sensors_selected_objects:   boolean  "Show sensors of all selected objects"
#Space|SpaceNLA.auto_snap -> auto_snap:   enum  "Automatic time snapping settings for transformations"
#+ * Space|SpaceNLA.dopesheet -> dopesheet:   pointer,  "(read-only)    Settings for filtering animation data"
#Space|SpaceNLA.show_frame_indicator -> show_frame_indicator:   boolean  "Show frame number beside the current frame indicator line"
#+ * Space|SpaceNLA.show_seconds -> show_seconds:   boolean,  "(read-only)    Show timing in seconds not frames"
#+ * Space|SpaceNLA.show_strip_curves -> show_strip_curves:   boolean  "Show influence curves on strips"
#Space|SpaceNLA.use_realtime_update -> use_realtime_update:   boolean  "When transforming strips, changes to the animation data are flushed to other views"
#+ * Space|SpaceNodeEditor.id -> id:   pointer,  "(read-only)    Datablock whose nodes are being edited"
#+ * Space|SpaceNodeEditor.id_from -> id_from:   pointer,  "(read-only)    Datablock from which the edited datablock is linked"
#+ * Space|SpaceNodeEditor.nodetree -> nodetree:   pointer,  "(read-only)    Node tree being displayed and edited"
#Space|SpaceNodeEditor.show_backdrop -> show_backdrop:   boolean  "Use active Viewer Node output as backdrop for compositing nodes"
#+ * Space|SpaceNodeEditor.texture_type -> texture_type:   enum  "Type of data to take texture from"
#+ * Space|SpaceNodeEditor.tree_type -> tree_type:   enum  "Node tree type to display and edit"
#+ * Space|SpaceOutliner.display_mode -> display_mode:   enum  "Type of information to display"
#Space|SpaceOutliner.filter_text -> filter_text:   string  "Live search filtering string"
#Space|SpaceOutliner.show_restrict_columns -> show_restrict_columns:   boolean  "Show column"
#Space|SpaceOutliner.use_filter_case_sensitive -> use_filter_case_sensitive:   boolean  "Only use case sensitive matches of search string"
#Space|SpaceOutliner.use_filter_complete -> use_filter_complete:   boolean  "Only use complete matches of search string"
#+ * Space|SpaceProperties.align -> align:   enum  "Arrangement of the panels"
#+ * Space|SpaceProperties.context -> context:   enum  "Type of active data to display and edit"
#+ * Space|SpaceProperties.pin_id -> pin_id:   pointer  "NO DESCRIPTION"
#Space|SpaceProperties.show_brush_texture -> show_brush_texture:   boolean  "Show brush textures"
#+ * Space|SpaceProperties.use_pin_id -> use_pin_id:   boolean  "Use the pinned context"
#+ * Space|SpaceSequenceEditor.display_channel -> display_channel:   int  "The channel number shown in the image preview. 0 is the result of all strips combined"
#+ * Space|SpaceSequenceEditor.display_mode -> display_mode:   enum  "The view mode to use for displaying sequencer output"
#+ * Space|SpaceSequenceEditor.draw_overexposed -> draw_overexposed:   int  "Show overexposed areas with zebra stripes"
#+ * Space|SpaceSequenceEditor.grease_pencil -> grease_pencil:   pointer,  "(read-only)    Grease pencil data for this space"
#+ * Space|SpaceSequenceEditor.offset_x -> offset_x:   float  "Offsets image horizontally from the view center"
#+ * Space|SpaceSequenceEditor.offset_y -> offset_y:   float  "Offsets image horizontally from the view center"
#+ * Space|SpaceSequenceEditor.proxy_render_size -> proxy_render_size:   enum  "Draw preview using full resolution or different proxy resolutions"
#Space|SpaceSequenceEditor.show_frame_indicator -> show_frame_indicator:   boolean  "Show frame number beside the current frame indicator line"
#Space|SpaceSequenceEditor.show_frames -> show_frames:   boolean  "Draw frames rather than seconds"
#Space|SpaceSequenceEditor.show_safe_margin -> show_safe_margin:   boolean  "Draw title safe margins in preview"
#Space|SpaceSequenceEditor.show_separate_color -> show_separate_color:   boolean  "Separate color channels in preview"
#+ * Space|SpaceSequenceEditor.use_grease_pencil -> use_grease_pencil:   boolean  "Display and edit the grease pencil freehand annotations overlay"
#+ * Space|SpaceSequenceEditor.use_marker_sync -> use_marker_sync:   boolean  "Transform markers as well as strips"
#+ * Space|SpaceSequenceEditor.view_type -> view_type:   enum  "The type of the Sequencer view (sequencer, preview or both)"
#+ * Space|SpaceSequenceEditor.zoom -> zoom:   float  "Display zoom level"
#+ * Space|SpaceTextEditor.find_text -> find_text:   string  "Text to search for with the find tool"
#+ * Space|SpaceTextEditor.font_size -> font_size:   int  "Font size to use for displaying the text"
#+ * Space|SpaceTextEditor.replace_text -> replace_text:   string  "Text to replace selected text with using the replace tool"
#Space|SpaceTextEditor.show_line_highlight -> show_line_highlight:   boolean  "Highlight the current line"
#+ * Space|SpaceTextEditor.show_line_numbers -> show_line_numbers:   boolean  "Show line numbers next to the text"
#+ * Space|SpaceTextEditor.show_syntax_highlight -> show_syntax_highlight:   boolean  "Syntax highlight for scripting"
#+ * Space|SpaceTextEditor.show_word_wrap -> show_word_wrap:   boolean  "Wrap words if there is not enough horizontal space"
#+ * Space|SpaceTextEditor.tab_width -> tab_width:   int  "Number of spaces to display tabs with"
#+ * Space|SpaceTextEditor.text -> text:   pointer  "Text displayed and edited in this space"
#Space|SpaceTextEditor.use_find_all -> use_find_all:   boolean  "Search in all text datablocks, instead of only the active one"
#Space|SpaceTextEditor.use_find_wrap -> use_find_wrap:   boolean  "Search again from the start of the file when reaching the end"
#Space|SpaceTextEditor.use_live_edit -> use_live_edit:   boolean  "Run python while editing"
#Space|SpaceTextEditor.use_overwrite -> use_overwrite:   boolean  "Overwrite characters when typing rather than inserting them"
#+ * Space|SpaceTimeline.cache_cloth -> cache_cloth:   boolean  "Show the active objects cloth point cache"
#+ * Space|SpaceTimeline.cache_particles -> cache_particles:   boolean  "Show the active objects particle point cache"
#+ * Space|SpaceTimeline.cache_smoke -> cache_smoke:   boolean  "Show the active objects smoke cache"
#+ * Space|SpaceTimeline.cache_softbody -> cache_softbody:   boolean  "Show the active objects softbody point cache"
#+ * Space|SpaceTimeline.show_cache -> show_cache:   boolean  "Show the status of cached frames in the timeline"
#Space|SpaceTimeline.show_frame_indicator -> show_frame_indicator:   boolean  "Show frame number beside the current frame indicator line"
#Space|SpaceTimeline.show_only_selected -> show_only_selected:   boolean  "Show keyframes for active Object and/or its selected channels only"
#Space|SpaceTimeline.use_play_3d_editors -> use_play_3d_editors:   boolean  "NO DESCRIPTION"
#Space|SpaceTimeline.use_play_animation_editors -> use_play_animation_editors:   boolean  "NO DESCRIPTION"
#Space|SpaceTimeline.use_play_image_editors -> use_play_image_editors:   boolean  "NO DESCRIPTION"
#Space|SpaceTimeline.use_play_node_editors -> use_play_node_editors:   boolean  "NO DESCRIPTION"
#Space|SpaceTimeline.use_play_properties_editors -> use_play_properties_editors:   boolean  "NO DESCRIPTION"
#Space|SpaceTimeline.use_play_sequence_editors -> use_play_sequence_editors:   boolean  "NO DESCRIPTION"
#Space|SpaceTimeline.use_play_top_left_3d_editor -> use_play_top_left_3d_editor:   boolean  "NO DESCRIPTION"
#Space|SpaceUserPreferences.filter_text -> filter_text:   string  "Search term for filtering in the UI"
#+ * Space|SpaceView3D.background_images -> background_images:   collection,  "(read-only)    List of background images"
#+ * Space|SpaceView3D.camera -> camera:   pointer  "Active camera used in this view (when unlocked from the scenes active camera)"
#+ * Space|SpaceView3D.clip_end -> clip_end:   float  "3D View far clipping distance"
#+ * Space|SpaceView3D.clip_start -> clip_start:   float  "3D View near clipping distance"
#+ * Space|SpaceView3D.current_orientation -> current_orientation:   pointer,  "(read-only)    Current Transformation orientation"
#+ * Space|SpaceView3D.cursor_location -> cursor_location:   float[3]  "3D cursor location for this view (dependent on local view setting)"
#+ * Space|SpaceView3D.grid_lines -> grid_lines:   int  "The number of grid lines to display in perspective view"
#+ * Space|SpaceView3D.grid_spacing -> grid_spacing:   float  "The distance between 3D View grid lines"
#+ * Space|SpaceView3D.grid_subdivisions -> grid_subdivisions:   int  "The number of subdivisions between grid lines"
#+ * Space|SpaceView3D.layers -> layers:   boolean[20]  "Layers visible in this 3D View"
#Space|SpaceView3D.layers_used -> layers_used:   boolean[20],  "(read-only)    Layers that contain something"
#+ * Space|SpaceView3D.lens -> lens:   float  "Lens angle (mm) in perspective view"
#+ * Space|SpaceView3D.local_view -> local_view:   pointer,  "(read-only)    Display an isolated sub-set of objects, apart from the scene visibility"
#+ * Space|SpaceView3D.lock_bone -> lock_bone:   string  "3D View center is locked to this bones position"
#+ * Space|SpaceView3D.lock_camera_and_layers -> lock_camera_and_layers:   boolean  "Use the scenes active camera and layers in this view, rather than local layers"
#+ * Space|SpaceView3D.lock_object -> lock_object:   pointer  "3D View center is locked to this objects position"
#+ * Space|SpaceView3D.pivot_point -> pivot_point:   enum  "Pivot center for rotation/scaling"
#+ * Space|SpaceView3D.region_3d -> region_3d:   pointer,  "(read-only)    3D region in this space, in case of quad view the camera region"
#+ * Space|SpaceView3D.region_quadview -> region_quadview:   pointer,  "(read-only)    3D region that defines the quad view settings"
#Space|SpaceView3D.show_all_objects_origin -> show_all_objects_origin:   boolean  "Show the object origin center dot for all (selected and unselected) objects"
#Space|SpaceView3D.show_axis_x -> show_axis_x:   boolean  "Show the X axis line in perspective view"
#Space|SpaceView3D.show_axis_y -> show_axis_y:   boolean  "Show the Y axis line in perspective view"
#Space|SpaceView3D.show_axis_z -> show_axis_z:   boolean  "Show the Z axis line in perspective view"
#Space|SpaceView3D.show_background_images -> show_background_images:   boolean  "Display reference images behind objects in the 3D View"
#Space|SpaceView3D.show_floor -> show_floor:   boolean  "Show the ground plane grid in perspective view"
#Space|SpaceView3D.show_manipulator -> show_manipulator:   boolean  "Use a 3D manipulator widget for controlling transforms"
#Space|SpaceView3D.show_only_render -> show_only_render:   boolean  "Display only objects which will be rendered"
#Space|SpaceView3D.show_outline_selected -> show_outline_selected:   boolean  "Show an outline highlight around selected objects in non-wireframe views"
#Space|SpaceView3D.show_relationship_lines -> show_relationship_lines:   boolean  "Show dashed lines indicating parent or constraint relationships"
#Space|SpaceView3D.show_textured_solid -> show_textured_solid:   boolean  "Display face-assigned textures in solid view"
#+ * Space|SpaceView3D.transform_orientation -> transform_orientation:   enum  "Transformation orientation"
#Space|SpaceView3D.use_manipulator_rotate -> use_manipulator_rotate:   boolean  "Use the manipulator for rotation transformations"
#Space|SpaceView3D.use_manipulator_scale -> use_manipulator_scale:   boolean  "Use the manipulator for scale transformations"
#Space|SpaceView3D.use_manipulator_translate -> use_manipulator_translate:   boolean  "Use the manipulator for movement transformations"
#Space|SpaceView3D.use_occlude_geometry -> use_occlude_geometry:   boolean  "Limit selection to visible (clipped with depth buffer)"
#Space|SpaceView3D.use_pivot_point_align -> use_pivot_point_align:   boolean  "Manipulate object centers only"
#Space|SpaceView3D.viewport_shade -> viewport_shade:   enum  "Method to display/shade objects in the 3D View"
#+ * Spline.bezier_points -> bezier_points:   collection,  "(read-only)    Collection of points for bezier curves only"
#+ * Spline.character_index -> character_index:   int,  "(read-only)    Location of this character in the text data (only for text curves)"
#+ * Spline.hide -> hide:   boolean  "Hide this curve in editmode"
#+ * Spline.material_index -> material_index:   int  "NO DESCRIPTION"
#+ * Spline.order_u -> order_u:   int  "Nurbs order in the U direction (For splines and surfaces), Higher values let points influence a greater area"
#+ * Spline.order_v -> order_v:   int  "Nurbs order in the V direction (For surfaces only), Higher values let points influence a greater area"
#+ * Spline.point_count_u -> point_count_u:   int,  "(read-only)    Total number points for the curve or surface in the U direction"
#+ * Spline.point_count_v -> point_count_v:   int,  "(read-only)    Total number points for the surface on the V direction"
#+ * Spline.points -> points:   collection,  "(read-only)    Collection of points that make up this poly or nurbs spline"
#+ * Spline.radius_interpolation -> radius_interpolation:   enum  "The type of radius interpolation for Bezier curves"
#+ * Spline.resolution_u -> resolution_u:   int  "Curve or Surface subdivisions per segment"
#+ * Spline.resolution_v -> resolution_v:   int  "Surface subdivisions per segment"
#+ * Spline.tilt_interpolation -> tilt_interpolation:   enum  "The type of tilt interpolation for 3D, Bezier curves"
#+ * Spline.type -> type:   enum  "The interpolation type for this curve element"
#Spline.use_bezier_u -> use_bezier_u:   boolean  "Make this nurbs curve or surface act like a bezier spline in the U direction (Order U must be 3 or 4, Cyclic U must be disabled)"
#Spline.use_bezier_v -> use_bezier_v:   boolean  "Make this nurbs surface act like a bezier spline in the V direction (Order V must be 3 or 4, Cyclic V must be disabled)"
#Spline.use_cyclic_u -> use_cyclic_u:   boolean  "Make this curve or surface a closed loop in the U direction"
#Spline.use_cyclic_v -> use_cyclic_v:   boolean  "Make this surface a closed loop in the V direction"
#Spline.use_endpoint_u -> use_endpoint_u:   boolean  "Make this nurbs curve or surface meet the endpoints in the U direction (Cyclic U must be disabled)"
#Spline.use_endpoint_v -> use_endpoint_v:   boolean  "Make this nurbs surface meet the endpoints in the V direction (Cyclic V must be disabled)"
#Spline.use_smooth -> use_smooth:   boolean  "Smooth the normals of the surface or beveled curve"
#+ * SplinePoint.co -> co:   float[4]  "Point coordinates"
#+ * SplinePoint.hide -> hide:   boolean  "Visibility status"
#+ * SplinePoint.radius -> radius:   float,  "(read-only)    Radius for bevelling"
#+ * SplinePoint.select -> select:   boolean  "Selection status"
#+ * SplinePoint.tilt -> tilt:   float  "Tilt in 3D View"
#+ * SplinePoint.weight -> weight:   float  "Nurbs weight"
#+ * SplinePoint.weight_softbody -> weight_softbody:   float  "Softbody goal weight"
#+ * Struct.base -> base:   pointer,  "(read-only)    Struct definition this is derived from"
#+ * Struct.description -> description:   string,  "(read-only)    Description of the Structs purpose"
#+ * Struct.functions -> functions:   collection,  "(read-only)"
#+ * Struct.identifier -> identifier:   string,  "(read-only)    Unique name used in the code and scripting"
#+ * Struct.name -> name:   string,  "(read-only)    Human readable name"
#+ * Struct.name_property -> name_property:   pointer,  "(read-only)    Property that gives the name of the struct"
#+ * Struct.nested -> nested:   pointer,  "(read-only)    Struct in which this struct is always nested, and to which it logically belongs"
#+ * Struct.properties -> properties:   collection,  "(read-only)    Properties in the struct"
#+ * TexMapping.location -> location:   float[3]  "NO DESCRIPTION"
#TexMapping.max -> max:   float[3]  "Maximum value for clipping"
#TexMapping.min -> min:   float[3]  "Minimum value for clipping"
#+ * TexMapping.rotation -> rotation:   float[3]  "NO DESCRIPTION"
#+ * TexMapping.scale -> scale:   float[3]  "NO DESCRIPTION"
#TexMapping.use_max -> use_max:   boolean  "Whether to use maximum clipping value"
#TexMapping.use_min -> use_min:   boolean  "Whether to use minimum clipping value"
#+ * TextBox.height -> height:   float  "NO DESCRIPTION"
#+ * TextBox.width -> width:   float  "NO DESCRIPTION"
#+ * TextBox.x -> x:   float  "NO DESCRIPTION"
#+ * TextBox.y -> y:   float  "NO DESCRIPTION"
#TextCharacterFormat.use_bold -> use_bold:   boolean  "NO DESCRIPTION"
#TextCharacterFormat.use_italic -> use_italic:   boolean  "NO DESCRIPTION"
#+ * TextCharacterFormat.use_small_caps -> use_small_caps:   boolean  "NO DESCRIPTION"
#TextCharacterFormat.use_underline -> use_underline:   boolean  "NO DESCRIPTION"
#+ * TextLine.body -> body:   string  "Text in the line"
#TextMarker.character_index_end -> character_index_end:   int,  "(read-only)    Start position of the marker in the line"
#TextMarker.character_index_start -> character_index_start:   int,  "(read-only)    Start position of the marker in the line"
#+ * TextMarker.color -> color:   float[4]  "Color to display the marker with"
#+ * TextMarker.group -> group:   int,  "(read-only)"
#TextMarker.is_temporary -> is_temporary:   boolean,  "(read-only)    Marker is temporary"
#+ * TextMarker.line -> line:   int,  "(read-only)    Line in which the marker is located"
#TextMarker.use_edit_all -> use_edit_all:   boolean,  "(read-only)    Edit all markers of the same group as one"
#+ * TextureSlot.blend_type -> blend_type:   enum  "NO DESCRIPTION"
#+ * TextureSlot.color -> color:   float[3]  "The default color for textures that dont return RGB"
#+ * TextureSlot.default_value -> default_value:   float  "Value to use for Ref, Spec, Amb, Emit, Alpha, RayMir, TransLu and Hard"
#TextureSlot.invert -> invert:   boolean  "Inverts the values of the texture to reverse its effect"
#+ * TextureSlot.name -> name:   string,  "(read-only)    Texture slot name"
#+ * TextureSlot.offset -> offset:   float[3]  "Fine tunes texture mapping X, Y and Z locations"
#+ * TextureSlot.output_node -> output_node:   enum  "Which output node to use, for node-based textures"
#TextureSlot.scale -> scale:   float[3]  "Sets scaling for the textures X, Y and Z sizes"
#+ * TextureSlot.texture -> texture:   pointer  "Texture datablock used by this texture slot"
#TextureSlot.use_rgb_to_intensity -> use_rgb_to_intensity:   boolean  "Converts texture RGB values to intensity (gray) values"
#TextureSlot.use_stencil -> use_stencil:   boolean  "Use this texture as a blending value on the next texture"
#+ * TextureSlot|BrushTextureSlot.angle -> angle:   float  "Defines brush texture rotation"
#+ * TextureSlot|BrushTextureSlot.map_mode -> map_mode:   enum  "NO DESCRIPTION"
#+ * TextureSlot|LampTextureSlot.color_factor -> color_factor:   float  "Amount texture affects color values"
#+ * TextureSlot|LampTextureSlot.object -> object:   pointer  "Object to use for mapping with Object texture coordinates"
#+ * TextureSlot|LampTextureSlot.shadow_factor -> shadow_factor:   float  "Amount texture affects shadow"
#TextureSlot|LampTextureSlot.texture_coords -> texture_coords:   enum  "NO DESCRIPTION"
#TextureSlot|LampTextureSlot.use_map_color -> use_map_color:   boolean  "Lets the texture affect the basic color of the lamp"
#TextureSlot|LampTextureSlot.use_map_shadow -> use_map_shadow:   boolean  "Lets the texture affect the shadow color of the lamp"
#+ * TextureSlot|MaterialTextureSlot.alpha_factor -> alpha_factor:   float  "Amount texture affects alpha"
#+ * TextureSlot|MaterialTextureSlot.ambient_factor -> ambient_factor:   float  "Amount texture affects ambient"
#TextureSlot|MaterialTextureSlot.color_emission_factor -> color_emission_factor:   float  "Amount texture affects emission color"
#+ * TextureSlot|MaterialTextureSlot.density_factor -> density_factor:   float  "Amount texture affects density"
#TextureSlot|MaterialTextureSlot.diffuse_color_factor -> diffuse_color_factor:   float  "Amount texture affects diffuse color"
#+ * TextureSlot|MaterialTextureSlot.diffuse_factor -> diffuse_factor:   float  "Amount texture affects diffuse reflectivity"
#+ * TextureSlot|MaterialTextureSlot.displacement_factor -> displacement_factor:   float  "Amount texture displaces the surface"
#+ * TextureSlot|MaterialTextureSlot.emission_factor -> emission_factor:   float  "Amount texture affects emission"
#+ * TextureSlot|MaterialTextureSlot.emit_factor -> emit_factor:   float  "Amount texture affects emission"
#+ * TextureSlot|MaterialTextureSlot.hardness_factor -> hardness_factor:   float  "Amount texture affects hardness"
#+ * TextureSlot|MaterialTextureSlot.mapping -> mapping:   enum  "NO DESCRIPTION"
#TextureSlot|MaterialTextureSlot.mapping_x -> mapping_x:   enum  "NO DESCRIPTION"
#TextureSlot|MaterialTextureSlot.mapping_y -> mapping_y:   enum  "NO DESCRIPTION"
#TextureSlot|MaterialTextureSlot.mapping_z -> mapping_z:   enum  "NO DESCRIPTION"
#+ * TextureSlot|MaterialTextureSlot.mirror_factor -> mirror_factor:   float  "Amount texture affects mirror color"
#+ * TextureSlot|MaterialTextureSlot.normal_factor -> normal_factor:   float  "Amount texture affects normal values"
#+ * TextureSlot|MaterialTextureSlot.normal_map_space -> normal_map_space:   enum  "NO DESCRIPTION"
#+ * TextureSlot|MaterialTextureSlot.object -> object:   pointer  "Object to use for mapping with Object texture coordinates"
#+ * TextureSlot|MaterialTextureSlot.raymir_factor -> raymir_factor:   float  "Amount texture affects ray mirror"
#TextureSlot|MaterialTextureSlot.reflection_color_factor -> reflection_color_factor:   float  "Amount texture affects color of out-scattered light"
#+ * TextureSlot|MaterialTextureSlot.reflection_factor -> reflection_factor:   float  "Amount texture affects brightness of out-scattered light"
#+ * TextureSlot|MaterialTextureSlot.scattering_factor -> scattering_factor:   float  "Amount texture affects scattering"
#TextureSlot|MaterialTextureSlot.specular_color_factor -> specular_color_factor:   float  "Amount texture affects specular color"
#+ * TextureSlot|MaterialTextureSlot.specular_factor -> specular_factor:   float  "Amount texture affects specular reflectivity"
#TextureSlot|MaterialTextureSlot.texture_coords -> texture_coords:   enum  "NO DESCRIPTION"
#+ * TextureSlot|MaterialTextureSlot.translucency_factor -> translucency_factor:   float  "Amount texture affects translucency"
#TextureSlot|MaterialTextureSlot.transmission_color_factor -> transmission_color_factor:   float  "Amount texture affects result color after light has been scattered/absorbed"
#+ * TextureSlot|MaterialTextureSlot.use -> use:   boolean  "Enable this material texture slot"
#TextureSlot|MaterialTextureSlot.use_from_dupli -> use_from_dupli:   boolean  "Duplis instanced from verts, faces or particles, inherit texture coordinate from their parent"
#TextureSlot|MaterialTextureSlot.use_from_original -> use_from_original:   boolean  "Duplis derive their object coordinates from the original objects transformation"
#TextureSlot|MaterialTextureSlot.use_map_alpha -> use_map_alpha:   boolean  "Causes the texture to affect the alpha value"
#TextureSlot|MaterialTextureSlot.use_map_ambient -> use_map_ambient:   boolean  "Causes the texture to affect the value of ambient"
#TextureSlot|MaterialTextureSlot.use_map_color_diffuse -> use_map_color_diffuse:   boolean  "Causes the texture to affect basic color of the material"
#TextureSlot|MaterialTextureSlot.use_map_color_emission -> use_map_color_emission:   boolean  "Causes the texture to affect the color of emission"
#TextureSlot|MaterialTextureSlot.use_map_color_reflection -> use_map_color_reflection:   boolean  "Causes the texture to affect the color of scattered light"
#TextureSlot|MaterialTextureSlot.use_map_color_spec -> use_map_color_spec:   boolean  "Causes the texture to affect the specularity color"
#TextureSlot|MaterialTextureSlot.use_map_color_transmission -> use_map_color_transmission:   boolean  "Causes the texture to affect the result color after other light has been scattered/absorbed"
#TextureSlot|MaterialTextureSlot.use_map_density -> use_map_density:   boolean  "Causes the texture to affect the volumes density"
#TextureSlot|MaterialTextureSlot.use_map_diffuse -> use_map_diffuse:   boolean  "Causes the texture to affect the value of the materials diffuse reflectivity"
#TextureSlot|MaterialTextureSlot.use_map_displacement -> use_map_displacement:   boolean  "Let the texture displace the surface"
#TextureSlot|MaterialTextureSlot.use_map_emission -> use_map_emission:   boolean  "Causes the texture to affect the volumes emission"
#TextureSlot|MaterialTextureSlot.use_map_emit -> use_map_emit:   boolean  "Causes the texture to affect the emit value"
#TextureSlot|MaterialTextureSlot.use_map_hardness -> use_map_hardness:   boolean  "Causes the texture to affect the hardness value"
#TextureSlot|MaterialTextureSlot.use_map_mirror -> use_map_mirror:   boolean  "Causes the texture to affect the mirror color"
#TextureSlot|MaterialTextureSlot.use_map_normal -> use_map_normal:   boolean  "Causes the texture to affect the rendered normal"
#TextureSlot|MaterialTextureSlot.use_map_raymir -> use_map_raymir:   boolean  "Causes the texture to affect the ray-mirror value"
#TextureSlot|MaterialTextureSlot.use_map_reflect -> use_map_reflect:   boolean  "Causes the texture to affect the reflected lights brightness"
#TextureSlot|MaterialTextureSlot.use_map_scatter -> use_map_scatter:   boolean  "Causes the texture to affect the volumes scattering"
#TextureSlot|MaterialTextureSlot.use_map_specular -> use_map_specular:   boolean  "Causes the texture to affect the value of specular reflectivity"
#TextureSlot|MaterialTextureSlot.use_map_translucency -> use_map_translucency:   boolean  "Causes the texture to affect the translucency value"
#TextureSlot|MaterialTextureSlot.use_map_warp -> use_map_warp:   boolean  "Let the texture warp texture coordinates of next channels"
#TextureSlot|MaterialTextureSlot.use_old_bump -> use_old_bump:   boolean  "Use old bump mapping (backwards compatibility option)"
#+ * TextureSlot|MaterialTextureSlot.uv_layer -> uv_layer:   string  "UV layer to use for mapping with UV texture coordinates"
#+ * TextureSlot|MaterialTextureSlot.warp_factor -> warp_factor:   float  "Amount texture affects texture coordinates of next channels"
#+ * TextureSlot|WorldTextureSlot.blend_factor -> blend_factor:   float  "Amount texture affects color progression of the background"
#+ * TextureSlot|WorldTextureSlot.horizon_factor -> horizon_factor:   float  "Amount texture affects color of the horizon"
#+ * TextureSlot|WorldTextureSlot.object -> object:   pointer  "Object to use for mapping with Object texture coordinates"
#TextureSlot|WorldTextureSlot.texture_coords -> texture_coords:   enum  "Texture coordinates used to map the texture onto the background"
#TextureSlot|WorldTextureSlot.use_map_blend -> use_map_blend:   boolean  "Affect the color progression of the background"
#TextureSlot|WorldTextureSlot.use_map_horizon -> use_map_horizon:   boolean  "Affect the color of the horizon"
#TextureSlot|WorldTextureSlot.use_map_zenith_down -> use_map_zenith_down:   boolean  "Affect the color of the zenith below"
#TextureSlot|WorldTextureSlot.use_map_zenith_up -> use_map_zenith_up:   boolean  "Affect the color of the zenith above"
#+ * TextureSlot|WorldTextureSlot.zenith_down_factor -> zenith_down_factor:   float  "Amount texture affects color of the zenith below"
#+ * TextureSlot|WorldTextureSlot.zenith_up_factor -> zenith_up_factor:   float  "Amount texture affects color of the zenith above"
#+ * Theme.bone_color_sets -> bone_color_sets:   collection,  "(read-only)"
#+ * Theme.console -> console:   pointer,  "(read-only)"
#+ * Theme.dopesheet_editor -> dopesheet_editor:   pointer,  "(read-only)"
#+ * Theme.file_browser -> file_browser:   pointer,  "(read-only)"
#+ * Theme.graph_editor -> graph_editor:   pointer,  "(read-only)"
#+ * Theme.image_editor -> image_editor:   pointer,  "(read-only)"
#+ * Theme.info -> info:   pointer,  "(read-only)"
#+ * Theme.logic_editor -> logic_editor:   pointer,  "(read-only)"
#+ * Theme.name -> name:   string  "Name of the theme"
#+ * Theme.nla_editor -> nla_editor:   pointer,  "(read-only)"
#+ * Theme.node_editor -> node_editor:   pointer,  "(read-only)"
#+ * Theme.outliner -> outliner:   pointer,  "(read-only)"
#+ * Theme.properties -> properties:   pointer,  "(read-only)"
#+ * Theme.sequence_editor -> sequence_editor:   pointer,  "(read-only)"
#+ * Theme.text_editor -> text_editor:   pointer,  "(read-only)"
#+ * Theme.theme_area -> theme_area:   enum  "NO DESCRIPTION"
#+ * Theme.timeline -> timeline:   pointer,  "(read-only)"
#+ * Theme.user_interface -> user_interface:   pointer,  "(read-only)"
#+ * Theme.user_preferences -> user_preferences:   pointer,  "(read-only)"
#+ * Theme.view_3d -> view_3d:   pointer,  "(read-only)"
#+ * ThemeAudioWindow.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeAudioWindow.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeAudioWindow.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeAudioWindow.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeAudioWindow.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeAudioWindow.frame_current -> frame_current:   float[3]  "NO DESCRIPTION"
#+ * ThemeAudioWindow.grid -> grid:   float[3]  "NO DESCRIPTION"
#+ * ThemeAudioWindow.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeAudioWindow.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeAudioWindow.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeAudioWindow.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeAudioWindow.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeAudioWindow.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeAudioWindow.window_sliders -> window_sliders:   float[3]  "NO DESCRIPTION"
#+ * ThemeBoneColorSet.active -> active:   float[3]  "Color used for active bones"
#+ * ThemeBoneColorSet.normal -> normal:   float[3]  "Color used for the surface of bones"
#+ * ThemeBoneColorSet.select -> select:   float[3]  "Color used for selected bones"
#ThemeBoneColorSet.show_colored_constraints -> show_colored_constraints:   boolean  "Allow the use of colors indicating constraints/keyed status"
#+ * ThemeConsole.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeConsole.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeConsole.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeConsole.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeConsole.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeConsole.cursor -> cursor:   float[3]  "NO DESCRIPTION"
#+ * ThemeConsole.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeConsole.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeConsole.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeConsole.line_error -> line_error:   float[3]  "NO DESCRIPTION"
#+ * ThemeConsole.line_info -> line_info:   float[3]  "NO DESCRIPTION"
#+ * ThemeConsole.line_input -> line_input:   float[3]  "NO DESCRIPTION"
#+ * ThemeConsole.line_output -> line_output:   float[3]  "NO DESCRIPTION"
#+ * ThemeConsole.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeConsole.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeConsole.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.active_channels_group -> active_channels_group:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.channel_group -> channel_group:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.channels -> channels:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.channels_selected -> channels_selected:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.dopesheet_channel -> dopesheet_channel:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.dopesheet_subchannel -> dopesheet_subchannel:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.frame_current -> frame_current:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.grid -> grid:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.list -> list:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.list_text -> list_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.list_text_hi -> list_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.list_title -> list_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.long_key -> long_key:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.long_key_selected -> long_key_selected:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.value_sliders -> value_sliders:   float[3]  "NO DESCRIPTION"
#+ * ThemeDopeSheet.view_sliders -> view_sliders:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.active_file -> active_file:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.active_file_text -> active_file_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.list -> list:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.list_text -> list_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.list_text_hi -> list_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.list_title -> list_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.scroll_handle -> scroll_handle:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.scrollbar -> scrollbar:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.selected_file -> selected_file:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.tiles -> tiles:   float[3]  "NO DESCRIPTION"
#+ * ThemeFileBrowser.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeFontStyle.font_kerning_style -> font_kerning_style:   enum  "Which style to use for font kerning"
#+ * ThemeFontStyle.points -> points:   int  "NO DESCRIPTION"
#+ * ThemeFontStyle.shadow -> shadow:   int  "Shadow size in pixels (0, 3 and 5 supported)"
#ThemeFontStyle.shadow_offset_x -> shadow_offset_x:   int  "Shadow offset in pixels"
#ThemeFontStyle.shadow_offset_y -> shadow_offset_y:   int  "Shadow offset in pixels"
#+ * ThemeFontStyle.shadowalpha -> shadowalpha:   float  "NO DESCRIPTION"
#+ * ThemeFontStyle.shadowcolor -> shadowcolor:   float  "Shadow color in grey value"
#+ * ThemeGraphEditor.active_channels_group -> active_channels_group:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.channel_group -> channel_group:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.channels_region -> channels_region:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.dopesheet_channel -> dopesheet_channel:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.dopesheet_subchannel -> dopesheet_subchannel:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.frame_current -> frame_current:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.grid -> grid:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.handle_align -> handle_align:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.handle_auto -> handle_auto:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.handle_free -> handle_free:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.handle_sel_align -> handle_sel_align:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.handle_sel_auto -> handle_sel_auto:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.handle_sel_free -> handle_sel_free:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.handle_sel_vect -> handle_sel_vect:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.handle_vect -> handle_vect:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.handle_vertex -> handle_vertex:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.handle_vertex_select -> handle_vertex_select:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.handle_vertex_size -> handle_vertex_size:   int  "NO DESCRIPTION"
#+ * ThemeGraphEditor.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.lastsel_point -> lastsel_point:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.list -> list:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.list_text -> list_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.list_text_hi -> list_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.list_title -> list_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.panel -> panel:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.vertex -> vertex:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.vertex_select -> vertex_select:   float[3]  "NO DESCRIPTION"
#+ * ThemeGraphEditor.vertex_size -> vertex_size:   int  "NO DESCRIPTION"
#+ * ThemeGraphEditor.window_sliders -> window_sliders:   float[3]  "NO DESCRIPTION"
#+ * ThemeImageEditor.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeImageEditor.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeImageEditor.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeImageEditor.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeImageEditor.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeImageEditor.editmesh_active -> editmesh_active:   float[4]  "NO DESCRIPTION"
#+ * ThemeImageEditor.face -> face:   float[4]  "NO DESCRIPTION"
#+ * ThemeImageEditor.face_dot -> face_dot:   float[3]  "NO DESCRIPTION"
#+ * ThemeImageEditor.face_select -> face_select:   float[4]  "NO DESCRIPTION"
#+ * ThemeImageEditor.facedot_size -> facedot_size:   int  "NO DESCRIPTION"
#+ * ThemeImageEditor.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeImageEditor.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeImageEditor.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeImageEditor.scope_back -> scope_back:   float[4]  "NO DESCRIPTION"
#+ * ThemeImageEditor.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeImageEditor.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeImageEditor.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeImageEditor.vertex -> vertex:   float[3]  "NO DESCRIPTION"
#+ * ThemeImageEditor.vertex_select -> vertex_select:   float[3]  "NO DESCRIPTION"
#+ * ThemeImageEditor.vertex_size -> vertex_size:   int  "NO DESCRIPTION"
#+ * ThemeInfo.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeInfo.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeInfo.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeInfo.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeInfo.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeInfo.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeInfo.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeInfo.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeInfo.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeInfo.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeInfo.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeLogicEditor.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeLogicEditor.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeLogicEditor.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeLogicEditor.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeLogicEditor.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeLogicEditor.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeLogicEditor.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeLogicEditor.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeLogicEditor.panel -> panel:   float[3]  "NO DESCRIPTION"
#+ * ThemeLogicEditor.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeLogicEditor.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeLogicEditor.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.bars -> bars:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.bars_selected -> bars_selected:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.frame_current -> frame_current:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.grid -> grid:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.list -> list:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.list_text -> list_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.list_text_hi -> list_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.list_title -> list_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.strips -> strips:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.strips_selected -> strips_selected:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeNLAEditor.view_sliders -> view_sliders:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.converter_node -> converter_node:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.group_node -> group_node:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.in_out_node -> in_out_node:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.list -> list:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.list_text -> list_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.list_text_hi -> list_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.list_title -> list_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.node_backdrop -> node_backdrop:   float[4]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.operator_node -> operator_node:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.selected_text -> selected_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.title -> title:   float[3]  "NO DESCRIPTION"
#ThemeNodeEditor.wire -> wire:   float[3]  "NO DESCRIPTION"
#+ * ThemeNodeEditor.wire_select -> wire_select:   float[3]  "NO DESCRIPTION"
#+ * ThemeOutliner.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeOutliner.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeOutliner.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeOutliner.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeOutliner.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeOutliner.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeOutliner.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeOutliner.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeOutliner.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeOutliner.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeOutliner.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeProperties.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeProperties.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeProperties.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeProperties.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeProperties.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeProperties.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeProperties.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeProperties.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeProperties.panel -> panel:   float[3]  "NO DESCRIPTION"
#+ * ThemeProperties.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeProperties.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeProperties.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.audio_strip -> audio_strip:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.draw_action -> draw_action:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.effect_strip -> effect_strip:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.frame_current -> frame_current:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.grid -> grid:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.image_strip -> image_strip:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.keyframe -> keyframe:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.meta_strip -> meta_strip:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.movie_strip -> movie_strip:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.plugin_strip -> plugin_strip:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.scene_strip -> scene_strip:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.transition_strip -> transition_strip:   float[3]  "NO DESCRIPTION"
#+ * ThemeSequenceEditor.window_sliders -> window_sliders:   float[3]  "NO DESCRIPTION"
#ThemeStyle.group_label -> group_label:   pointer,  "(read-only)"
#ThemeStyle.panel_title -> panel_title:   pointer,  "(read-only)"
#+ * ThemeStyle.panelzoom -> panelzoom:   float  "Default zoom level for panel areas"
#+ * ThemeStyle.widget -> widget:   pointer,  "(read-only)"
#ThemeStyle.widget_label -> widget_label:   pointer,  "(read-only)"
#+ * ThemeTextEditor.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.cursor -> cursor:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.line_numbers_background -> line_numbers_background:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.scroll_bar -> scroll_bar:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.selected_text -> selected_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.syntax_builtin -> syntax_builtin:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.syntax_comment -> syntax_comment:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.syntax_numbers -> syntax_numbers:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.syntax_special -> syntax_special:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.syntax_string -> syntax_string:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeTextEditor.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeTimeline.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeTimeline.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeTimeline.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeTimeline.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeTimeline.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeTimeline.frame_current -> frame_current:   float[3]  "NO DESCRIPTION"
#+ * ThemeTimeline.grid -> grid:   float[3]  "NO DESCRIPTION"
#+ * ThemeTimeline.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeTimeline.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeTimeline.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeTimeline.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeTimeline.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeTimeline.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeUserInterface.icon_file -> icon_file:   string  "NO DESCRIPTION"
#+ * ThemeUserInterface.wcol_box -> wcol_box:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_list_item -> wcol_list_item:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_menu -> wcol_menu:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_menu_back -> wcol_menu_back:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_menu_item -> wcol_menu_item:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_num -> wcol_num:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_numslider -> wcol_numslider:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_option -> wcol_option:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_progress -> wcol_progress:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_pulldown -> wcol_pulldown:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_radio -> wcol_radio:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_regular -> wcol_regular:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_scroll -> wcol_scroll:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_state -> wcol_state:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_text -> wcol_text:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_toggle -> wcol_toggle:   pointer,  "(read-only)"
#+ * ThemeUserInterface.wcol_tool -> wcol_tool:   pointer,  "(read-only)"
#+ * ThemeUserPreferences.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeUserPreferences.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeUserPreferences.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeUserPreferences.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeUserPreferences.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeUserPreferences.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeUserPreferences.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeUserPreferences.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeUserPreferences.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeUserPreferences.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeUserPreferences.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.act_spline -> act_spline:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.back -> back:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.bone_pose -> bone_pose:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.bone_solid -> bone_solid:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.button -> button:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.button_text -> button_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.button_text_hi -> button_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.button_title -> button_title:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.edge_crease -> edge_crease:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.edge_facesel -> edge_facesel:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.edge_seam -> edge_seam:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.edge_select -> edge_select:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.edge_sharp -> edge_sharp:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.editmesh_active -> editmesh_active:   float[4]  "NO DESCRIPTION"
#+ * ThemeView3D.face -> face:   float[4]  "NO DESCRIPTION"
#+ * ThemeView3D.face_dot -> face_dot:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.face_select -> face_select:   float[4]  "NO DESCRIPTION"
#+ * ThemeView3D.facedot_size -> facedot_size:   int  "NO DESCRIPTION"
#+ * ThemeView3D.frame_current -> frame_current:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.grid -> grid:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.handle_align -> handle_align:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.handle_auto -> handle_auto:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.handle_free -> handle_free:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.handle_sel_align -> handle_sel_align:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.handle_sel_auto -> handle_sel_auto:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.handle_sel_free -> handle_sel_free:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.handle_sel_vect -> handle_sel_vect:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.handle_vect -> handle_vect:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.header -> header:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.header_text -> header_text:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.header_text_hi -> header_text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.lamp -> lamp:   float[4]  "NO DESCRIPTION"
#+ * ThemeView3D.lastsel_point -> lastsel_point:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.normal -> normal:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.nurb_sel_uline -> nurb_sel_uline:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.nurb_sel_vline -> nurb_sel_vline:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.nurb_uline -> nurb_uline:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.nurb_vline -> nurb_vline:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.object_active -> object_active:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.object_grouped -> object_grouped:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.object_grouped_active -> object_grouped_active:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.object_selected -> object_selected:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.panel -> panel:   float[4]  "NO DESCRIPTION"
#+ * ThemeView3D.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.text_hi -> text_hi:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.title -> title:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.transform -> transform:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.vertex -> vertex:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.vertex_normal -> vertex_normal:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.vertex_select -> vertex_select:   float[3]  "NO DESCRIPTION"
#+ * ThemeView3D.vertex_size -> vertex_size:   int  "NO DESCRIPTION"
#+ * ThemeView3D.wire -> wire:   float[3]  "NO DESCRIPTION"
#+ * ThemeWidgetColors.inner -> inner:   float[4]  "NO DESCRIPTION"
#+ * ThemeWidgetColors.inner_sel -> inner_sel:   float[4]  "NO DESCRIPTION"
#+ * ThemeWidgetColors.item -> item:   float[4]  "NO DESCRIPTION"
#+ * ThemeWidgetColors.outline -> outline:   float[3]  "NO DESCRIPTION"
#+ * ThemeWidgetColors.shadedown -> shadedown:   int  "NO DESCRIPTION"
#+ * ThemeWidgetColors.shadetop -> shadetop:   int  "NO DESCRIPTION"
#ThemeWidgetColors.show_shaded -> show_shaded:   boolean  "NO DESCRIPTION"
#+ * ThemeWidgetColors.text -> text:   float[3]  "NO DESCRIPTION"
#+ * ThemeWidgetColors.text_sel -> text_sel:   float[3]  "NO DESCRIPTION"
#+ * ThemeWidgetStateColors.blend -> blend:   float  "NO DESCRIPTION"
#+ * ThemeWidgetStateColors.inner_anim -> inner_anim:   float[3]  "NO DESCRIPTION"
#+ * ThemeWidgetStateColors.inner_anim_sel -> inner_anim_sel:   float[3]  "NO DESCRIPTION"
#+ * ThemeWidgetStateColors.inner_driven -> inner_driven:   float[3]  "NO DESCRIPTION"
#+ * ThemeWidgetStateColors.inner_driven_sel -> inner_driven_sel:   float[3]  "NO DESCRIPTION"
#+ * ThemeWidgetStateColors.inner_key -> inner_key:   float[3]  "NO DESCRIPTION"
#+ * ThemeWidgetStateColors.inner_key_sel -> inner_key_sel:   float[3]  "NO DESCRIPTION"
#+ * TimelineMarker.camera -> camera:   pointer  "Camera this timeline sets to active"
#+ * TimelineMarker.frame -> frame:   int  "The frame on which the timeline marker appears"
#+ * TimelineMarker.name -> name:   string  "NO DESCRIPTION"
#+ * TimelineMarker.select -> select:   boolean  "Marker selection state"
#ToolSettings.auto_keying_mode -> auto_keying_mode:   enum  "Mode of automatic keyframe insertion for Objects and Bones"
#+ * ToolSettings.edge_path_mode -> edge_path_mode:   enum  "The edge flag to tag when selecting the shortest path"
#+ * ToolSettings.etch_adaptive_limit -> etch_adaptive_limit:   float  "Number of bones in the subdivided stroke"
#+ * ToolSettings.etch_convert_mode -> etch_convert_mode:   enum  "Method used to convert stroke to bones"
#+ * ToolSettings.etch_length_limit -> etch_length_limit:   float  "Number of bones in the subdivided stroke"
#+ * ToolSettings.etch_number -> etch_number:   string  "DOC BROKEN"
#+ * ToolSettings.etch_roll_mode -> etch_roll_mode:   enum  "Method used to adjust the roll of bones when retargeting"
#+ * ToolSettings.etch_side -> etch_side:   string  "DOC BROKEN"
#+ * ToolSettings.etch_subdivision_number -> etch_subdivision_number:   int  "Number of bones in the subdivided stroke"
#+ * ToolSettings.etch_template -> etch_template:   pointer  "Template armature that will be retargeted to the stroke"
#+ * ToolSettings.image_paint -> image_paint:   pointer,  "(read-only)"
#ToolSettings.mesh_select_mode -> mesh_select_mode:   boolean[3]  "Which mesh elements selection works on"
#+ * ToolSettings.normal_size -> normal_size:   float  "Display size for normals in the 3D view"
#+ * ToolSettings.particle_edit -> particle_edit:   pointer,  "(read-only)"
#ToolSettings.proportional_edit -> proportional_edit:   enum  "Proportional editing mode"
#ToolSettings.proportional_edit_falloff -> proportional_edit_falloff:   enum  "Falloff type for proportional editing mode"
#+ * ToolSettings.sculpt -> sculpt:   pointer,  "(read-only)"
#+ * ToolSettings.sculpt_paint_use_unified_size -> sculpt_paint_use_unified_size:   boolean  "Instead of per brush radius, the radius is shared across brushes"
#+ * ToolSettings.sculpt_paint_use_unified_strength -> sculpt_paint_use_unified_strength:   boolean  "Instead of per brush strength, the strength is shared across brushes"
#ToolSettings.show_uv_local_view -> show_uv_local_view:   boolean  "Draw only faces with the currently displayed image assigned"
#+ * ToolSettings.snap_element -> snap_element:   enum  "Type of element to snap to"
#+ * ToolSettings.snap_target -> snap_target:   enum  "Which part to snap onto the target"
#ToolSettings.use_auto_normalize -> use_auto_normalize:   boolean  "Ensure all bone-deforming vertex groups add up to 1.0 while weight painting"
#ToolSettings.use_bone_sketching -> use_bone_sketching:   boolean  "DOC BROKEN"
#ToolSettings.use_etch_autoname -> use_etch_autoname:   boolean  "DOC BROKEN"
#ToolSettings.use_etch_overdraw -> use_etch_overdraw:   boolean  "DOC BROKEN"
#ToolSettings.use_etch_quick -> use_etch_quick:   boolean  "DOC BROKEN"
#ToolSettings.use_keyframe_insert_auto -> use_keyframe_insert_auto:   boolean  "Automatic keyframe insertion for Objects and Bones"
#ToolSettings.use_mesh_automerge -> use_mesh_automerge:   boolean  "Automatically merge vertices moved to the same location"
#ToolSettings.use_proportional_edit_objects -> use_proportional_edit_objects:   boolean  "Proportional editing object mode"
#ToolSettings.use_record_with_nla -> use_record_with_nla:   boolean  "Add a new NLA Track + Strip for every loop/pass made over the animation to allow non-destructive tweaking"
#ToolSettings.use_snap -> use_snap:   boolean  "Snap during transform"
#ToolSettings.use_snap_align_rotation -> use_snap_align_rotation:   boolean  "Align rotation with the snapping target"
#ToolSettings.use_snap_peel_object -> use_snap_peel_object:   boolean  "Consider objects as whole when finding volume center"
#ToolSettings.use_snap_project -> use_snap_project:   boolean  "Project vertices on the surface of other objects"
#ToolSettings.use_uv_select_sync -> use_uv_select_sync:   boolean  "Keep UV and edit mode mesh selection in sync"
#ToolSettings.uv_select_mode -> uv_select_mode:   enum  "UV selection and display mode"
#+ * ToolSettings.vertex_group_weight -> vertex_group_weight:   float  "Weight to assign in vertex groups"
#+ * ToolSettings.vertex_paint -> vertex_paint:   pointer,  "(read-only)"
#+ * ToolSettings.weight_paint -> weight_paint:   pointer,  "(read-only)"
#+ * TransformOrientation.matrix -> matrix:   float[9]  "NO DESCRIPTION"
#+ * TransformOrientation.name -> name:   string  "NO DESCRIPTION"
#+ * UILayout.alignment -> alignment:   enum  "NO DESCRIPTION"
#+ * UILayout.operator_context -> operator_context:   enum  "NO DESCRIPTION"
#+ * UILayout.scale_x -> scale_x:   float  "Scale factor along the X for items in this (sub)layout."
#+ * UILayout.scale_y -> scale_y:   float  "Scale factor along the Y for items in this (sub)layout."
 + * UILayout.active -> show_active:   boolean  "NO DESCRIPTION"
 + * UILayout.enabled -> show_enabled:   boolean  "When false, this (sub)layout is greyed out."
#+ * UVProjector.object -> object:   pointer  "Object to use as projector transform"
#UVTextures.active -> active:   pointer  "Active UV texture"
#+ * UnitSettings.rotation_units -> rotation_units:   enum  "Unit to use for displaying/editing rotation values"
#+ * UnitSettings.scale_length -> scale_length:   float  "Scale to use when converting between blender units and dimensions"
#+ * UnitSettings.system -> system:   enum  "The unit system to use for button display"
#+ * UnitSettings.use_separate -> use_separate:   boolean  "Display units in pairs"
#+ * UserPreferences.active_section -> active_section:   enum  "Active section of the user preferences shown in the user interface"
#+ * UserPreferences.addons -> addons:   collection,  "(read-only)"
#+ * UserPreferences.edit -> edit:   pointer,  "(read-only)    Settings for interacting with Blender data"
#+ * UserPreferences.filepaths -> filepaths:   pointer,  "(read-only)    Default paths for external files"
#+ * UserPreferences.inputs -> inputs:   pointer,  "(read-only)    Settings for input devices"
#+ * UserPreferences.system -> system:   pointer,  "(read-only)    Graphics driver and operating system settings"
#+ * UserPreferences.themes -> themes:   collection,  "(read-only)"
#UserPreferences.ui_styles -> ui_styles:   collection,  "(read-only)"
#+ * UserPreferences.view -> view:   pointer,  "(read-only)    Preferences related to viewing data"
#+ * UserPreferencesEdit.auto_keying_mode -> auto_keying_mode:   enum  "Mode of automatic keyframe insertion for Objects and Bones"
#+ * UserPreferencesEdit.grease_pencil_eraser_radius -> grease_pencil_eraser_radius:   int  "Radius of eraser brush"
#+ * UserPreferencesEdit.grease_pencil_euclidean_distance -> grease_pencil_euclidean_distance:   int  "Distance moved by mouse when drawing stroke (in pixels) to include"
#+ * UserPreferencesEdit.grease_pencil_manhattan_distance -> grease_pencil_manhattan_distance:   int  "Pixels moved by mouse per axis when drawing stroke"
#+ * UserPreferencesEdit.keyframe_new_handle_type -> keyframe_new_handle_type:   enum  "NO DESCRIPTION"
#+ * UserPreferencesEdit.keyframe_new_interpolation_type -> keyframe_new_interpolation_type:   enum  "NO DESCRIPTION"
#+ * UserPreferencesEdit.material_link -> material_link:   enum  "Toggle whether the material is linked to object data or the object block"
#+ * UserPreferencesEdit.object_align -> object_align:   enum  "When adding objects from a 3D View menu, either align them to that views direction or the world coordinates"
#UserPreferencesEdit.sculpt_paint_overlay_color -> sculpt_paint_overlay_color:   float[3]  "Color of texture overlay"
#+ * UserPreferencesEdit.undo_memory_limit -> undo_memory_limit:   int  "Maximum memory usage in megabytes (0 means unlimited)"
#+ * UserPreferencesEdit.undo_steps -> undo_steps:   int  "Number of undo steps available (smaller values conserve memory)"
#+ * UserPreferencesEdit.use_auto_keying -> use_auto_keying:   boolean  "Automatic keyframe insertion for Objects and Bones"
#UserPreferencesEdit.use_drag_immediately -> use_drag_immediately:   boolean  "Moving things with a mouse drag confirms when releasing the button"
#UserPreferencesEdit.use_duplicate_action -> use_duplicate_action:   boolean  "Causes actions to be duplicated with the object"
#UserPreferencesEdit.use_duplicate_armature -> use_duplicate_armature:   boolean  "Causes armature data to be duplicated with the object"
#UserPreferencesEdit.use_duplicate_curve -> use_duplicate_curve:   boolean  "Causes curve data to be duplicated with the object"
#UserPreferencesEdit.use_duplicate_fcurve -> use_duplicate_fcurve:   boolean  "Causes F-curve data to be duplicated with the object"
#UserPreferencesEdit.use_duplicate_lamp -> use_duplicate_lamp:   boolean  "Causes lamp data to be duplicated with the object"
#UserPreferencesEdit.use_duplicate_material -> use_duplicate_material:   boolean  "Causes material data to be duplicated with the object"
#UserPreferencesEdit.use_duplicate_mesh -> use_duplicate_mesh:   boolean  "Causes mesh data to be duplicated with the object"
#UserPreferencesEdit.use_duplicate_metaball -> use_duplicate_metaball:   boolean  "Causes metaball data to be duplicated with the object"
#UserPreferencesEdit.use_duplicate_particle -> use_duplicate_particle:   boolean  "Causes particle systems to be duplicated with the object"
#UserPreferencesEdit.use_duplicate_surface -> use_duplicate_surface:   boolean  "Causes surface data to be duplicated with the object"
#UserPreferencesEdit.use_duplicate_text -> use_duplicate_text:   boolean  "Causes text data to be duplicated with the object"
#UserPreferencesEdit.use_duplicate_texture -> use_duplicate_texture:   boolean  "Causes texture data to be duplicated with the object"
#UserPreferencesEdit.use_enter_edit_mode -> use_enter_edit_mode:   boolean  "Enter Edit Mode automatically after adding a new object"
#UserPreferencesEdit.use_global_undo -> use_global_undo:   boolean  "Global undo works by keeping a full copy of the file itself in memory, so takes extra memory"
#UserPreferencesEdit.use_grease_pencil_simplify_stroke -> use_grease_pencil_simplify_stroke:   boolean  "Simplify the final stroke"
#UserPreferencesEdit.use_grease_pencil_smooth_stroke -> use_grease_pencil_smooth_stroke:   boolean  "Smooth the final stroke"
#UserPreferencesEdit.use_insertkey_xyz_to_rgb -> use_insertkey_xyz_to_rgb:   boolean  "Color for newly added transformation F-Curves (Location, Rotation, Scale) and also Color is based on the transform axis"
#UserPreferencesEdit.use_keyframe_insert_available -> use_keyframe_insert_available:   boolean  "Automatic keyframe insertion in available curves"
#UserPreferencesEdit.use_keyframe_insert_keyingset -> use_keyframe_insert_keyingset:   boolean  "Automatic keyframe insertion using active Keying Set"
#UserPreferencesEdit.use_keyframe_insert_needed -> use_keyframe_insert_needed:   boolean  "Keyframe insertion only when keyframe needed"
#+ * UserPreferencesEdit.use_negative_frames -> use_negative_frames:   boolean  "Current frame number can be manually set to a negative value"
#+ * UserPreferencesEdit.use_visual_keying -> use_visual_keying:   boolean  "Use Visual keying automatically for constrained objects"
#+ * UserPreferencesFilePaths.animation_player -> animation_player:   string  "Path to a custom animation/frame sequence player"
#+ * UserPreferencesFilePaths.animation_player_preset -> animation_player_preset:   enum  "Preset configs for external animation players"
#+ * UserPreferencesFilePaths.auto_save_time -> auto_save_time:   int  "The time (in minutes) to wait between automatic temporary saves"
#UserPreferencesFilePaths.font_directory -> font_directory:   string  "The default directory to search for loading fonts"
#+ * UserPreferencesFilePaths.image_editor -> image_editor:   string  "Path to an image editor"
#+ * UserPreferencesFilePaths.recent_files -> recent_files:   int  "Maximum number of recently opened files to remember"
#+ * UserPreferencesFilePaths.render_output_directory -> render_output_directory:   string  "The default directory for rendering output"
#+ * UserPreferencesFilePaths.save_version -> save_version:   int  "The number of old versions to maintain in the current directory, when manually saving"
#UserPreferencesFilePaths.script_directory -> script_directory:   string  "The default directory to search for Python scripts (resets python module search path: sys.path)"
#+ * UserPreferencesFilePaths.sequence_plugin_directory -> sequence_plugin_directory:   string  "The default directory to search for sequence plugins"
#UserPreferencesFilePaths.show_hidden_files_datablocks -> show_hidden_files_datablocks:   boolean  "Hide files/datablocks that start with a dot(.*)"
#UserPreferencesFilePaths.sound_directory -> sound_directory:   string  "The default directory to search for sounds"
#+ * UserPreferencesFilePaths.temporary_directory -> temporary_directory:   string  "The directory for storing temporary save files"
#UserPreferencesFilePaths.texture_directory -> texture_directory:   string  "The default directory to search for textures"
#+ * UserPreferencesFilePaths.texture_plugin_directory -> texture_plugin_directory:   string  "The default directory to search for texture plugins"
#UserPreferencesFilePaths.use_auto_save_temporary_files -> use_auto_save_temporary_files:   boolean  "Automatic saving of temporary files"
#UserPreferencesFilePaths.use_file_compression -> use_file_compression:   boolean  "Enable file compression when saving .blend files"
#UserPreferencesFilePaths.use_filter_files -> use_filter_files:   boolean  "Display only files with extensions in the image select window"
#UserPreferencesFilePaths.use_load_ui -> use_load_ui:   boolean  "Load user interface setup when loading .blend files"
#+ * UserPreferencesFilePaths.use_relative_paths -> use_relative_paths:   boolean  "Default relative path option for the file selector"
#UserPreferencesFilePaths.use_save_preview_images -> use_save_preview_images:   boolean  "Enables automatic saving of preview images in the .blend file"
#+ * UserPreferencesInput.edited_keymaps -> edited_keymaps:   collection,  "(read-only)"
#UserPreferencesInput.invert_mouse_wheel_zoom -> invert_mouse_wheel_zoom:   boolean  "Invert the axis of mouse movement for zooming"
#UserPreferencesInput.invert_zoom_wheel -> invert_zoom_wheel:   boolean  "Swap the Mouse Wheel zoom direction"
#UserPreferencesInput.mouse_double_click_time -> mouse_double_click_time:   int  "The time (in ms) for a double click"
#+ * UserPreferencesInput.ndof_pan_speed -> ndof_pan_speed:   int  "The overall panning speed of an NDOF device, as percent of standard"
#+ * UserPreferencesInput.ndof_rotate_speed -> ndof_rotate_speed:   int  "The overall rotation speed of an NDOF device, as percent of standard"
#+ * UserPreferencesInput.select_mouse -> select_mouse:   enum  "The mouse button used for selection"
#UserPreferencesInput.use_emulate_numpad -> use_emulate_numpad:   boolean  "Causes the 1 to 0 keys to act as the numpad (useful for laptops)"
#UserPreferencesInput.use_mouse_continuous -> use_mouse_continuous:   boolean  "Allow moving the mouse outside the view on some manipulations (transform, ui control drag)"
#UserPreferencesInput.use_mouse_emulate_3_button -> use_mouse_emulate_3_button:   boolean  "Emulates Middle Mouse with Alt+LeftMouse (doesnt work with Left Mouse Select option)"
#UserPreferencesInput.use_mouse_mmb_paste -> use_mouse_mmb_paste:   boolean  "In text window, paste with middle mouse button instead of panning"
#UserPreferencesInput.view_rotate_method -> view_rotate_method:   enum  "Rotation style in the viewport"
#UserPreferencesInput.view_zoom_axis -> view_zoom_axis:   enum  "Axis of mouse movement to zoom in or out on"
#UserPreferencesInput.view_zoom_method -> view_zoom_method:   enum  "Which style to use for viewport scaling"
#+ * UserPreferencesInput.wheel_scroll_lines -> wheel_scroll_lines:   int  "The number of lines scrolled at a time with the mouse wheel"
#+ * UserPreferencesSystem.audio_channels -> audio_channels:   enum  "Sets the audio channel count"
#+ * UserPreferencesSystem.audio_device -> audio_device:   enum  "Sets the audio output device"
#+ * UserPreferencesSystem.audio_mixing_buffer -> audio_mixing_buffer:   enum  "Sets the number of samples used by the audio mixing buffer"
#+ * UserPreferencesSystem.audio_sample_format -> audio_sample_format:   enum  "Sets the audio sample format"
#+ * UserPreferencesSystem.audio_sample_rate -> audio_sample_rate:   enum  "Sets the audio sample rate"
#+ * UserPreferencesSystem.color_picker_type -> color_picker_type:   enum  "Different styles of displaying the color picker widget"
#+ * UserPreferencesSystem.dpi -> dpi:   int  "Font size and resolution for display"
#+ * UserPreferencesSystem.frame_server_port -> frame_server_port:   int  "Frameserver Port for Frameserver Rendering"
#UserPreferencesSystem.gl_clip_alpha -> gl_clip_alpha:   float  "Clip alpha below this threshold in the 3D textured view"
#+ * UserPreferencesSystem.gl_texture_limit -> gl_texture_limit:   enum  "Limit the texture size to save graphics memory"
#+ * UserPreferencesSystem.language -> language:   enum  "Language use for translation"
#+ * UserPreferencesSystem.memory_cache_limit -> memory_cache_limit:   int  "Memory cache limit in sequencer (megabytes)"
#+ * UserPreferencesSystem.prefetch_frames -> prefetch_frames:   int  "Number of frames to render ahead during playback"
#+ * UserPreferencesSystem.screencast_fps -> screencast_fps:   int  "Frame rate for the screencast to be played back"
#+ * UserPreferencesSystem.screencast_wait_time -> screencast_wait_time:   int  "Time in milliseconds between each frame recorded for screencast"
#+ * UserPreferencesSystem.scrollback -> scrollback:   int  "Maximum number of lines to store for the console buffer"
#+ * UserPreferencesSystem.solid_lights -> solid_lights:   collection,  "(read-only)    Lights user to display objects in solid draw mode"
#+ * UserPreferencesSystem.texture_collection_rate -> texture_collection_rate:   int  "Number of seconds between each run of the GL texture garbage collector"
#+ * UserPreferencesSystem.texture_time_out -> texture_time_out:   int  "Time since last access of a GL texture in seconds after which it is freed. (Set to 0 to keep textures allocated.)"
#+ * UserPreferencesSystem.use_antialiasing -> use_antialiasing:   boolean  "Use anti-aliasing for the 3D view (may impact redraw performance)"
#UserPreferencesSystem.use_international_fonts -> use_international_fonts:   boolean  "Use international fonts"
#+ * UserPreferencesSystem.use_mipmaps -> use_mipmaps:   boolean  "Scale textures for the 3D View (looks nicer but uses more memory and slows image reloading)"
#UserPreferencesSystem.use_preview_images -> use_preview_images:   boolean  "Enables automatic saving of preview images in the .blend file (Windows only)"
#UserPreferencesSystem.use_scripts_auto_execute -> use_scripts_auto_execute:   boolean  "Allow any .blend file to run scripts automatically (unsafe with blend files from an untrusted source)"
#UserPreferencesSystem.use_tabs_as_spaces -> use_tabs_as_spaces:   boolean  "Automatically converts all new tabs into spaces for new and loaded text files"
#+ * UserPreferencesSystem.use_textured_fonts -> use_textured_fonts:   boolean  "Use textures for drawing international fonts"
#UserPreferencesSystem.use_translate_buttons -> use_translate_buttons:   boolean  "Translate button labels"
#UserPreferencesSystem.use_translate_toolbox -> use_translate_toolbox:   boolean  "Translate toolbox menu"
#UserPreferencesSystem.use_translate_tooltips -> use_translate_tooltips:   boolean  "Translate Tooltips"
#UserPreferencesSystem.use_vertex_buffer_objects -> use_vertex_buffer_objects:   boolean  "Use Vertex Buffer Objects (or Vertex Arrays, if unsupported) for viewport rendering"
#+ * UserPreferencesSystem.use_weight_color_range -> use_weight_color_range:   boolean  "Enable color range used for weight visualization in weight painting mode"
#+ * UserPreferencesSystem.weight_color_range -> weight_color_range:   pointer,  "(read-only)    Color range used for weight visualization in weight painting mode"
#+ * UserPreferencesSystem.window_draw_method -> window_draw_method:   enum  "Drawing method used by the window manager"
#+ * UserPreferencesView.manipulator_handle_size -> manipulator_handle_size:   int  "Size of widget handles as percentage of widget radius"
#+ * UserPreferencesView.manipulator_hotspot -> manipulator_hotspot:   int  "Hotspot in pixels for clicking widget handles"
#+ * UserPreferencesView.manipulator_size -> manipulator_size:   int  "Diameter of widget, in 10 pixel units"
#+ * UserPreferencesView.mini_axis_brightness -> mini_axis_brightness:   int  "The brightness of the icon"
#+ * UserPreferencesView.mini_axis_size -> mini_axis_size:   int  "The axis icons size"
#+ * UserPreferencesView.object_origin_size -> object_origin_size:   int  "Diameter in Pixels for Object/Lamp origin display"
#+ * UserPreferencesView.open_left_mouse_delay -> open_left_mouse_delay:   int  "Time in 1/10 seconds to hold the Left Mouse Button before opening the toolbox"
#+ * UserPreferencesView.open_right_mouse_delay -> open_right_mouse_delay:   int  "Time in 1/10 seconds to hold the Right Mouse Button before opening the toolbox"
#+ * UserPreferencesView.open_sublevel_delay -> open_sublevel_delay:   int  "Time delay in 1/10 seconds before automatically opening sub level menus"
#+ * UserPreferencesView.open_toplevel_delay -> open_toplevel_delay:   int  "Time delay in 1/10 seconds before automatically opening top level menus"
#+ * UserPreferencesView.rotation_angle -> rotation_angle:   int  "The rotation step for numerical pad keys (2 4 6 8)"
#UserPreferencesView.show_column_layout -> show_column_layout:   boolean  "Use a column layout for toolbox"
#UserPreferencesView.show_large_cursors -> show_large_cursors:   boolean  "Use large mouse cursors when available"
#UserPreferencesView.show_manipulator -> show_manipulator:   boolean  "Use 3D transform manipulator"
#+ * UserPreferencesView.show_mini_axis -> show_mini_axis:   boolean  "Show a small rotating 3D axis in the bottom left corner of the 3D View"
#UserPreferencesView.show_object_info -> show_object_info:   boolean  "Display objects name and frame number in 3D view"
#+ * UserPreferencesView.show_playback_fps -> show_playback_fps:   boolean  "Show the frames per second screen refresh rate, while animation is played back"
#+ * UserPreferencesView.show_splash -> show_splash:   boolean  "Display splash screen on startup"
#UserPreferencesView.show_tooltips -> show_tooltips:   boolean  "Display tooltips"
#+ * UserPreferencesView.show_view_name -> show_view_name:   boolean  "Show the name of the views direction in each 3D View"
#+ * UserPreferencesView.smooth_view -> smooth_view:   int  "The time to animate the view in milliseconds, zero to disable"
#+ * UserPreferencesView.timecode_style -> timecode_style:   enum  "Format of Time Codes displayed when not displaying timing in terms of frames"
#UserPreferencesView.use_auto_perspective -> use_auto_perspective:   boolean  "Automatically switch between orthographic and perspective when changing from top/front/side views"
#UserPreferencesView.use_directional_menus -> use_directional_menus:   boolean  "Otherwise menus, etc will always be top to bottom, left to right, no matter opening direction"
#UserPreferencesView.use_global_pivot -> use_global_pivot:   boolean  "Lock the same rotation/scaling pivot in all 3D Views"
#UserPreferencesView.use_global_scene -> use_global_scene:   boolean  "Forces the current Scene to be displayed in all Screens"
#UserPreferencesView.use_mouse_auto_depth -> use_mouse_auto_depth:   boolean  "Use the depth under the mouse to improve view pan/rotate/zoom functionality"
#UserPreferencesView.use_mouse_over_open -> use_mouse_over_open:   boolean  "Open menu buttons and pulldowns automatically when the mouse is hovering"
#UserPreferencesView.use_rotate_around_active -> use_rotate_around_active:   boolean  "Use selection as the pivot point"
#UserPreferencesView.use_zoom_to_mouse -> use_zoom_to_mouse:   boolean  "Zoom in towards the mouse pointers position in the 3D view, rather than the 2D window center"
#UserPreferencesView.view2d_grid_spacing_min -> view2d_grid_spacing_min:   int  "Minimum number of pixels between each gridline in 2D Viewports"
#+ * UserSolidLight.diffuse_color -> diffuse_color:   float[3]  "The diffuse color of the OpenGL light"
#+ * UserSolidLight.direction -> direction:   float[3]  "The direction that the OpenGL light is shining"
#+ * UserSolidLight.specular_color -> specular_color:   float[3]  "The color of the lights specular highlight"
#+ * UserSolidLight.use -> use:   boolean  "Enable this OpenGL light in solid draw mode"
#+ * ValueNodeSocket.default_value -> default_value:   float[1]  "Default value of the socket when no link is attached"
#+ * ValueNodeSocket.name -> name:   string,  "(read-only)    Socket name"
#+ * VectorNodeSocket.default_value -> default_value:   float[3]  "Default value of the socket when no link is attached"
#+ * VectorNodeSocket.name -> name:   string,  "(read-only)    Socket name"
#VertexColors.active -> active:   pointer  "Active vertex color layer"
#+ * VertexGroup.index -> index:   int,  "(read-only)    Index number of the vertex group"
#+ * VertexGroup.name -> name:   string  "Vertex group name"
#+ * VertexGroupElement.group -> group:   int,  "(read-only)"
#+ * VertexGroupElement.weight -> weight:   float  "Vertex Weight"
#+ * VoxelData.domain_object -> domain_object:   pointer  "Object used as the smoke simulation domain"
#+ * VoxelData.extension -> extension:   enum  "Sets how the texture is extrapolated past its original bounds"
#+ * VoxelData.file_format -> file_format:   enum  "Format of the source data set to render"
#VoxelData.filepath -> filepath:   string  "The external source data file to use"
#+ * VoxelData.intensity -> intensity:   float  "Multiplier for intensity values"
#+ * VoxelData.interpolation -> interpolation:   enum  "Method to interpolate/smooth values between voxel cells"
#+ * VoxelData.resolution -> resolution:   int[3]  "Resolution of the voxel grid"
#+ * VoxelData.smoke_data_type -> smoke_data_type:   enum  "Simulation value to be used as a texture"
#VoxelData.still_frame -> still_frame:   int  "The frame number to always use"
#VoxelData.use_still_frame -> use_still_frame:   boolean  "Always render a still frame from the voxel data sequence"
#+ * Window.screen -> screen:   pointer  "Active screen showing in the window"
#+ * WorldLighting.adapt_to_speed -> adapt_to_speed:   float  "Use the speed vector pass to reduce AO samples in fast moving pixels. Higher values result in more aggressive sample reduction. Requires Vec pass enabled (for Raytrace Adaptive QMC)"
#WorldLighting.ao_blend_type -> ao_blend_type:   enum  "Defines how AO mixes with material shading"
#+ * WorldLighting.ao_factor -> ao_factor:   float  "Factor for ambient occlusion blending"
#+ * WorldLighting.bias -> bias:   float  "Bias (in radians) to prevent smoothed faces from showing banding (for Raytrace Constant Jittered)"
#+ * WorldLighting.correction -> correction:   float  "Ad-hoc correction for over-occlusion due to the approximation (for Approximate)"
#+ * WorldLighting.distance -> distance:   float  "Length of rays, defines how far away other faces give occlusion effect"
#+ * WorldLighting.environment_color -> environment_color:   enum  "Defines where the color of the environment light comes from"
#+ * WorldLighting.environment_energy -> environment_energy:   float  "Defines the strength of environment light"
#WorldLighting.error_threshold -> error_threshold:   float  "Low values are slower and higher quality (for Approximate)"
#+ * WorldLighting.falloff_strength -> falloff_strength:   float  "Distance attenuation factor, the higher, the shorter the shadows"
#+ * WorldLighting.gather_method -> gather_method:   enum  "NO DESCRIPTION"
#+ * WorldLighting.indirect_bounces -> indirect_bounces:   int  "Number of indirect diffuse light bounces to use for approximate ambient occlusion"
#+ * WorldLighting.indirect_factor -> indirect_factor:   float  "Factor for how much surrounding objects contribute to light"
#+ * WorldLighting.passes -> passes:   int  "Number of preprocessing passes to reduce overocclusion (for approximate ambient occlusion)"
#+ * WorldLighting.sample_method -> sample_method:   enum  "Method for generating shadow samples (for Raytrace)"
#+ * WorldLighting.samples -> samples:   int  "Amount of ray samples. Higher values give smoother results and longer rendering times"
#+ * WorldLighting.threshold -> threshold:   float  "Samples below this threshold will be considered fully shadowed/unshadowed and skipped (for Raytrace Adaptive QMC)"
#+ * WorldLighting.use_ambient_occlusion -> use_ambient_occlusion:   boolean  "Use Ambient Occlusion to add shadowing based on distance between objects"
#WorldLighting.use_cache -> use_cache:   boolean  "Cache AO results in pixels and interpolate over neighbouring pixels for speedup (for Approximate)"
#WorldLighting.use_environment_light -> use_environment_light:   boolean  "Add light coming from the environment"
#WorldLighting.use_falloff -> use_falloff:   boolean  "NO DESCRIPTION"
#WorldLighting.use_indirect_light -> use_indirect_light:   boolean  "Add indirect light bouncing of surrounding objects"
#+ * WorldMistSettings.depth -> depth:   float  "The distance over which the mist effect fades in"
#+ * WorldMistSettings.falloff -> falloff:   enum  "Type of transition used to fade mist"
#+ * WorldMistSettings.height -> height:   float  "Control how much mist density decreases with height"
#+ * WorldMistSettings.intensity -> intensity:   float  "Intensity of the mist effect"
#+ * WorldMistSettings.start -> start:   float  "Starting distance of the mist, measured from the camera"
#+ * WorldMistSettings.use_mist -> use_mist:   boolean  "Occlude objects with the environment color as they are further away"
#+ * WorldStarsSettings.average_separation -> average_separation:   float  "Average distance between any two stars"
#WorldStarsSettings.color_random -> color_random:   float  "Randomize star colors"
#WorldStarsSettings.distance_min -> distance_min:   float  "Minimum distance to the camera for stars"
#+ * WorldStarsSettings.size -> size:   float  "Average screen dimension of stars"
#+ * WorldStarsSettings.use_stars -> use_stars:   boolean  "Enable starfield generation"
